
c:/Users/hanzo/code/dumpster-fire/target/1.5.2/photon/dumpster-fire.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00007fc4  080a001c  080a001c  0001001c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .backup       00000004  40024000  080a7fe0  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         000000d8  20000000  080a7fe4  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          0000059c  200000d8  200000d8  000400d8  2**2
                  ALLOC
  6 .module_info_suffix 00000028  080a80bc  080a80bc  000380bc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .module_info_crc 00000004  080a80e4  080a80e4  000380e4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_info   000ba5da  00000000  00000000  000380e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0001022a  00000000  00000000  000f26c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0001511d  00000000  00000000  001028ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00001ff0  00000000  00000000  00117a09  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00003540  00000000  00000000  001199f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000258ae  00000000  00000000  0011cf39  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00024bdb  00000000  00000000  001427e7  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000a9949  00000000  00000000  001673c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000baac  00000000  00000000  00210d0c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <link_dynalib_end+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <link_dynalib_end+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <link_dynalib_end+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f002 fbdf 	bl	80a27f0 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <link_dynalib_end+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <link_dynalib_end+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f002 fbe4 	bl	80a2806 <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <link_dynalib_end+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000000 	.word	0x20000000
 80a0048:	080a7fe4 	.word	0x080a7fe4
 80a004c:	200000d8 	.word	0x200000d8
 80a0050:	200000d8 	.word	0x200000d8
 80a0054:	20000674 	.word	0x20000674
 80a0058:	20000674 	.word	0x20000674

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f001 fe63 	bl	80a1d28 <module_user_init_hook>
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a7fa0 	.word	0x080a7fa0
 80a0084:	080a7fd4 	.word	0x080a7fd4

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 b8d6 	b.w	80a0238 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 f8f1 	bl	80a0274 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f001 be09 	b.w	80a1cac <_post_loop>

080a009a <_ZdlPv>:
 80a009a:	f001 bc2b 	b.w	80a18f4 <free>

080a009e <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a009e:	7800      	ldrb	r0, [r0, #0]
 80a00a0:	fab0 f080 	clz	r0, r0
 80a00a4:	0940      	lsrs	r0, r0, #5
 80a00a6:	4770      	bx	lr

080a00a8 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00a8:	2301      	movs	r3, #1
 80a00aa:	7003      	strb	r3, [r0, #0]
 80a00ac:	4770      	bx	lr
	...

080a00b0 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_>:
     { "/rsa-utils/prng4.js", "application/javascript", prng4_js },
     { nullptr }
};

void myPage(const char* url, ResponseCallback* cb, void* cbArg, Reader* body, Writer* result, void* reserved)
{
 80a00b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a00b4:	4607      	mov	r7, r0
 80a00b6:	b085      	sub	sp, #20
 80a00b8:	460c      	mov	r4, r1
 80a00ba:	4615      	mov	r5, r2
    Serial.printlnf("handling page %s", url);
 80a00bc:	f001 ff5c 	bl	80a1f78 <_Z16_fetch_usbserialv>
    }

    template <typename... Args>
    inline size_t printlnf(const char* format, Args... args)
    {
        return this->printf_impl(true, format, args...);
 80a00c0:	463b      	mov	r3, r7
 80a00c2:	4a29      	ldr	r2, [pc, #164]	; (80a0168 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xb8>)
 80a00c4:	2101      	movs	r1, #1
 80a00c6:	f001 fd4d 	bl	80a1b64 <_ZN5Print11printf_implEbPKcz>

    if (strcmp(url,"/index")==0) {
 80a00ca:	4928      	ldr	r1, [pc, #160]	; (80a016c <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xbc>)
 80a00cc:	4638      	mov	r0, r7
 80a00ce:	f002 fc05 	bl	80a28dc <strcmp>
 80a00d2:	4606      	mov	r6, r0
 80a00d4:	b998      	cbnz	r0, 80a00fe <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0x4e>
        Serial.println("sending redirect");
 80a00d6:	f001 ff4f 	bl	80a1f78 <_Z16_fetch_usbserialv>
 80a00da:	4925      	ldr	r1, [pc, #148]	; (80a0170 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xc0>)
 80a00dc:	f001 fd19 	bl	80a1b12 <_ZN5Print7printlnEPKc>

    struct __attribute__((packed)) Header {
    		uint16_t size;
    		const char* header_list;		// when non-null, a series of headers. Each header MUST be terminated by CRLF.

    		Header(const char* headers) : size(sizeof(*this)), header_list(headers) {}
 80a00e0:	2306      	movs	r3, #6
 80a00e2:	f8ad 3008 	strh.w	r3, [sp, #8]
 80a00e6:	4b23      	ldr	r3, [pc, #140]	; (80a0174 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xc4>)
        Header h("Location: /index.html\r\n");
        cb(cbArg, 0, 301, "text/plain", &h);
 80a00e8:	f240 122d 	movw	r2, #301	; 0x12d
 80a00ec:	f8cd 300a 	str.w	r3, [sp, #10]
 80a00f0:	ab02      	add	r3, sp, #8
 80a00f2:	9300      	str	r3, [sp, #0]
 80a00f4:	4631      	mov	r1, r6
 80a00f6:	4b20      	ldr	r3, [pc, #128]	; (80a0178 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xc8>)
 80a00f8:	4628      	mov	r0, r5
 80a00fa:	47a0      	blx	r4
 80a00fc:	e030      	b.n	80a0160 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xb0>
    }

    int8_t idx = 0;
    for (;;idx++) {
        Page& p = myPages[idx];
        if (!p.url) {
 80a00fe:	f8df b07c 	ldr.w	fp, [pc, #124]	; 80a017c <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xcc>
 80a0102:	2600      	movs	r6, #0
 80a0104:	f04f 080c 	mov.w	r8, #12
 80a0108:	fa4f fa86 	sxtb.w	sl, r6
 80a010c:	fb08 f20a 	mul.w	r2, r8, sl
 80a0110:	f85b 1002 	ldr.w	r1, [fp, r2]
 80a0114:	eb0b 0902 	add.w	r9, fp, r2
 80a0118:	b149      	cbz	r1, 80a012e <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0x7e>
            idx = -1;
            break;
        }
        else if (strcmp(url, p.url)==0) {
 80a011a:	4638      	mov	r0, r7
 80a011c:	f002 fbde 	bl	80a28dc <strcmp>
 80a0120:	3601      	adds	r6, #1
 80a0122:	4601      	mov	r1, r0
 80a0124:	2800      	cmp	r0, #0
 80a0126:	d1ef      	bne.n	80a0108 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0x58>
            break;
        }
    }

    if (idx==-1) {
 80a0128:	f1ba 3fff 	cmp.w	sl, #4294967295
 80a012c:	d107      	bne.n	80a013e <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0x8e>
        cb(cbArg, 0, 404, nullptr, nullptr);
 80a012e:	2300      	movs	r3, #0
 80a0130:	9300      	str	r3, [sp, #0]
 80a0132:	f44f 72ca 	mov.w	r2, #404	; 0x194
 80a0136:	4619      	mov	r1, r3
 80a0138:	4628      	mov	r0, r5
 80a013a:	47a0      	blx	r4
 80a013c:	e010      	b.n	80a0160 <_Z6myPagePKcPFiPvttS0_P6HeaderES1_P6ReaderP6WriterS1_+0xb0>
    }
    else {
        cb(cbArg, 0, 200, myPages[idx].mime_type, nullptr);
 80a013e:	9000      	str	r0, [sp, #0]
 80a0140:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80a0144:	22c8      	movs	r2, #200	; 0xc8
 80a0146:	4628      	mov	r0, r5
 80a0148:	47a0      	blx	r4
        result->write(myPages[idx].data);
 80a014a:	f8d9 4008 	ldr.w	r4, [r9, #8]
        inline void write(const uint8_t* buf, size_t length) {
            callback(this, buf, length);
        }

        inline void write(const char* s) {
            write((const uint8_t*)s, strlen(s));
 80a014e:	4620      	mov	r0, r4
 80a0150:	f002 fbce 	bl	80a28f0 <strlen>

        callback_t callback;
        void* state;

        inline void write(const uint8_t* buf, size_t length) {
            callback(this, buf, length);
 80a0154:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80a0156:	4602      	mov	r2, r0
 80a0158:	681b      	ldr	r3, [r3, #0]
 80a015a:	4621      	mov	r1, r4
 80a015c:	980e      	ldr	r0, [sp, #56]	; 0x38
 80a015e:	4798      	blx	r3
    }
}
 80a0160:	b005      	add	sp, #20
 80a0162:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a0166:	bf00      	nop
 80a0168:	080a5af2 	.word	0x080a5af2
 80a016c:	080a5b03 	.word	0x080a5b03
 80a0170:	080a5b0a 	.word	0x080a5b0a
 80a0174:	080a5b1b 	.word	0x080a5b1b
 80a0178:	080a5b33 	.word	0x080a5b33
 80a017c:	20000000 	.word	0x20000000

080a0180 <_Z10flameLight6String>:
{
  // do nothing, forever
}

int flameLight(String flameOn)
{
 80a0180:	b573      	push	{r0, r1, r4, r5, r6, lr}
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
 80a0182:	492b      	ldr	r1, [pc, #172]	; (80a0230 <_Z10flameLight6String+0xb0>)
 80a0184:	f001 fc7e 	bl	80a1a84 <_ZNK6String6equalsEPKc>
  if(flameOn == "on")
 80a0188:	2800      	cmp	r0, #0
 80a018a:	d049      	beq.n	80a0220 <_Z10flameLight6String+0xa0>

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a018c:	f001 fa54 	bl	80a1638 <HAL_Timer_Get_Milli_Seconds>
  {
    elapsedMillis timeElapsed;
    unsigned int interval = 10000; //duration * 1s
    while(timeElapsed < interval)
 80a0190:	f242 760f 	movw	r6, #9999	; 0x270f
 80a0194:	4605      	mov	r5, r0
 80a0196:	f001 fa4f 	bl	80a1638 <HAL_Timer_Get_Milli_Seconds>
 80a019a:	1b40      	subs	r0, r0, r5
 80a019c:	42b0      	cmp	r0, r6
 80a019e:	f04f 0400 	mov.w	r4, #0
 80a01a2:	d901      	bls.n	80a01a8 <_Z10flameLight6String+0x28>
      //  color switch delay to give a sense of realism
      delay(random(10,113));    
    }
    for(int i=0; i<strip.numPixels(); i++) 
      {
        strip.setPixelColor(i,0,0, 0);
 80a01a4:	4625      	mov	r5, r4
 80a01a6:	e028      	b.n	80a01fa <_Z10flameLight6String+0x7a>

      //  Green flame:
      //int r = 74, g = 150, b = 12;

      //  Flicker, based on our initial RGB values
      for(int i=0; i<strip.numPixels(); i++) 
 80a01a8:	4822      	ldr	r0, [pc, #136]	; (80a0234 <_Z10flameLight6String+0xb4>)
 80a01aa:	f001 f9ce 	bl	80a154a <_ZNK17Adafruit_NeoPixel9numPixelsEv>
 80a01ae:	4284      	cmp	r4, r0
 80a01b0:	da19      	bge.n	80a01e6 <_Z10flameLight6String+0x66>
      {
        int flicker = random(0,55);
 80a01b2:	2137      	movs	r1, #55	; 0x37
 80a01b4:	2000      	movs	r0, #0
 80a01b6:	f002 f810 	bl	80a21da <_Z6randomii>
        int r1 = r-flicker;
 80a01ba:	f1c0 02e2 	rsb	r2, r0, #226	; 0xe2
        int g1 = g-flicker;
 80a01be:	f1c0 0379 	rsb	r3, r0, #121	; 0x79
        int b1 = b-flicker;
 80a01c2:	f1c0 0023 	rsb	r0, r0, #35	; 0x23
        if(g1<0) g1=0;
        if(r1<0) r1=0;
        if(b1<0) b1=0;
        strip.setPixelColor(i,r1,g1, b1);
 80a01c6:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a01ca:	b2c0      	uxtb	r0, r0
 80a01cc:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80a01d0:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
 80a01d4:	9000      	str	r0, [sp, #0]
 80a01d6:	b2a1      	uxth	r1, r4
 80a01d8:	b2db      	uxtb	r3, r3
 80a01da:	b2d2      	uxtb	r2, r2
 80a01dc:	4815      	ldr	r0, [pc, #84]	; (80a0234 <_Z10flameLight6String+0xb4>)
 80a01de:	f001 f985 	bl	80a14ec <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>

      //  Green flame:
      //int r = 74, g = 150, b = 12;

      //  Flicker, based on our initial RGB values
      for(int i=0; i<strip.numPixels(); i++) 
 80a01e2:	3401      	adds	r4, #1
 80a01e4:	e7e0      	b.n	80a01a8 <_Z10flameLight6String+0x28>
        if(g1<0) g1=0;
        if(r1<0) r1=0;
        if(b1<0) b1=0;
        strip.setPixelColor(i,r1,g1, b1);
      }
      strip.show();
 80a01e6:	4813      	ldr	r0, [pc, #76]	; (80a0234 <_Z10flameLight6String+0xb4>)
 80a01e8:	f000 f8c6 	bl	80a0378 <_ZN17Adafruit_NeoPixel4showEv>

      //  Adjust the delay here, if you'd like.  Right now, it randomizes the 
      //  color switch delay to give a sense of realism
      delay(random(10,113));    
 80a01ec:	2171      	movs	r1, #113	; 0x71
 80a01ee:	200a      	movs	r0, #10
 80a01f0:	f001 fff3 	bl	80a21da <_Z6randomii>
 80a01f4:	f001 fd08 	bl	80a1c08 <delay>
{
  if(flameOn == "on")
  {
    elapsedMillis timeElapsed;
    unsigned int interval = 10000; //duration * 1s
    while(timeElapsed < interval)
 80a01f8:	e7cd      	b.n	80a0196 <_Z10flameLight6String+0x16>

      //  Adjust the delay here, if you'd like.  Right now, it randomizes the 
      //  color switch delay to give a sense of realism
      delay(random(10,113));    
    }
    for(int i=0; i<strip.numPixels(); i++) 
 80a01fa:	480e      	ldr	r0, [pc, #56]	; (80a0234 <_Z10flameLight6String+0xb4>)
 80a01fc:	f001 f9a5 	bl	80a154a <_ZNK17Adafruit_NeoPixel9numPixelsEv>
 80a0200:	4284      	cmp	r4, r0
 80a0202:	da08      	bge.n	80a0216 <_Z10flameLight6String+0x96>
      {
        strip.setPixelColor(i,0,0, 0);
 80a0204:	2300      	movs	r3, #0
 80a0206:	b2a1      	uxth	r1, r4
 80a0208:	9500      	str	r5, [sp, #0]
 80a020a:	461a      	mov	r2, r3
 80a020c:	4809      	ldr	r0, [pc, #36]	; (80a0234 <_Z10flameLight6String+0xb4>)
 80a020e:	f001 f96d 	bl	80a14ec <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>

      //  Adjust the delay here, if you'd like.  Right now, it randomizes the 
      //  color switch delay to give a sense of realism
      delay(random(10,113));    
    }
    for(int i=0; i<strip.numPixels(); i++) 
 80a0212:	3401      	adds	r4, #1
 80a0214:	e7f1      	b.n	80a01fa <_Z10flameLight6String+0x7a>
      {
        strip.setPixelColor(i,0,0, 0);
      }
      strip.show();
 80a0216:	4807      	ldr	r0, [pc, #28]	; (80a0234 <_Z10flameLight6String+0xb4>)
 80a0218:	f000 f8ae 	bl	80a0378 <_ZN17Adafruit_NeoPixel4showEv>

    //clear pixels?
    return 1;
 80a021c:	2001      	movs	r0, #1
 80a021e:	e004      	b.n	80a022a <_Z10flameLight6String+0xaa>
    
  }
  
  else
  {
    strip.clear();
 80a0220:	4804      	ldr	r0, [pc, #16]	; (80a0234 <_Z10flameLight6String+0xb4>)
 80a0222:	f001 f9ba 	bl	80a159a <_ZN17Adafruit_NeoPixel5clearEv>
    return -1;
 80a0226:	f04f 30ff 	mov.w	r0, #4294967295
  }
 80a022a:	b002      	add	sp, #8
 80a022c:	bd70      	pop	{r4, r5, r6, pc}
 80a022e:	bf00      	nop
 80a0230:	080a5b3e 	.word	0x080a5b3e
 80a0234:	200000dc 	.word	0x200000dc

080a0238 <setup>:
#define PIXEL_COUNT 18 // groups of "flames"
#define PIXEL_TYPE WS2812B

Adafruit_NeoPixel strip(PIXEL_COUNT, PIXEL_PIN, PIXEL_TYPE);

void setup() {
 80a0238:	b510      	push	{r4, lr}
  strip.begin();
 80a023a:	4c09      	ldr	r4, [pc, #36]	; (80a0260 <setup+0x28>)
 80a023c:	4620      	mov	r0, r4
 80a023e:	f000 f865 	bl	80a030c <_ZN17Adafruit_NeoPixel5beginEv>
  strip.setBrightness(brightness);
 80a0242:	4b08      	ldr	r3, [pc, #32]	; (80a0264 <setup+0x2c>)
 80a0244:	4620      	mov	r0, r4
 80a0246:	7819      	ldrb	r1, [r3, #0]
 80a0248:	f001 f981 	bl	80a154e <_ZN17Adafruit_NeoPixel13setBrightnessEh>
  strip.show(); // Initialize all pixels to 'off'
 80a024c:	4620      	mov	r0, r4
 80a024e:	f000 f893 	bl	80a0378 <_ZN17Adafruit_NeoPixel4showEv>
  Particle.function("flame", flameLight);
}
 80a0252:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        return _function(name, args...);
    }

    static bool _function(const char *funcKey, user_function_int_str_t* func)
    {
        return register_function(call_raw_user_function, (void*)func, funcKey);
 80a0256:	4a04      	ldr	r2, [pc, #16]	; (80a0268 <setup+0x30>)
 80a0258:	4904      	ldr	r1, [pc, #16]	; (80a026c <setup+0x34>)
 80a025a:	4805      	ldr	r0, [pc, #20]	; (80a0270 <setup+0x38>)
 80a025c:	f001 bda6 	b.w	80a1dac <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a0260:	200000dc 	.word	0x200000dc
 80a0264:	2000006c 	.word	0x2000006c
 80a0268:	080a5b41 	.word	0x080a5b41
 80a026c:	080a0181 	.word	0x080a0181
 80a0270:	080a1d81 	.word	0x080a1d81

080a0274 <loop>:

void loop()
{
 80a0274:	4770      	bx	lr
	...

080a0278 <_GLOBAL__sub_I_myPages>:
  else
  {
    strip.clear();
    return -1;
  }
 80a0278:	b510      	push	{r4, lr}

#define PIXEL_PIN D3
#define PIXEL_COUNT 18 // groups of "flames"
#define PIXEL_TYPE WS2812B

Adafruit_NeoPixel strip(PIXEL_COUNT, PIXEL_PIN, PIXEL_TYPE);
 80a027a:	4c0a      	ldr	r4, [pc, #40]	; (80a02a4 <_GLOBAL__sub_I_myPages+0x2c>)
inline int32_t pinReadFast(pin_t _pin)
{
    return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static Hal_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a027c:	f001 f99c 	bl	80a15b8 <HAL_Pin_Map>
        cb(cbArg, 0, 200, myPages[idx].mime_type, nullptr);
        result->write(myPages[idx].data);
    }
}

STARTUP(softap_set_application_page_handler(myPage, nullptr));
 80a0280:	2100      	movs	r1, #0
 80a0282:	4809      	ldr	r0, [pc, #36]	; (80a02a8 <_GLOBAL__sub_I_myPages+0x30>)
 80a0284:	f001 faa2 	bl	80a17cc <softap_set_application_page_handler>

#define PIXEL_PIN D3
#define PIXEL_COUNT 18 // groups of "flames"
#define PIXEL_TYPE WS2812B

Adafruit_NeoPixel strip(PIXEL_COUNT, PIXEL_PIN, PIXEL_TYPE);
 80a0288:	2203      	movs	r2, #3
 80a028a:	2112      	movs	r1, #18
 80a028c:	4620      	mov	r0, r4
 80a028e:	2302      	movs	r3, #2
 80a0290:	f000 f861 	bl	80a0356 <_ZN17Adafruit_NeoPixelC1Ethh>
 80a0294:	4620      	mov	r0, r4
  else
  {
    strip.clear();
    return -1;
  }
 80a0296:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

#define PIXEL_PIN D3
#define PIXEL_COUNT 18 // groups of "flames"
#define PIXEL_TYPE WS2812B

Adafruit_NeoPixel strip(PIXEL_COUNT, PIXEL_PIN, PIXEL_TYPE);
 80a029a:	4a04      	ldr	r2, [pc, #16]	; (80a02ac <_GLOBAL__sub_I_myPages+0x34>)
 80a029c:	4904      	ldr	r1, [pc, #16]	; (80a02b0 <_GLOBAL__sub_I_myPages+0x38>)
 80a029e:	f002 b92f 	b.w	80a2500 <__aeabi_atexit>
 80a02a2:	bf00      	nop
 80a02a4:	200000dc 	.word	0x200000dc
 80a02a8:	080a00b1 	.word	0x080a00b1
 80a02ac:	200000d8 	.word	0x200000d8
 80a02b0:	080a02b9 	.word	0x080a02b9

080a02b4 <micros>:
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a02b4:	f001 b9b8 	b.w	80a1628 <HAL_Timer_Get_Micro_Seconds>

080a02b8 <_ZN17Adafruit_NeoPixelD1Ev>:
{
  updateLength(n);
  setPin(p);
}

Adafruit_NeoPixel::~Adafruit_NeoPixel() {
 80a02b8:	b510      	push	{r4, lr}
 80a02ba:	4604      	mov	r4, r0
  if (pixels) free(pixels);
 80a02bc:	68c0      	ldr	r0, [r0, #12]
 80a02be:	b108      	cbz	r0, 80a02c4 <_ZN17Adafruit_NeoPixelD1Ev+0xc>
 80a02c0:	f001 fb18 	bl	80a18f4 <free>
  if (begun) pinMode(pin, INPUT);
 80a02c4:	7823      	ldrb	r3, [r4, #0]
 80a02c6:	b11b      	cbz	r3, 80a02d0 <_ZN17Adafruit_NeoPixelD1Ev+0x18>
 80a02c8:	2100      	movs	r1, #0
 80a02ca:	79e0      	ldrb	r0, [r4, #7]
 80a02cc:	f002 f896 	bl	80a23fc <pinMode>
}
 80a02d0:	4620      	mov	r0, r4
 80a02d2:	bd10      	pop	{r4, pc}

080a02d4 <_ZN17Adafruit_NeoPixel12updateLengthEt>:

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a02d4:	b538      	push	{r3, r4, r5, lr}
 80a02d6:	4604      	mov	r4, r0
  if (pixels) free(pixels); // Free existing data (if any)
 80a02d8:	68c0      	ldr	r0, [r0, #12]
Adafruit_NeoPixel::~Adafruit_NeoPixel() {
  if (pixels) free(pixels);
  if (begun) pinMode(pin, INPUT);
}

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a02da:	460d      	mov	r5, r1
  if (pixels) free(pixels); // Free existing data (if any)
 80a02dc:	b108      	cbz	r0, 80a02e2 <_ZN17Adafruit_NeoPixel12updateLengthEt+0xe>
 80a02de:	f001 fb09 	bl	80a18f4 <free>

  // Allocate new data -- note: ALL PIXELS ARE CLEARED
  numBytes = n * ((type == SK6812RGBW) ? 4 : 3);
 80a02e2:	79a3      	ldrb	r3, [r4, #6]
 80a02e4:	2b06      	cmp	r3, #6
 80a02e6:	bf0c      	ite	eq
 80a02e8:	2004      	moveq	r0, #4
 80a02ea:	2003      	movne	r0, #3
 80a02ec:	4368      	muls	r0, r5
 80a02ee:	b280      	uxth	r0, r0
 80a02f0:	80a0      	strh	r0, [r4, #4]
  if ((pixels = (uint8_t *)malloc(numBytes))) {
 80a02f2:	f001 faf7 	bl	80a18e4 <malloc>
 80a02f6:	60e0      	str	r0, [r4, #12]
 80a02f8:	b128      	cbz	r0, 80a0306 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x32>
    memset(pixels, 0, numBytes);
 80a02fa:	88a2      	ldrh	r2, [r4, #4]
 80a02fc:	2100      	movs	r1, #0
 80a02fe:	f002 fa82 	bl	80a2806 <memset>
    numLEDs = n;
 80a0302:	8065      	strh	r5, [r4, #2]
 80a0304:	bd38      	pop	{r3, r4, r5, pc}
  } else {
    numLEDs = numBytes = 0;
 80a0306:	80a0      	strh	r0, [r4, #4]
 80a0308:	8060      	strh	r0, [r4, #2]
 80a030a:	bd38      	pop	{r3, r4, r5, pc}

080a030c <_ZN17Adafruit_NeoPixel5beginEv>:
  }
}

void Adafruit_NeoPixel::begin(void) {
 80a030c:	b510      	push	{r4, lr}
 80a030e:	4604      	mov	r4, r0
  pinMode(pin, OUTPUT);
 80a0310:	2101      	movs	r1, #1
 80a0312:	79c0      	ldrb	r0, [r0, #7]
 80a0314:	f002 f872 	bl	80a23fc <pinMode>
  digitalWrite(pin, LOW);
 80a0318:	2100      	movs	r1, #0
 80a031a:	79e0      	ldrb	r0, [r4, #7]
 80a031c:	f002 f87f 	bl	80a241e <digitalWrite>
  begun = true;
 80a0320:	2301      	movs	r3, #1
 80a0322:	7023      	strb	r3, [r4, #0]
 80a0324:	bd10      	pop	{r4, pc}

080a0326 <_ZN17Adafruit_NeoPixel6setPinEh>:
}

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a0326:	b538      	push	{r3, r4, r5, lr}
    if (begun) {
 80a0328:	7803      	ldrb	r3, [r0, #0]
  digitalWrite(pin, LOW);
  begun = true;
}

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a032a:	4605      	mov	r5, r0
 80a032c:	460c      	mov	r4, r1
    if (begun) {
 80a032e:	b11b      	cbz	r3, 80a0338 <_ZN17Adafruit_NeoPixel6setPinEh+0x12>
        pinMode(pin, INPUT);
 80a0330:	2100      	movs	r1, #0
 80a0332:	79c0      	ldrb	r0, [r0, #7]
 80a0334:	f002 f862 	bl	80a23fc <pinMode>
    }
    pin = p;
    if (begun) {
 80a0338:	782b      	ldrb	r3, [r5, #0]
// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
    if (begun) {
        pinMode(pin, INPUT);
    }
    pin = p;
 80a033a:	71ec      	strb	r4, [r5, #7]
    if (begun) {
 80a033c:	b153      	cbz	r3, 80a0354 <_ZN17Adafruit_NeoPixel6setPinEh+0x2e>
        pinMode(p, OUTPUT);
 80a033e:	b2a4      	uxth	r4, r4
 80a0340:	4620      	mov	r0, r4
 80a0342:	2101      	movs	r1, #1
 80a0344:	f002 f85a 	bl	80a23fc <pinMode>
        digitalWrite(p, LOW);
 80a0348:	4620      	mov	r0, r4
    }
}
 80a034a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        pinMode(pin, INPUT);
    }
    pin = p;
    if (begun) {
        pinMode(p, OUTPUT);
        digitalWrite(p, LOW);
 80a034e:	2100      	movs	r1, #0
 80a0350:	f002 b865 	b.w	80a241e <digitalWrite>
 80a0354:	bd38      	pop	{r3, r4, r5, pc}

080a0356 <_ZN17Adafruit_NeoPixelC1Ethh>:
  #error "*** PLATFORM_ID not supported by this library. PLATFORM should be Particle Core, Photon, Electron, Argon, Boron, Xenon and RedBear Duo ***"
#endif
// fast pin access
#define pinSet(_pin, _hilo) (_hilo ? pinHI(_pin) : pinLO(_pin))

Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :
 80a0356:	b570      	push	{r4, r5, r6, lr}
 80a0358:	4604      	mov	r4, r0
 80a035a:	4616      	mov	r6, r2
  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)
 80a035c:	2500      	movs	r5, #0
 80a035e:	7183      	strb	r3, [r0, #6]
 80a0360:	7005      	strb	r5, [r0, #0]
 80a0362:	7205      	strb	r5, [r0, #8]
 80a0364:	60c5      	str	r5, [r0, #12]
 80a0366:	6105      	str	r5, [r0, #16]
{
  updateLength(n);
 80a0368:	f7ff ffb4 	bl	80a02d4 <_ZN17Adafruit_NeoPixel12updateLengthEt>
  setPin(p);
 80a036c:	4620      	mov	r0, r4
 80a036e:	4631      	mov	r1, r6
 80a0370:	f7ff ffd9 	bl	80a0326 <_ZN17Adafruit_NeoPixel6setPinEh>
}
 80a0374:	4620      	mov	r0, r4
 80a0376:	bd70      	pop	{r4, r5, r6, pc}

080a0378 <_ZN17Adafruit_NeoPixel4showEv>:
        digitalWrite(p, LOW);
    }
}

void Adafruit_NeoPixel::show(void) {
  if(!pixels) return;
 80a0378:	68c3      	ldr	r3, [r0, #12]
 80a037a:	2b00      	cmp	r3, #0
 80a037c:	f000 858e 	beq.w	80a0e9c <_ZN17Adafruit_NeoPixel4showEv+0xb24>
        pinMode(p, OUTPUT);
        digitalWrite(p, LOW);
    }
}

void Adafruit_NeoPixel::show(void) {
 80a0380:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a0384:	4604      	mov	r4, r0
 80a0386:	7983      	ldrb	r3, [r0, #6]
 80a0388:	b086      	sub	sp, #24
 80a038a:	3b02      	subs	r3, #2
 80a038c:	b2db      	uxtb	r3, r3
 80a038e:	2b04      	cmp	r3, #4
 80a0390:	bf96      	itet	ls
 80a0392:	4a29      	ldrls	r2, [pc, #164]	; (80a0438 <_ZN17Adafruit_NeoPixel4showEv+0xc0>)
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  uint32_t wait_time; // wait time in microseconds.
  switch(type) {
 80a0394:	2532      	movhi	r5, #50	; 0x32
 80a0396:	f852 5023 	ldrls.w	r5, [r2, r3, lsl #2]
    case WS2812B2_FAST:
    default: {   // default = 50us reset pulse
        wait_time = 50L;
      } break;
  }
  while((micros() - endTime) < wait_time);
 80a039a:	f7ff ff8b 	bl	80a02b4 <micros>
 80a039e:	6923      	ldr	r3, [r4, #16]
 80a03a0:	1ac0      	subs	r0, r0, r3
 80a03a2:	42a8      	cmp	r0, r5
 80a03a4:	d3f9      	bcc.n	80a039a <_ZN17Adafruit_NeoPixel4showEv+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 80a03a6:	b672      	cpsid	i
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a03a8:	79a1      	ldrb	r1, [r4, #6]
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a03aa:	88a3      	ldrh	r3, [r4, #4]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a03ac:	2902      	cmp	r1, #2
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a03ae:	f8ad 300a 	strh.w	r3, [sp, #10]
  volatile uint8_t
    j,              // 8-bit inner loop counter
   *ptr = pixels,   // Pointer to next byte
 80a03b2:	f8d4 e00c 	ldr.w	lr, [r4, #12]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a03b6:	f000 8272 	beq.w	80a089e <_ZN17Adafruit_NeoPixel4showEv+0x526>
 80a03ba:	2907      	cmp	r1, #7
 80a03bc:	f000 826f 	beq.w	80a089e <_ZN17Adafruit_NeoPixel4showEv+0x526>
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
 80a03c0:	2906      	cmp	r1, #6
 80a03c2:	f000 8432 	beq.w	80a0c2a <_ZN17Adafruit_NeoPixel4showEv+0x8b2>
        }
        mask >>= 1;
      } while ( ++j < 32 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == WS2812B2 || type == WS2812B2_FAST) { // WS2812B with DWT timer
 80a03c6:	2905      	cmp	r1, #5
 80a03c8:	f000 83ab 	beq.w	80a0b22 <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
 80a03cc:	2908      	cmp	r1, #8
 80a03ce:	f000 83a8 	beq.w	80a0b22 <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
 80a03d2:	2900      	cmp	r1, #0
 80a03d4:	f040 8563 	bne.w	80a0e9e <_ZN17Adafruit_NeoPixel4showEv+0xb26>
 80a03d8:	4a18      	ldr	r2, [pc, #96]	; (80a043c <_ZN17Adafruit_NeoPixel4showEv+0xc4>)
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a03da:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a03de:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a03e2:	b29b      	uxth	r3, r3
 80a03e4:	2b00      	cmp	r3, #0
 80a03e6:	f000 8395 	beq.w	80a0b14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a03ea:	9604      	str	r6, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a03ec:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a03f0:	f10e 0503 	add.w	r5, lr, #3
 80a03f4:	3b03      	subs	r3, #3
 80a03f6:	b29b      	uxth	r3, r3
 80a03f8:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a03fc:	f89e 3000 	ldrb.w	r3, [lr]
 80a0400:	b2db      	uxtb	r3, r3
 80a0402:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a0406:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a040a:	b2db      	uxtb	r3, r3
 80a040c:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a0410:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a0414:	b2db      	uxtb	r3, r3
 80a0416:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a041a:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a041e:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a0422:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a0426:	021b      	lsls	r3, r3, #8
 80a0428:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a042c:	4303      	orrs	r3, r0
 80a042e:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a0430:	f88d 1005 	strb.w	r1, [sp, #5]
 80a0434:	e11b      	b.n	80a066e <_ZN17Adafruit_NeoPixel4showEv+0x2f6>
 80a0436:	bf00      	nop
 80a0438:	080a7d14 	.word	0x080a7d14
 80a043c:	200000f0 	.word	0x200000f0
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0440:	4600      	mov	r0, r0
 80a0442:	bf00      	nop
 80a0444:	bf00      	nop
 80a0446:	bf00      	nop
 80a0448:	bf00      	nop
 80a044a:	bf00      	nop
 80a044c:	bf00      	nop
 80a044e:	bf00      	nop
 80a0450:	bf00      	nop
 80a0452:	bf00      	nop
 80a0454:	bf00      	nop
 80a0456:	bf00      	nop
 80a0458:	bf00      	nop
 80a045a:	bf00      	nop
 80a045c:	bf00      	nop
 80a045e:	bf00      	nop
 80a0460:	bf00      	nop
 80a0462:	bf00      	nop
 80a0464:	bf00      	nop
 80a0466:	bf00      	nop
 80a0468:	bf00      	nop
 80a046a:	bf00      	nop
 80a046c:	bf00      	nop
 80a046e:	bf00      	nop
 80a0470:	bf00      	nop
 80a0472:	bf00      	nop
 80a0474:	bf00      	nop
 80a0476:	bf00      	nop
 80a0478:	bf00      	nop
 80a047a:	bf00      	nop
 80a047c:	bf00      	nop
 80a047e:	bf00      	nop
 80a0480:	bf00      	nop
 80a0482:	bf00      	nop
 80a0484:	bf00      	nop
 80a0486:	bf00      	nop
 80a0488:	bf00      	nop
 80a048a:	bf00      	nop
 80a048c:	bf00      	nop
 80a048e:	bf00      	nop
 80a0490:	bf00      	nop
 80a0492:	bf00      	nop
 80a0494:	bf00      	nop
 80a0496:	bf00      	nop
 80a0498:	bf00      	nop
 80a049a:	bf00      	nop
 80a049c:	bf00      	nop
 80a049e:	bf00      	nop
 80a04a0:	bf00      	nop
 80a04a2:	bf00      	nop
 80a04a4:	bf00      	nop
 80a04a6:	bf00      	nop
 80a04a8:	bf00      	nop
 80a04aa:	bf00      	nop
 80a04ac:	bf00      	nop
 80a04ae:	bf00      	nop
 80a04b0:	bf00      	nop
 80a04b2:	bf00      	nop
 80a04b4:	bf00      	nop
 80a04b6:	bf00      	nop
 80a04b8:	bf00      	nop
 80a04ba:	bf00      	nop
 80a04bc:	bf00      	nop
 80a04be:	bf00      	nop
 80a04c0:	bf00      	nop
 80a04c2:	bf00      	nop
 80a04c4:	bf00      	nop
 80a04c6:	bf00      	nop
 80a04c8:	bf00      	nop
 80a04ca:	bf00      	nop
 80a04cc:	bf00      	nop
 80a04ce:	bf00      	nop
 80a04d0:	bf00      	nop
 80a04d2:	bf00      	nop
 80a04d4:	bf00      	nop
 80a04d6:	bf00      	nop
 80a04d8:	bf00      	nop
 80a04da:	bf00      	nop
 80a04dc:	bf00      	nop
 80a04de:	bf00      	nop
 80a04e0:	bf00      	nop
 80a04e2:	bf00      	nop
 80a04e4:	bf00      	nop
 80a04e6:	bf00      	nop
 80a04e8:	bf00      	nop
 80a04ea:	bf00      	nop
 80a04ec:	bf00      	nop
 80a04ee:	bf00      	nop
 80a04f0:	bf00      	nop
 80a04f2:	bf00      	nop
 80a04f4:	bf00      	nop
 80a04f6:	bf00      	nop
 80a04f8:	bf00      	nop
 80a04fa:	bf00      	nop
 80a04fc:	bf00      	nop
 80a04fe:	bf00      	nop
 80a0500:	bf00      	nop
 80a0502:	bf00      	nop
 80a0504:	bf00      	nop
 80a0506:	bf00      	nop
 80a0508:	bf00      	nop
 80a050a:	bf00      	nop
 80a050c:	bf00      	nop
 80a050e:	bf00      	nop
 80a0510:	bf00      	nop
 80a0512:	bf00      	nop
 80a0514:	bf00      	nop
 80a0516:	bf00      	nop
 80a0518:	bf00      	nop
 80a051a:	bf00      	nop
 80a051c:	bf00      	nop
 80a051e:	bf00      	nop
 80a0520:	bf00      	nop
 80a0522:	bf00      	nop
 80a0524:	bf00      	nop
 80a0526:	bf00      	nop
 80a0528:	bf00      	nop
 80a052a:	bf00      	nop
 80a052c:	bf00      	nop
 80a052e:	bf00      	nop
 80a0530:	bf00      	nop
 80a0532:	bf00      	nop
 80a0534:	bf00      	nop
 80a0536:	bf00      	nop
 80a0538:	bf00      	nop
 80a053a:	bf00      	nop
 80a053c:	bf00      	nop
 80a053e:	bf00      	nop
 80a0540:	bf00      	nop
 80a0542:	bf00      	nop
 80a0544:	bf00      	nop
 80a0546:	bf00      	nop
          // WS2811 spec             1.30us LOW
          // Adafruit on Arduino    (meas. 1.25us)
          // This lib on Spark Core (meas. 1.24us)
          // This lib on Photon     (meas. 1.24us)
          pinSet(pin, LOW); // LOW
 80a0548:	79e3      	ldrb	r3, [r4, #7]
 80a054a:	6810      	ldr	r0, [r2, #0]
 80a054c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0550:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0554:	88bf      	ldrh	r7, [r7, #4]
 80a0556:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a055a:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a055c:	4600      	mov	r0, r0
 80a055e:	bf00      	nop
 80a0560:	bf00      	nop
 80a0562:	bf00      	nop
 80a0564:	bf00      	nop
 80a0566:	bf00      	nop
 80a0568:	bf00      	nop
 80a056a:	bf00      	nop
 80a056c:	bf00      	nop
 80a056e:	bf00      	nop
 80a0570:	bf00      	nop
 80a0572:	bf00      	nop
 80a0574:	bf00      	nop
 80a0576:	bf00      	nop
 80a0578:	bf00      	nop
 80a057a:	bf00      	nop
 80a057c:	bf00      	nop
 80a057e:	bf00      	nop
 80a0580:	bf00      	nop
 80a0582:	bf00      	nop
 80a0584:	bf00      	nop
 80a0586:	bf00      	nop
 80a0588:	bf00      	nop
 80a058a:	bf00      	nop
 80a058c:	bf00      	nop
 80a058e:	bf00      	nop
 80a0590:	bf00      	nop
 80a0592:	bf00      	nop
 80a0594:	bf00      	nop
 80a0596:	bf00      	nop
 80a0598:	bf00      	nop
 80a059a:	bf00      	nop
 80a059c:	bf00      	nop
 80a059e:	bf00      	nop
 80a05a0:	bf00      	nop
 80a05a2:	bf00      	nop
 80a05a4:	bf00      	nop
 80a05a6:	bf00      	nop
 80a05a8:	bf00      	nop
 80a05aa:	bf00      	nop
 80a05ac:	bf00      	nop
 80a05ae:	bf00      	nop
 80a05b0:	bf00      	nop
 80a05b2:	bf00      	nop
 80a05b4:	bf00      	nop
 80a05b6:	bf00      	nop
 80a05b8:	bf00      	nop
 80a05ba:	bf00      	nop
 80a05bc:	bf00      	nop
 80a05be:	bf00      	nop
 80a05c0:	bf00      	nop
 80a05c2:	bf00      	nop
 80a05c4:	bf00      	nop
 80a05c6:	bf00      	nop
 80a05c8:	bf00      	nop
 80a05ca:	bf00      	nop
 80a05cc:	bf00      	nop
 80a05ce:	bf00      	nop
 80a05d0:	bf00      	nop
 80a05d2:	bf00      	nop
 80a05d4:	bf00      	nop
 80a05d6:	bf00      	nop
 80a05d8:	bf00      	nop
 80a05da:	bf00      	nop
 80a05dc:	bf00      	nop
 80a05de:	bf00      	nop
 80a05e0:	bf00      	nop
 80a05e2:	bf00      	nop
 80a05e4:	bf00      	nop
 80a05e6:	bf00      	nop
 80a05e8:	bf00      	nop
 80a05ea:	bf00      	nop
 80a05ec:	bf00      	nop
 80a05ee:	bf00      	nop
 80a05f0:	bf00      	nop
 80a05f2:	bf00      	nop
 80a05f4:	bf00      	nop
 80a05f6:	bf00      	nop
 80a05f8:	bf00      	nop
 80a05fa:	bf00      	nop
 80a05fc:	bf00      	nop
 80a05fe:	bf00      	nop
 80a0600:	bf00      	nop
 80a0602:	bf00      	nop
 80a0604:	bf00      	nop
 80a0606:	bf00      	nop
 80a0608:	bf00      	nop
 80a060a:	bf00      	nop
 80a060c:	bf00      	nop
 80a060e:	bf00      	nop
 80a0610:	bf00      	nop
 80a0612:	bf00      	nop
 80a0614:	bf00      	nop
 80a0616:	bf00      	nop
 80a0618:	bf00      	nop
 80a061a:	bf00      	nop
 80a061c:	bf00      	nop
 80a061e:	bf00      	nop
 80a0620:	bf00      	nop
 80a0622:	bf00      	nop
 80a0624:	bf00      	nop
 80a0626:	bf00      	nop
 80a0628:	bf00      	nop
 80a062a:	bf00      	nop
 80a062c:	bf00      	nop
 80a062e:	bf00      	nop
 80a0630:	bf00      	nop
 80a0632:	bf00      	nop
 80a0634:	bf00      	nop
 80a0636:	bf00      	nop
 80a0638:	bf00      	nop
 80a063a:	bf00      	nop
 80a063c:	bf00      	nop
 80a063e:	bf00      	nop
 80a0640:	bf00      	nop
 80a0642:	bf00      	nop
 80a0644:	bf00      	nop
 80a0646:	bf00      	nop
 80a0648:	bf00      	nop
 80a064a:	bf00      	nop
 80a064c:	bf00      	nop
 80a064e:	bf00      	nop
 80a0650:	bf00      	nop
 80a0652:	bf00      	nop
 80a0654:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a0656:	9b04      	ldr	r3, [sp, #16]
 80a0658:	085b      	lsrs	r3, r3, #1
 80a065a:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a065c:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a0660:	3301      	adds	r3, #1
 80a0662:	b2db      	uxtb	r3, r3
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a0664:	2b17      	cmp	r3, #23
 80a0666:	f88d 3005 	strb.w	r3, [sp, #5]
 80a066a:	f200 82db 	bhi.w	80a0c24 <_ZN17Adafruit_NeoPixel4showEv+0x8ac>
        pinSet(pin, HIGH); // HIGH
 80a066e:	79e3      	ldrb	r3, [r4, #7]
 80a0670:	6810      	ldr	r0, [r2, #0]
 80a0672:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0676:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a067a:	88bf      	ldrh	r7, [r7, #4]
 80a067c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0680:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a0682:	9803      	ldr	r0, [sp, #12]
 80a0684:	9b04      	ldr	r3, [sp, #16]
 80a0686:	4218      	tst	r0, r3
 80a0688:	f47f aeda 	bne.w	80a0440 <_ZN17Adafruit_NeoPixel4showEv+0xc8>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            "nop" "\n\t" "nop" "\n\t"
            ::: "r0", "cc", "memory");
 80a068c:	4600      	mov	r0, r0
 80a068e:	bf00      	nop
 80a0690:	bf00      	nop
 80a0692:	bf00      	nop
 80a0694:	bf00      	nop
 80a0696:	bf00      	nop
 80a0698:	bf00      	nop
 80a069a:	bf00      	nop
 80a069c:	bf00      	nop
 80a069e:	bf00      	nop
 80a06a0:	bf00      	nop
 80a06a2:	bf00      	nop
 80a06a4:	bf00      	nop
 80a06a6:	bf00      	nop
 80a06a8:	bf00      	nop
 80a06aa:	bf00      	nop
 80a06ac:	bf00      	nop
 80a06ae:	bf00      	nop
 80a06b0:	bf00      	nop
 80a06b2:	bf00      	nop
 80a06b4:	bf00      	nop
 80a06b6:	bf00      	nop
 80a06b8:	bf00      	nop
 80a06ba:	bf00      	nop
 80a06bc:	bf00      	nop
 80a06be:	bf00      	nop
 80a06c0:	bf00      	nop
 80a06c2:	bf00      	nop
 80a06c4:	bf00      	nop
 80a06c6:	bf00      	nop
 80a06c8:	bf00      	nop
 80a06ca:	bf00      	nop
 80a06cc:	bf00      	nop
 80a06ce:	bf00      	nop
 80a06d0:	bf00      	nop
 80a06d2:	bf00      	nop
 80a06d4:	bf00      	nop
 80a06d6:	bf00      	nop
 80a06d8:	bf00      	nop
 80a06da:	bf00      	nop
 80a06dc:	bf00      	nop
          // WS2811 spec             2.000us LOW
          // Adafruit on Arduino    (meas. 2.000us)
          // This lib on Spark Core (meas. 2.000us)
          // This lib on Photon     (meas. 2.000us)
          pinSet(pin, LOW); // LOW
 80a06de:	79e3      	ldrb	r3, [r4, #7]
 80a06e0:	6810      	ldr	r0, [r2, #0]
 80a06e2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a06e6:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a06ea:	88bf      	ldrh	r7, [r7, #4]
 80a06ec:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a06f0:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a06f2:	4600      	mov	r0, r0
 80a06f4:	bf00      	nop
 80a06f6:	bf00      	nop
 80a06f8:	bf00      	nop
 80a06fa:	bf00      	nop
 80a06fc:	bf00      	nop
 80a06fe:	bf00      	nop
 80a0700:	bf00      	nop
 80a0702:	bf00      	nop
 80a0704:	bf00      	nop
 80a0706:	bf00      	nop
 80a0708:	bf00      	nop
 80a070a:	bf00      	nop
 80a070c:	bf00      	nop
 80a070e:	bf00      	nop
 80a0710:	bf00      	nop
 80a0712:	bf00      	nop
 80a0714:	bf00      	nop
 80a0716:	bf00      	nop
 80a0718:	bf00      	nop
 80a071a:	bf00      	nop
 80a071c:	bf00      	nop
 80a071e:	bf00      	nop
 80a0720:	bf00      	nop
 80a0722:	bf00      	nop
 80a0724:	bf00      	nop
 80a0726:	bf00      	nop
 80a0728:	bf00      	nop
 80a072a:	bf00      	nop
 80a072c:	bf00      	nop
 80a072e:	bf00      	nop
 80a0730:	bf00      	nop
 80a0732:	bf00      	nop
 80a0734:	bf00      	nop
 80a0736:	bf00      	nop
 80a0738:	bf00      	nop
 80a073a:	bf00      	nop
 80a073c:	bf00      	nop
 80a073e:	bf00      	nop
 80a0740:	bf00      	nop
 80a0742:	bf00      	nop
 80a0744:	bf00      	nop
 80a0746:	bf00      	nop
 80a0748:	bf00      	nop
 80a074a:	bf00      	nop
 80a074c:	bf00      	nop
 80a074e:	bf00      	nop
 80a0750:	bf00      	nop
 80a0752:	bf00      	nop
 80a0754:	bf00      	nop
 80a0756:	bf00      	nop
 80a0758:	bf00      	nop
 80a075a:	bf00      	nop
 80a075c:	bf00      	nop
 80a075e:	bf00      	nop
 80a0760:	bf00      	nop
 80a0762:	bf00      	nop
 80a0764:	bf00      	nop
 80a0766:	bf00      	nop
 80a0768:	bf00      	nop
 80a076a:	bf00      	nop
 80a076c:	bf00      	nop
 80a076e:	bf00      	nop
 80a0770:	bf00      	nop
 80a0772:	bf00      	nop
 80a0774:	bf00      	nop
 80a0776:	bf00      	nop
 80a0778:	bf00      	nop
 80a077a:	bf00      	nop
 80a077c:	bf00      	nop
 80a077e:	bf00      	nop
 80a0780:	bf00      	nop
 80a0782:	bf00      	nop
 80a0784:	bf00      	nop
 80a0786:	bf00      	nop
 80a0788:	bf00      	nop
 80a078a:	bf00      	nop
 80a078c:	bf00      	nop
 80a078e:	bf00      	nop
 80a0790:	bf00      	nop
 80a0792:	bf00      	nop
 80a0794:	bf00      	nop
 80a0796:	bf00      	nop
 80a0798:	bf00      	nop
 80a079a:	bf00      	nop
 80a079c:	bf00      	nop
 80a079e:	bf00      	nop
 80a07a0:	bf00      	nop
 80a07a2:	bf00      	nop
 80a07a4:	bf00      	nop
 80a07a6:	bf00      	nop
 80a07a8:	bf00      	nop
 80a07aa:	bf00      	nop
 80a07ac:	bf00      	nop
 80a07ae:	bf00      	nop
 80a07b0:	bf00      	nop
 80a07b2:	bf00      	nop
 80a07b4:	bf00      	nop
 80a07b6:	bf00      	nop
 80a07b8:	bf00      	nop
 80a07ba:	bf00      	nop
 80a07bc:	bf00      	nop
 80a07be:	bf00      	nop
 80a07c0:	bf00      	nop
 80a07c2:	bf00      	nop
 80a07c4:	bf00      	nop
 80a07c6:	bf00      	nop
 80a07c8:	bf00      	nop
 80a07ca:	bf00      	nop
 80a07cc:	bf00      	nop
 80a07ce:	bf00      	nop
 80a07d0:	bf00      	nop
 80a07d2:	bf00      	nop
 80a07d4:	bf00      	nop
 80a07d6:	bf00      	nop
 80a07d8:	bf00      	nop
 80a07da:	bf00      	nop
 80a07dc:	bf00      	nop
 80a07de:	bf00      	nop
 80a07e0:	bf00      	nop
 80a07e2:	bf00      	nop
 80a07e4:	bf00      	nop
 80a07e6:	bf00      	nop
 80a07e8:	bf00      	nop
 80a07ea:	bf00      	nop
 80a07ec:	bf00      	nop
 80a07ee:	bf00      	nop
 80a07f0:	bf00      	nop
 80a07f2:	bf00      	nop
 80a07f4:	bf00      	nop
 80a07f6:	bf00      	nop
 80a07f8:	bf00      	nop
 80a07fa:	bf00      	nop
 80a07fc:	bf00      	nop
 80a07fe:	bf00      	nop
 80a0800:	bf00      	nop
 80a0802:	bf00      	nop
 80a0804:	bf00      	nop
 80a0806:	bf00      	nop
 80a0808:	bf00      	nop
 80a080a:	bf00      	nop
 80a080c:	bf00      	nop
 80a080e:	bf00      	nop
 80a0810:	bf00      	nop
 80a0812:	bf00      	nop
 80a0814:	bf00      	nop
 80a0816:	bf00      	nop
 80a0818:	bf00      	nop
 80a081a:	bf00      	nop
 80a081c:	bf00      	nop
 80a081e:	bf00      	nop
 80a0820:	bf00      	nop
 80a0822:	bf00      	nop
 80a0824:	bf00      	nop
 80a0826:	bf00      	nop
 80a0828:	bf00      	nop
 80a082a:	bf00      	nop
 80a082c:	bf00      	nop
 80a082e:	bf00      	nop
 80a0830:	bf00      	nop
 80a0832:	bf00      	nop
 80a0834:	bf00      	nop
 80a0836:	bf00      	nop
 80a0838:	bf00      	nop
 80a083a:	bf00      	nop
 80a083c:	bf00      	nop
 80a083e:	bf00      	nop
 80a0840:	bf00      	nop
 80a0842:	bf00      	nop
 80a0844:	bf00      	nop
 80a0846:	bf00      	nop
 80a0848:	bf00      	nop
 80a084a:	bf00      	nop
 80a084c:	bf00      	nop
 80a084e:	bf00      	nop
 80a0850:	bf00      	nop
 80a0852:	bf00      	nop
 80a0854:	bf00      	nop
 80a0856:	bf00      	nop
 80a0858:	bf00      	nop
 80a085a:	bf00      	nop
 80a085c:	bf00      	nop
 80a085e:	bf00      	nop
 80a0860:	bf00      	nop
 80a0862:	bf00      	nop
 80a0864:	bf00      	nop
 80a0866:	bf00      	nop
 80a0868:	bf00      	nop
 80a086a:	bf00      	nop
 80a086c:	bf00      	nop
 80a086e:	bf00      	nop
 80a0870:	bf00      	nop
 80a0872:	bf00      	nop
 80a0874:	bf00      	nop
 80a0876:	bf00      	nop
 80a0878:	bf00      	nop
 80a087a:	bf00      	nop
 80a087c:	bf00      	nop
 80a087e:	bf00      	nop
 80a0880:	bf00      	nop
 80a0882:	bf00      	nop
 80a0884:	bf00      	nop
 80a0886:	bf00      	nop
 80a0888:	bf00      	nop
 80a088a:	bf00      	nop
 80a088c:	bf00      	nop
 80a088e:	bf00      	nop
 80a0890:	bf00      	nop
 80a0892:	bf00      	nop
 80a0894:	bf00      	nop
 80a0896:	bf00      	nop
 80a0898:	bf00      	nop
 80a089a:	bf00      	nop
 80a089c:	e6db      	b.n	80a0656 <_ZN17Adafruit_NeoPixel4showEv+0x2de>
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a089e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a08a2:	4a17      	ldr	r2, [pc, #92]	; (80a0900 <_ZN17Adafruit_NeoPixel4showEv+0x588>)
 80a08a4:	b29b      	uxth	r3, r3
      mask = 0x800000; // reset the mask
 80a08a6:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a08aa:	2600      	movs	r6, #0
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a08ac:	2b00      	cmp	r3, #0
 80a08ae:	f000 8131 	beq.w	80a0b14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a08b2:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a08b4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a08b8:	f10e 0103 	add.w	r1, lr, #3
 80a08bc:	3b03      	subs	r3, #3
 80a08be:	b29b      	uxth	r3, r3
 80a08c0:	f8ad 300a 	strh.w	r3, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a08c4:	f89e 3000 	ldrb.w	r3, [lr]
 80a08c8:	b2db      	uxtb	r3, r3
 80a08ca:	f88d 3006 	strb.w	r3, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a08ce:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a08d2:	b2db      	uxtb	r3, r3
 80a08d4:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a08d8:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a08dc:	b2db      	uxtb	r3, r3
 80a08de:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a08e2:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a08e6:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80a08ea:	f89d 7008 	ldrb.w	r7, [sp, #8]
 80a08ee:	0200      	lsls	r0, r0, #8
 80a08f0:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 80a08f4:	433b      	orrs	r3, r7
 80a08f6:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a08f8:	f88d 6005 	strb.w	r6, [sp, #5]
 80a08fc:	e080      	b.n	80a0a00 <_ZN17Adafruit_NeoPixel4showEv+0x688>
 80a08fe:	bf00      	nop
 80a0900:	200000f0 	.word	0x200000f0
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0904:	4600      	mov	r0, r0
 80a0906:	bf00      	nop
 80a0908:	bf00      	nop
 80a090a:	bf00      	nop
 80a090c:	bf00      	nop
 80a090e:	bf00      	nop
 80a0910:	bf00      	nop
 80a0912:	bf00      	nop
 80a0914:	bf00      	nop
 80a0916:	bf00      	nop
 80a0918:	bf00      	nop
 80a091a:	bf00      	nop
 80a091c:	bf00      	nop
 80a091e:	bf00      	nop
 80a0920:	bf00      	nop
 80a0922:	bf00      	nop
 80a0924:	bf00      	nop
 80a0926:	bf00      	nop
 80a0928:	bf00      	nop
 80a092a:	bf00      	nop
 80a092c:	bf00      	nop
 80a092e:	bf00      	nop
 80a0930:	bf00      	nop
 80a0932:	bf00      	nop
 80a0934:	bf00      	nop
 80a0936:	bf00      	nop
 80a0938:	bf00      	nop
 80a093a:	bf00      	nop
 80a093c:	bf00      	nop
 80a093e:	bf00      	nop
 80a0940:	bf00      	nop
 80a0942:	bf00      	nop
 80a0944:	bf00      	nop
 80a0946:	bf00      	nop
 80a0948:	bf00      	nop
 80a094a:	bf00      	nop
 80a094c:	bf00      	nop
 80a094e:	bf00      	nop
 80a0950:	bf00      	nop
 80a0952:	bf00      	nop
 80a0954:	bf00      	nop
 80a0956:	bf00      	nop
 80a0958:	bf00      	nop
 80a095a:	bf00      	nop
 80a095c:	bf00      	nop
 80a095e:	bf00      	nop
 80a0960:	bf00      	nop
 80a0962:	bf00      	nop
 80a0964:	bf00      	nop
 80a0966:	bf00      	nop
 80a0968:	bf00      	nop
 80a096a:	bf00      	nop
 80a096c:	bf00      	nop
 80a096e:	bf00      	nop
 80a0970:	bf00      	nop
 80a0972:	bf00      	nop
 80a0974:	bf00      	nop
 80a0976:	bf00      	nop
 80a0978:	bf00      	nop
 80a097a:	bf00      	nop
 80a097c:	bf00      	nop
 80a097e:	bf00      	nop
 80a0980:	bf00      	nop
 80a0982:	bf00      	nop
 80a0984:	bf00      	nop
 80a0986:	bf00      	nop
 80a0988:	bf00      	nop
 80a098a:	bf00      	nop
 80a098c:	bf00      	nop
 80a098e:	bf00      	nop
 80a0990:	bf00      	nop
 80a0992:	bf00      	nop
 80a0994:	bf00      	nop
 80a0996:	bf00      	nop
 80a0998:	bf00      	nop
 80a099a:	bf00      	nop
 80a099c:	bf00      	nop
          // WS2812 spec             600ns LOW
          // Adafruit on Arduino    (meas. 436ns)
          // This lib on Spark Core (meas. 446ns)
          // This lib on Photon     (meas. 434ns)
          pinSet(pin, LOW); // LOW
 80a099e:	79e3      	ldrb	r3, [r4, #7]
 80a09a0:	6810      	ldr	r0, [r2, #0]
 80a09a2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a09a6:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a09aa:	88bf      	ldrh	r7, [r7, #4]
 80a09ac:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a09b0:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a09b2:	4600      	mov	r0, r0
 80a09b4:	bf00      	nop
 80a09b6:	bf00      	nop
 80a09b8:	bf00      	nop
 80a09ba:	bf00      	nop
 80a09bc:	bf00      	nop
 80a09be:	bf00      	nop
 80a09c0:	bf00      	nop
 80a09c2:	bf00      	nop
 80a09c4:	bf00      	nop
 80a09c6:	bf00      	nop
 80a09c8:	bf00      	nop
 80a09ca:	bf00      	nop
 80a09cc:	bf00      	nop
 80a09ce:	bf00      	nop
 80a09d0:	bf00      	nop
 80a09d2:	bf00      	nop
 80a09d4:	bf00      	nop
 80a09d6:	bf00      	nop
 80a09d8:	bf00      	nop
 80a09da:	bf00      	nop
 80a09dc:	bf00      	nop
 80a09de:	bf00      	nop
 80a09e0:	bf00      	nop
 80a09e2:	bf00      	nop
 80a09e4:	bf00      	nop
 80a09e6:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a09e8:	9b04      	ldr	r3, [sp, #16]
 80a09ea:	085b      	lsrs	r3, r3, #1
 80a09ec:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a09ee:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a09f2:	3301      	adds	r3, #1
 80a09f4:	b2db      	uxtb	r3, r3
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a09f6:	2b17      	cmp	r3, #23
 80a09f8:	f88d 3005 	strb.w	r3, [sp, #5]
 80a09fc:	f200 8083 	bhi.w	80a0b06 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
        pinSet(pin, HIGH); // HIGH
 80a0a00:	79e3      	ldrb	r3, [r4, #7]
 80a0a02:	6810      	ldr	r0, [r2, #0]
 80a0a04:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0a08:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0a0c:	88bf      	ldrh	r7, [r7, #4]
 80a0a0e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0a12:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a0a14:	9803      	ldr	r0, [sp, #12]
 80a0a16:	9b04      	ldr	r3, [sp, #16]
 80a0a18:	4218      	tst	r0, r3
 80a0a1a:	f47f af73 	bne.w	80a0904 <_ZN17Adafruit_NeoPixel4showEv+0x58c>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0a1e:	4600      	mov	r0, r0
 80a0a20:	bf00      	nop
 80a0a22:	bf00      	nop
 80a0a24:	bf00      	nop
 80a0a26:	bf00      	nop
 80a0a28:	bf00      	nop
 80a0a2a:	bf00      	nop
 80a0a2c:	bf00      	nop
 80a0a2e:	bf00      	nop
 80a0a30:	bf00      	nop
 80a0a32:	bf00      	nop
 80a0a34:	bf00      	nop
 80a0a36:	bf00      	nop
 80a0a38:	bf00      	nop
 80a0a3a:	bf00      	nop
 80a0a3c:	bf00      	nop
 80a0a3e:	bf00      	nop
 80a0a40:	bf00      	nop
 80a0a42:	bf00      	nop
 80a0a44:	bf00      	nop
          // WS2812 spec             800ns LOW
          // Adafruit on Arduino    (meas. 938ns)
          // This lib on Spark Core (meas. 944ns)
          // This lib on Photon     (meas. 936ns)
          pinSet(pin, LOW); // LOW
 80a0a46:	79e3      	ldrb	r3, [r4, #7]
 80a0a48:	6810      	ldr	r0, [r2, #0]
 80a0a4a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0a4e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0a52:	88bf      	ldrh	r7, [r7, #4]
 80a0a54:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0a58:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0a5a:	4600      	mov	r0, r0
 80a0a5c:	bf00      	nop
 80a0a5e:	bf00      	nop
 80a0a60:	bf00      	nop
 80a0a62:	bf00      	nop
 80a0a64:	bf00      	nop
 80a0a66:	bf00      	nop
 80a0a68:	bf00      	nop
 80a0a6a:	bf00      	nop
 80a0a6c:	bf00      	nop
 80a0a6e:	bf00      	nop
 80a0a70:	bf00      	nop
 80a0a72:	bf00      	nop
 80a0a74:	bf00      	nop
 80a0a76:	bf00      	nop
 80a0a78:	bf00      	nop
 80a0a7a:	bf00      	nop
 80a0a7c:	bf00      	nop
 80a0a7e:	bf00      	nop
 80a0a80:	bf00      	nop
 80a0a82:	bf00      	nop
 80a0a84:	bf00      	nop
 80a0a86:	bf00      	nop
 80a0a88:	bf00      	nop
 80a0a8a:	bf00      	nop
 80a0a8c:	bf00      	nop
 80a0a8e:	bf00      	nop
 80a0a90:	bf00      	nop
 80a0a92:	bf00      	nop
 80a0a94:	bf00      	nop
 80a0a96:	bf00      	nop
 80a0a98:	bf00      	nop
 80a0a9a:	bf00      	nop
 80a0a9c:	bf00      	nop
 80a0a9e:	bf00      	nop
 80a0aa0:	bf00      	nop
 80a0aa2:	bf00      	nop
 80a0aa4:	bf00      	nop
 80a0aa6:	bf00      	nop
 80a0aa8:	bf00      	nop
 80a0aaa:	bf00      	nop
 80a0aac:	bf00      	nop
 80a0aae:	bf00      	nop
 80a0ab0:	bf00      	nop
 80a0ab2:	bf00      	nop
 80a0ab4:	bf00      	nop
 80a0ab6:	bf00      	nop
 80a0ab8:	bf00      	nop
 80a0aba:	bf00      	nop
 80a0abc:	bf00      	nop
 80a0abe:	bf00      	nop
 80a0ac0:	bf00      	nop
 80a0ac2:	bf00      	nop
 80a0ac4:	bf00      	nop
 80a0ac6:	bf00      	nop
 80a0ac8:	bf00      	nop
 80a0aca:	bf00      	nop
 80a0acc:	bf00      	nop
 80a0ace:	bf00      	nop
 80a0ad0:	bf00      	nop
 80a0ad2:	bf00      	nop
 80a0ad4:	bf00      	nop
 80a0ad6:	bf00      	nop
 80a0ad8:	bf00      	nop
 80a0ada:	bf00      	nop
 80a0adc:	bf00      	nop
 80a0ade:	bf00      	nop
 80a0ae0:	bf00      	nop
 80a0ae2:	bf00      	nop
 80a0ae4:	bf00      	nop
 80a0ae6:	bf00      	nop
 80a0ae8:	bf00      	nop
 80a0aea:	bf00      	nop
 80a0aec:	bf00      	nop
 80a0aee:	bf00      	nop
 80a0af0:	bf00      	nop
 80a0af2:	bf00      	nop
 80a0af4:	bf00      	nop
 80a0af6:	bf00      	nop
 80a0af8:	bf00      	nop
 80a0afa:	bf00      	nop
 80a0afc:	bf00      	nop
 80a0afe:	bf00      	nop
 80a0b00:	bf00      	nop
 80a0b02:	bf00      	nop
 80a0b04:	e770      	b.n	80a09e8 <_ZN17Adafruit_NeoPixel4showEv+0x670>
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0b06:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a0b0a:	468e      	mov	lr, r1
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0b0c:	b29b      	uxth	r3, r3
 80a0b0e:	2b00      	cmp	r3, #0
 80a0b10:	f47f aecf 	bne.w	80a08b2 <_ZN17Adafruit_NeoPixel4showEv+0x53a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 80a0b14:	b662      	cpsie	i
  }
// END of NRF52 implementation


#endif
  endTime = micros(); // Save EOD time for latch on next call
 80a0b16:	f7ff fbcd 	bl	80a02b4 <micros>
 80a0b1a:	6120      	str	r0, [r4, #16]
}
 80a0b1c:	b006      	add	sp, #24
 80a0b1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a0b22:	4b5e      	ldr	r3, [pc, #376]	; (80a0c9c <_ZN17Adafruit_NeoPixel4showEv+0x924>)
 80a0b24:	4a5e      	ldr	r2, [pc, #376]	; (80a0ca0 <_ZN17Adafruit_NeoPixel4showEv+0x928>)
        pinSet(pin, HIGH); // HIGH
        if (c & mask) { // if masked bit is high
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a0b26:	4618      	mov	r0, r3
 80a0b28:	6811      	ldr	r1, [r2, #0]
    #define CYCLES_800_T1L  8  // 436ns (meas. 425ns)

    volatile uint32_t cyc;

    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a0b2a:	f44f 0800 	mov.w	r8, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a0b2e:	2700      	movs	r7, #0
    #define CYCLES_800_T1H  80 // 812ns (meas. 792ns)
    #define CYCLES_800_T1L  8  // 436ns (meas. 425ns)

    volatile uint32_t cyc;

    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0b30:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a0b34:	b292      	uxth	r2, r2
 80a0b36:	2a00      	cmp	r2, #0
 80a0b38:	d0ec      	beq.n	80a0b14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a0b3a:	f8cd 8010 	str.w	r8, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a0b3e:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a0b42:	f10e 0503 	add.w	r5, lr, #3
 80a0b46:	3a03      	subs	r2, #3
 80a0b48:	b292      	uxth	r2, r2
 80a0b4a:	f8ad 200a 	strh.w	r2, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a0b4e:	f89e 2000 	ldrb.w	r2, [lr]
 80a0b52:	b2d2      	uxtb	r2, r2
 80a0b54:	f88d 2006 	strb.w	r2, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a0b58:	f89e 2001 	ldrb.w	r2, [lr, #1]
 80a0b5c:	b2d2      	uxtb	r2, r2
 80a0b5e:	f88d 2007 	strb.w	r2, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a0b62:	f89e 2002 	ldrb.w	r2, [lr, #2]
 80a0b66:	b2d2      	uxtb	r2, r2
 80a0b68:	f88d 2008 	strb.w	r2, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a0b6c:	f89d 2006 	ldrb.w	r2, [sp, #6]
 80a0b70:	f89d e007 	ldrb.w	lr, [sp, #7]
 80a0b74:	f89d c008 	ldrb.w	ip, [sp, #8]
 80a0b78:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 80a0b7c:	ea4e 4202 	orr.w	r2, lr, r2, lsl #16
 80a0b80:	ea42 020c 	orr.w	r2, r2, ip
 80a0b84:	9203      	str	r2, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a0b86:	f88d 7005 	strb.w	r7, [sp, #5]
      do {
        cyc = DWT->CYCCNT;
        pinSet(pin, HIGH); // HIGH
 80a0b8a:	79e2      	ldrb	r2, [r4, #7]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a0b8c:	685e      	ldr	r6, [r3, #4]
        pinSet(pin, HIGH); // HIGH
 80a0b8e:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a0b92:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a0b96:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a0b9a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a0b9e:	9605      	str	r6, [sp, #20]
        pinSet(pin, HIGH); // HIGH
 80a0ba0:	f8a2 e018 	strh.w	lr, [r2, #24]
        if (c & mask) { // if masked bit is high
 80a0ba4:	9e03      	ldr	r6, [sp, #12]
 80a0ba6:	9a04      	ldr	r2, [sp, #16]
 80a0ba8:	4216      	tst	r6, r2
 80a0baa:	d023      	beq.n	80a0bf4 <_ZN17Adafruit_NeoPixel4showEv+0x87c>
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a0bac:	685a      	ldr	r2, [r3, #4]
 80a0bae:	9e05      	ldr	r6, [sp, #20]
 80a0bb0:	1b92      	subs	r2, r2, r6
 80a0bb2:	2a4f      	cmp	r2, #79	; 0x4f
 80a0bb4:	d9fa      	bls.n	80a0bac <_ZN17Adafruit_NeoPixel4showEv+0x834>
          pinSet(pin, LOW);
 80a0bb6:	79e2      	ldrb	r2, [r4, #7]
 80a0bb8:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a0bbc:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a0bc0:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a0bc4:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80a0bc8:	f8a2 e01a 	strh.w	lr, [r2, #26]
          cyc = DWT->CYCCNT;
 80a0bcc:	6842      	ldr	r2, [r0, #4]
 80a0bce:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
 80a0bd0:	685a      	ldr	r2, [r3, #4]
 80a0bd2:	9e05      	ldr	r6, [sp, #20]
 80a0bd4:	1b92      	subs	r2, r2, r6
 80a0bd6:	2a07      	cmp	r2, #7
 80a0bd8:	d9fa      	bls.n	80a0bd0 <_ZN17Adafruit_NeoPixel4showEv+0x858>
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
          pinSet(pin, LOW);
          cyc = DWT->CYCCNT;
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
        }
        mask >>= 1;
 80a0bda:	9a04      	ldr	r2, [sp, #16]
 80a0bdc:	0852      	lsrs	r2, r2, #1
 80a0bde:	9204      	str	r2, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a0be0:	f89d 2005 	ldrb.w	r2, [sp, #5]
 80a0be4:	3201      	adds	r2, #1
 80a0be6:	b2d2      	uxtb	r2, r2
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a0be8:	2a17      	cmp	r2, #23
 80a0bea:	f88d 2005 	strb.w	r2, [sp, #5]
 80a0bee:	d9cc      	bls.n	80a0b8a <_ZN17Adafruit_NeoPixel4showEv+0x812>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a0bf0:	46ae      	mov	lr, r5
 80a0bf2:	e79d      	b.n	80a0b30 <_ZN17Adafruit_NeoPixel4showEv+0x7b8>
          pinSet(pin, LOW);
          cyc = DWT->CYCCNT;
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
        }
        else { // else masked bit is low
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
 80a0bf4:	685a      	ldr	r2, [r3, #4]
 80a0bf6:	9e05      	ldr	r6, [sp, #20]
 80a0bf8:	1b92      	subs	r2, r2, r6
 80a0bfa:	2a18      	cmp	r2, #24
 80a0bfc:	d9fa      	bls.n	80a0bf4 <_ZN17Adafruit_NeoPixel4showEv+0x87c>
          pinSet(pin, LOW);
 80a0bfe:	79e2      	ldrb	r2, [r4, #7]
 80a0c00:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a0c04:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a0c08:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a0c0c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80a0c10:	f8a2 e01a 	strh.w	lr, [r2, #26]
          cyc = DWT->CYCCNT;
 80a0c14:	6842      	ldr	r2, [r0, #4]
 80a0c16:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
 80a0c18:	685a      	ldr	r2, [r3, #4]
 80a0c1a:	9e05      	ldr	r6, [sp, #20]
 80a0c1c:	1b92      	subs	r2, r2, r6
 80a0c1e:	2a45      	cmp	r2, #69	; 0x45
 80a0c20:	d9fa      	bls.n	80a0c18 <_ZN17Adafruit_NeoPixel4showEv+0x8a0>
 80a0c22:	e7da      	b.n	80a0bda <_ZN17Adafruit_NeoPixel4showEv+0x862>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
 80a0c24:	46ae      	mov	lr, r5
 80a0c26:	f7ff bbda 	b.w	80a03de <_ZN17Adafruit_NeoPixel4showEv+0x66>
 80a0c2a:	4a1d      	ldr	r2, [pc, #116]	; (80a0ca0 <_ZN17Adafruit_NeoPixel4showEv+0x928>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
    while(i) { // While bytes left... (4 bytes = 1 pixel)
      mask = 0x80000000; // reset the mask
 80a0c2c:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
      j = 0;        // reset the 32-bit counter
 80a0c30:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
    while(i) { // While bytes left... (4 bytes = 1 pixel)
 80a0c32:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a0c36:	b29b      	uxth	r3, r3
 80a0c38:	2b00      	cmp	r3, #0
 80a0c3a:	f43f af6b 	beq.w	80a0b14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x80000000; // reset the mask
 80a0c3e:	9504      	str	r5, [sp, #16]
      i = i-4;      // decrement bytes remaining
 80a0c40:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a0c44:	f10e 0104 	add.w	r1, lr, #4
 80a0c48:	3b04      	subs	r3, #4
 80a0c4a:	b29b      	uxth	r3, r3
 80a0c4c:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a0c50:	f89e 3000 	ldrb.w	r3, [lr]
 80a0c54:	b2db      	uxtb	r3, r3
 80a0c56:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a0c5a:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a0c5e:	b2db      	uxtb	r3, r3
 80a0c60:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a0c64:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a0c68:	b2db      	uxtb	r3, r3
 80a0c6a:	f88d 3008 	strb.w	r3, [sp, #8]
      w = *ptr++;   // Next white byte value
 80a0c6e:	f89e 3003 	ldrb.w	r3, [lr, #3]
 80a0c72:	b2db      	uxtb	r3, r3
 80a0c74:	f88d 3009 	strb.w	r3, [sp, #9]
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
 80a0c78:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a0c7c:	f89d 7006 	ldrb.w	r7, [sp, #6]
 80a0c80:	f89d e008 	ldrb.w	lr, [sp, #8]
 80a0c84:	043f      	lsls	r7, r7, #16
 80a0c86:	f89d 0009 	ldrb.w	r0, [sp, #9]
 80a0c8a:	ea47 6303 	orr.w	r3, r7, r3, lsl #24
 80a0c8e:	4303      	orrs	r3, r0
 80a0c90:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
 80a0c94:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 32-bit counter
 80a0c96:	f88d 6005 	strb.w	r6, [sp, #5]
 80a0c9a:	e07e      	b.n	80a0d9a <_ZN17Adafruit_NeoPixel4showEv+0xa22>
 80a0c9c:	e0001000 	.word	0xe0001000
 80a0ca0:	200000f0 	.word	0x200000f0
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0ca4:	4600      	mov	r0, r0
 80a0ca6:	bf00      	nop
 80a0ca8:	bf00      	nop
 80a0caa:	bf00      	nop
 80a0cac:	bf00      	nop
 80a0cae:	bf00      	nop
 80a0cb0:	bf00      	nop
 80a0cb2:	bf00      	nop
 80a0cb4:	bf00      	nop
 80a0cb6:	bf00      	nop
 80a0cb8:	bf00      	nop
 80a0cba:	bf00      	nop
 80a0cbc:	bf00      	nop
 80a0cbe:	bf00      	nop
 80a0cc0:	bf00      	nop
 80a0cc2:	bf00      	nop
 80a0cc4:	bf00      	nop
 80a0cc6:	bf00      	nop
 80a0cc8:	bf00      	nop
 80a0cca:	bf00      	nop
 80a0ccc:	bf00      	nop
 80a0cce:	bf00      	nop
 80a0cd0:	bf00      	nop
 80a0cd2:	bf00      	nop
 80a0cd4:	bf00      	nop
 80a0cd6:	bf00      	nop
 80a0cd8:	bf00      	nop
 80a0cda:	bf00      	nop
 80a0cdc:	bf00      	nop
 80a0cde:	bf00      	nop
 80a0ce0:	bf00      	nop
 80a0ce2:	bf00      	nop
 80a0ce4:	bf00      	nop
 80a0ce6:	bf00      	nop
 80a0ce8:	bf00      	nop
 80a0cea:	bf00      	nop
 80a0cec:	bf00      	nop
 80a0cee:	bf00      	nop
 80a0cf0:	bf00      	nop
 80a0cf2:	bf00      	nop
 80a0cf4:	bf00      	nop
 80a0cf6:	bf00      	nop
 80a0cf8:	bf00      	nop
 80a0cfa:	bf00      	nop
 80a0cfc:	bf00      	nop
 80a0cfe:	bf00      	nop
 80a0d00:	bf00      	nop
 80a0d02:	bf00      	nop
 80a0d04:	bf00      	nop
 80a0d06:	bf00      	nop
 80a0d08:	bf00      	nop
 80a0d0a:	bf00      	nop
 80a0d0c:	bf00      	nop
 80a0d0e:	bf00      	nop
 80a0d10:	bf00      	nop
          // SK6812RGBW spec         600ns LOW
          // WS2812 spec             600ns LOW
          // Adafruit on Arduino    (meas. 436ns)
          // This lib on Spark Core (meas. 598ns)
          // This lib on Photon     (meas. 600ns)
          pinSet(pin, LOW); // LOW
 80a0d12:	79e3      	ldrb	r3, [r4, #7]
 80a0d14:	6810      	ldr	r0, [r2, #0]
 80a0d16:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0d1a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0d1e:	88bf      	ldrh	r7, [r7, #4]
 80a0d20:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0d24:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0d26:	4600      	mov	r0, r0
 80a0d28:	bf00      	nop
 80a0d2a:	bf00      	nop
 80a0d2c:	bf00      	nop
 80a0d2e:	bf00      	nop
 80a0d30:	bf00      	nop
 80a0d32:	bf00      	nop
 80a0d34:	bf00      	nop
 80a0d36:	bf00      	nop
 80a0d38:	bf00      	nop
 80a0d3a:	bf00      	nop
 80a0d3c:	bf00      	nop
 80a0d3e:	bf00      	nop
 80a0d40:	bf00      	nop
 80a0d42:	bf00      	nop
 80a0d44:	bf00      	nop
 80a0d46:	bf00      	nop
 80a0d48:	bf00      	nop
 80a0d4a:	bf00      	nop
 80a0d4c:	bf00      	nop
 80a0d4e:	bf00      	nop
 80a0d50:	bf00      	nop
 80a0d52:	bf00      	nop
 80a0d54:	bf00      	nop
 80a0d56:	bf00      	nop
 80a0d58:	bf00      	nop
 80a0d5a:	bf00      	nop
 80a0d5c:	bf00      	nop
 80a0d5e:	bf00      	nop
 80a0d60:	bf00      	nop
 80a0d62:	bf00      	nop
 80a0d64:	bf00      	nop
 80a0d66:	bf00      	nop
 80a0d68:	bf00      	nop
 80a0d6a:	bf00      	nop
 80a0d6c:	bf00      	nop
 80a0d6e:	bf00      	nop
 80a0d70:	bf00      	nop
 80a0d72:	bf00      	nop
 80a0d74:	bf00      	nop
 80a0d76:	bf00      	nop
 80a0d78:	bf00      	nop
 80a0d7a:	bf00      	nop
 80a0d7c:	bf00      	nop
 80a0d7e:	bf00      	nop
 80a0d80:	bf00      	nop
 80a0d82:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a0d84:	9b04      	ldr	r3, [sp, #16]
 80a0d86:	085b      	lsrs	r3, r3, #1
 80a0d88:	9304      	str	r3, [sp, #16]
      } while ( ++j < 32 ); // ... pixel done
 80a0d8a:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a0d8e:	3301      	adds	r3, #1
 80a0d90:	b2db      	uxtb	r3, r3
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
      j = 0;        // reset the 32-bit counter
      do {
 80a0d92:	2b1f      	cmp	r3, #31
 80a0d94:	f88d 3005 	strb.w	r3, [sp, #5]
 80a0d98:	d87e      	bhi.n	80a0e98 <_ZN17Adafruit_NeoPixel4showEv+0xb20>
        pinSet(pin, HIGH); // HIGH
 80a0d9a:	79e3      	ldrb	r3, [r4, #7]
 80a0d9c:	6810      	ldr	r0, [r2, #0]
 80a0d9e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0da2:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0da6:	88bf      	ldrh	r7, [r7, #4]
 80a0da8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0dac:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a0dae:	9803      	ldr	r0, [sp, #12]
 80a0db0:	9b04      	ldr	r3, [sp, #16]
 80a0db2:	4218      	tst	r0, r3
 80a0db4:	f47f af76 	bne.w	80a0ca4 <_ZN17Adafruit_NeoPixel4showEv+0x92c>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0db8:	4600      	mov	r0, r0
 80a0dba:	bf00      	nop
 80a0dbc:	bf00      	nop
 80a0dbe:	bf00      	nop
 80a0dc0:	bf00      	nop
 80a0dc2:	bf00      	nop
 80a0dc4:	bf00      	nop
 80a0dc6:	bf00      	nop
 80a0dc8:	bf00      	nop
 80a0dca:	bf00      	nop
 80a0dcc:	bf00      	nop
 80a0dce:	bf00      	nop
 80a0dd0:	bf00      	nop
 80a0dd2:	bf00      	nop
 80a0dd4:	bf00      	nop
 80a0dd6:	bf00      	nop
 80a0dd8:	bf00      	nop
 80a0dda:	bf00      	nop
 80a0ddc:	bf00      	nop
 80a0dde:	bf00      	nop
          // SK6812RGBW spec         900ns LOW
          // WS2812 spec             800ns LOW
          // Adafruit on Arduino    (meas. 938ns)
          // This lib on Spark Core (meas. 904ns)
          // This lib on Photon     (meas. 900ns)
          pinSet(pin, LOW); // LOW
 80a0de0:	79e3      	ldrb	r3, [r4, #7]
 80a0de2:	6810      	ldr	r0, [r2, #0]
 80a0de4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a0de8:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a0dec:	88bf      	ldrh	r7, [r7, #4]
 80a0dee:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a0df2:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0df4:	4600      	mov	r0, r0
 80a0df6:	bf00      	nop
 80a0df8:	bf00      	nop
 80a0dfa:	bf00      	nop
 80a0dfc:	bf00      	nop
 80a0dfe:	bf00      	nop
 80a0e00:	bf00      	nop
 80a0e02:	bf00      	nop
 80a0e04:	bf00      	nop
 80a0e06:	bf00      	nop
 80a0e08:	bf00      	nop
 80a0e0a:	bf00      	nop
 80a0e0c:	bf00      	nop
 80a0e0e:	bf00      	nop
 80a0e10:	bf00      	nop
 80a0e12:	bf00      	nop
 80a0e14:	bf00      	nop
 80a0e16:	bf00      	nop
 80a0e18:	bf00      	nop
 80a0e1a:	bf00      	nop
 80a0e1c:	bf00      	nop
 80a0e1e:	bf00      	nop
 80a0e20:	bf00      	nop
 80a0e22:	bf00      	nop
 80a0e24:	bf00      	nop
 80a0e26:	bf00      	nop
 80a0e28:	bf00      	nop
 80a0e2a:	bf00      	nop
 80a0e2c:	bf00      	nop
 80a0e2e:	bf00      	nop
 80a0e30:	bf00      	nop
 80a0e32:	bf00      	nop
 80a0e34:	bf00      	nop
 80a0e36:	bf00      	nop
 80a0e38:	bf00      	nop
 80a0e3a:	bf00      	nop
 80a0e3c:	bf00      	nop
 80a0e3e:	bf00      	nop
 80a0e40:	bf00      	nop
 80a0e42:	bf00      	nop
 80a0e44:	bf00      	nop
 80a0e46:	bf00      	nop
 80a0e48:	bf00      	nop
 80a0e4a:	bf00      	nop
 80a0e4c:	bf00      	nop
 80a0e4e:	bf00      	nop
 80a0e50:	bf00      	nop
 80a0e52:	bf00      	nop
 80a0e54:	bf00      	nop
 80a0e56:	bf00      	nop
 80a0e58:	bf00      	nop
 80a0e5a:	bf00      	nop
 80a0e5c:	bf00      	nop
 80a0e5e:	bf00      	nop
 80a0e60:	bf00      	nop
 80a0e62:	bf00      	nop
 80a0e64:	bf00      	nop
 80a0e66:	bf00      	nop
 80a0e68:	bf00      	nop
 80a0e6a:	bf00      	nop
 80a0e6c:	bf00      	nop
 80a0e6e:	bf00      	nop
 80a0e70:	bf00      	nop
 80a0e72:	bf00      	nop
 80a0e74:	bf00      	nop
 80a0e76:	bf00      	nop
 80a0e78:	bf00      	nop
 80a0e7a:	bf00      	nop
 80a0e7c:	bf00      	nop
 80a0e7e:	bf00      	nop
 80a0e80:	bf00      	nop
 80a0e82:	bf00      	nop
 80a0e84:	bf00      	nop
 80a0e86:	bf00      	nop
 80a0e88:	bf00      	nop
 80a0e8a:	bf00      	nop
 80a0e8c:	bf00      	nop
 80a0e8e:	bf00      	nop
 80a0e90:	bf00      	nop
 80a0e92:	bf00      	nop
 80a0e94:	bf00      	nop
 80a0e96:	e775      	b.n	80a0d84 <_ZN17Adafruit_NeoPixel4showEv+0xa0c>
      mask = 0x80000000; // reset the mask
      i = i-4;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
 80a0e98:	468e      	mov	lr, r1
 80a0e9a:	e6ca      	b.n	80a0c32 <_ZN17Adafruit_NeoPixel4showEv+0x8ba>
 80a0e9c:	4770      	bx	lr
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
 80a0e9e:	2903      	cmp	r1, #3
 80a0ea0:	f000 812e 	beq.w	80a1100 <_ZN17Adafruit_NeoPixel4showEv+0xd88>
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a0ea4:	4a1e      	ldr	r2, [pc, #120]	; (80a0f20 <_ZN17Adafruit_NeoPixel4showEv+0xba8>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a0ea6:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a0eaa:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a0eac:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a0eb0:	b29b      	uxth	r3, r3
 80a0eb2:	2b00      	cmp	r3, #0
 80a0eb4:	f43f ae2e 	beq.w	80a0b14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a0eb8:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a0eba:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a0ebe:	79e0      	ldrb	r0, [r4, #7]
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
 80a0ec0:	3b03      	subs	r3, #3
 80a0ec2:	b29b      	uxth	r3, r3
 80a0ec4:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a0ec8:	f89e 3000 	ldrb.w	r3, [lr]
 80a0ecc:	f10e 0103 	add.w	r1, lr, #3
 80a0ed0:	b2db      	uxtb	r3, r3
 80a0ed2:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a0ed6:	f89e 3001 	ldrb.w	r3, [lr, #1]
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a0eda:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a0ede:	b2db      	uxtb	r3, r3
 80a0ee0:	f88d 3008 	strb.w	r3, [sp, #8]
      g = *ptr++;   // Next green byte value
 80a0ee4:	f89e 3002 	ldrb.w	r3, [lr, #2]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a0ee8:	f8d2 e000 	ldr.w	lr, [r2]
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
 80a0eec:	b2db      	uxtb	r3, r3
 80a0eee:	f88d 3006 	strb.w	r3, [sp, #6]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a0ef2:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a0ef6:	f89d 3008 	ldrb.w	r3, [sp, #8]
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a0efa:	eb0e 0c80 	add.w	ip, lr, r0, lsl #2
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a0efe:	021b      	lsls	r3, r3, #8
 80a0f00:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a0f04:	f89d 7006 	ldrb.w	r7, [sp, #6]
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a0f08:	f8bc c004 	ldrh.w	ip, [ip, #4]
 80a0f0c:	f85e 0020 	ldr.w	r0, [lr, r0, lsl #2]
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a0f10:	433b      	orrs	r3, r7
 80a0f12:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a0f14:	f88d 6005 	strb.w	r6, [sp, #5]
      pinSet(pin, LOW); // LOW
 80a0f18:	f8a0 c01a 	strh.w	ip, [r0, #26]
 80a0f1c:	e07d      	b.n	80a101a <_ZN17Adafruit_NeoPixel4showEv+0xca2>
 80a0f1e:	bf00      	nop
 80a0f20:	200000f0 	.word	0x200000f0
      for( ;; ) {   // ... pixel done
        if (c & mask) { // if masked bit is high
          // TM1829 spec             800ns LOW
          // This lib on Spark Core (meas. 806ns)
          // This lib on Photon     (meas. 792ns)
          mask >>= 1; // Do this task during the long delay of this bit
 80a0f24:	9b04      	ldr	r3, [sp, #16]
 80a0f26:	085b      	lsrs	r3, r3, #1
 80a0f28:	9304      	str	r3, [sp, #16]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0f2a:	4600      	mov	r0, r0
 80a0f2c:	bf00      	nop
 80a0f2e:	bf00      	nop
 80a0f30:	bf00      	nop
 80a0f32:	bf00      	nop
 80a0f34:	bf00      	nop
 80a0f36:	bf00      	nop
 80a0f38:	bf00      	nop
 80a0f3a:	bf00      	nop
 80a0f3c:	bf00      	nop
 80a0f3e:	bf00      	nop
 80a0f40:	bf00      	nop
 80a0f42:	bf00      	nop
 80a0f44:	bf00      	nop
 80a0f46:	bf00      	nop
 80a0f48:	bf00      	nop
 80a0f4a:	bf00      	nop
 80a0f4c:	bf00      	nop
 80a0f4e:	bf00      	nop
 80a0f50:	bf00      	nop
 80a0f52:	bf00      	nop
 80a0f54:	bf00      	nop
 80a0f56:	bf00      	nop
 80a0f58:	bf00      	nop
 80a0f5a:	bf00      	nop
 80a0f5c:	bf00      	nop
 80a0f5e:	bf00      	nop
 80a0f60:	bf00      	nop
 80a0f62:	bf00      	nop
 80a0f64:	bf00      	nop
 80a0f66:	bf00      	nop
 80a0f68:	bf00      	nop
 80a0f6a:	bf00      	nop
 80a0f6c:	bf00      	nop
 80a0f6e:	bf00      	nop
 80a0f70:	bf00      	nop
 80a0f72:	bf00      	nop
 80a0f74:	bf00      	nop
 80a0f76:	bf00      	nop
 80a0f78:	bf00      	nop
 80a0f7a:	bf00      	nop
 80a0f7c:	bf00      	nop
 80a0f7e:	bf00      	nop
 80a0f80:	bf00      	nop
 80a0f82:	bf00      	nop
 80a0f84:	bf00      	nop
 80a0f86:	bf00      	nop
 80a0f88:	bf00      	nop
 80a0f8a:	bf00      	nop
 80a0f8c:	bf00      	nop
 80a0f8e:	bf00      	nop
 80a0f90:	bf00      	nop
 80a0f92:	bf00      	nop
 80a0f94:	bf00      	nop
 80a0f96:	bf00      	nop
 80a0f98:	bf00      	nop
 80a0f9a:	bf00      	nop
 80a0f9c:	bf00      	nop
 80a0f9e:	bf00      	nop
 80a0fa0:	bf00      	nop
 80a0fa2:	bf00      	nop
 80a0fa4:	bf00      	nop
 80a0fa6:	bf00      	nop
 80a0fa8:	bf00      	nop
 80a0faa:	bf00      	nop
 80a0fac:	bf00      	nop
 80a0fae:	bf00      	nop
          j++;
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a0fb0:	79e0      	ldrb	r0, [r4, #7]
 80a0fb2:	6817      	ldr	r7, [r2, #0]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          j++;
 80a0fb4:	f89d 3005 	ldrb.w	r3, [sp, #5]
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a0fb8:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80a0fbc:	eb07 0e80 	add.w	lr, r7, r0, lsl #2
 80a0fc0:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a0fc4:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          j++;
 80a0fc8:	3301      	adds	r3, #1
 80a0fca:	b2db      	uxtb	r3, r3
 80a0fcc:	f88d 3005 	strb.w	r3, [sp, #5]
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a0fd0:	f8a0 e018 	strh.w	lr, [r0, #24]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a0fd4:	4600      	mov	r0, r0
 80a0fd6:	bf00      	nop
 80a0fd8:	bf00      	nop
 80a0fda:	bf00      	nop
 80a0fdc:	bf00      	nop
 80a0fde:	bf00      	nop
 80a0fe0:	bf00      	nop
 80a0fe2:	bf00      	nop
 80a0fe4:	bf00      	nop
 80a0fe6:	bf00      	nop
 80a0fe8:	bf00      	nop
 80a0fea:	bf00      	nop
 80a0fec:	bf00      	nop
 80a0fee:	bf00      	nop
 80a0ff0:	bf00      	nop
 80a0ff2:	bf00      	nop
 80a0ff4:	bf00      	nop
 80a0ff6:	bf00      	nop
 80a0ff8:	bf00      	nop
 80a0ffa:	bf00      	nop
 80a0ffc:	bf00      	nop
          if(j==24) break;
 80a0ffe:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1002:	2b18      	cmp	r3, #24
 80a1004:	d07a      	beq.n	80a10fc <_ZN17Adafruit_NeoPixel4showEv+0xd84>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          if(j==24) break;
          pinSet(pin, LOW); // LOW
 80a1006:	79e3      	ldrb	r3, [r4, #7]
 80a1008:	6810      	ldr	r0, [r2, #0]
 80a100a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a100e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1012:	88bf      	ldrh	r7, [r7, #4]
 80a1014:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1018:	835f      	strh	r7, [r3, #26]
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
      for( ;; ) {   // ... pixel done
        if (c & mask) { // if masked bit is high
 80a101a:	9803      	ldr	r0, [sp, #12]
 80a101c:	9b04      	ldr	r3, [sp, #16]
 80a101e:	4218      	tst	r0, r3
 80a1020:	d180      	bne.n	80a0f24 <_ZN17Adafruit_NeoPixel4showEv+0xbac>
            "mov r0, r0" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
            ::: "r0", "cc", "memory");
 80a1022:	4600      	mov	r0, r0
 80a1024:	bf00      	nop
 80a1026:	bf00      	nop
 80a1028:	bf00      	nop
 80a102a:	bf00      	nop
 80a102c:	bf00      	nop
 80a102e:	bf00      	nop
 80a1030:	bf00      	nop
 80a1032:	bf00      	nop
 80a1034:	bf00      	nop
 80a1036:	bf00      	nop
 80a1038:	bf00      	nop
 80a103a:	bf00      	nop
 80a103c:	bf00      	nop
 80a103e:	bf00      	nop
 80a1040:	bf00      	nop
 80a1042:	bf00      	nop
#endif
          // TM1829 spec             800ns HIGH
          // This lib on Spark Core (meas. 792ns)
          // This lib on Photon     (meas. 800ns)
          pinSet(pin, HIGH); // HIGH
 80a1044:	79e3      	ldrb	r3, [r4, #7]
 80a1046:	6810      	ldr	r0, [r2, #0]
 80a1048:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a104c:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1050:	88bf      	ldrh	r7, [r7, #4]
 80a1052:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1056:	831f      	strh	r7, [r3, #24]
          j++;
 80a1058:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a105c:	3301      	adds	r3, #1
 80a105e:	b2db      	uxtb	r3, r3
 80a1060:	f88d 3005 	strb.w	r3, [sp, #5]
          mask >>= 1; // Do this task during the long delay of this bit
 80a1064:	9b04      	ldr	r3, [sp, #16]
 80a1066:	085b      	lsrs	r3, r3, #1
 80a1068:	9304      	str	r3, [sp, #16]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a106a:	4600      	mov	r0, r0
 80a106c:	bf00      	nop
 80a106e:	bf00      	nop
 80a1070:	bf00      	nop
 80a1072:	bf00      	nop
 80a1074:	bf00      	nop
 80a1076:	bf00      	nop
 80a1078:	bf00      	nop
 80a107a:	bf00      	nop
 80a107c:	bf00      	nop
 80a107e:	bf00      	nop
 80a1080:	bf00      	nop
 80a1082:	bf00      	nop
 80a1084:	bf00      	nop
 80a1086:	bf00      	nop
 80a1088:	bf00      	nop
 80a108a:	bf00      	nop
 80a108c:	bf00      	nop
 80a108e:	bf00      	nop
 80a1090:	bf00      	nop
 80a1092:	bf00      	nop
 80a1094:	bf00      	nop
 80a1096:	bf00      	nop
 80a1098:	bf00      	nop
 80a109a:	bf00      	nop
 80a109c:	bf00      	nop
 80a109e:	bf00      	nop
 80a10a0:	bf00      	nop
 80a10a2:	bf00      	nop
 80a10a4:	bf00      	nop
 80a10a6:	bf00      	nop
 80a10a8:	bf00      	nop
 80a10aa:	bf00      	nop
 80a10ac:	bf00      	nop
 80a10ae:	bf00      	nop
 80a10b0:	bf00      	nop
 80a10b2:	bf00      	nop
 80a10b4:	bf00      	nop
 80a10b6:	bf00      	nop
 80a10b8:	bf00      	nop
 80a10ba:	bf00      	nop
 80a10bc:	bf00      	nop
 80a10be:	bf00      	nop
 80a10c0:	bf00      	nop
 80a10c2:	bf00      	nop
 80a10c4:	bf00      	nop
 80a10c6:	bf00      	nop
 80a10c8:	bf00      	nop
 80a10ca:	bf00      	nop
 80a10cc:	bf00      	nop
 80a10ce:	bf00      	nop
 80a10d0:	bf00      	nop
 80a10d2:	bf00      	nop
 80a10d4:	bf00      	nop
 80a10d6:	bf00      	nop
 80a10d8:	bf00      	nop
 80a10da:	bf00      	nop
 80a10dc:	bf00      	nop
 80a10de:	bf00      	nop
 80a10e0:	bf00      	nop
 80a10e2:	bf00      	nop
 80a10e4:	bf00      	nop
 80a10e6:	bf00      	nop
 80a10e8:	bf00      	nop
 80a10ea:	bf00      	nop
 80a10ec:	bf00      	nop
 80a10ee:	bf00      	nop
 80a10f0:	bf00      	nop
 80a10f2:	bf00      	nop
          if(j==24) break;
 80a10f4:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a10f8:	2b18      	cmp	r3, #24
 80a10fa:	d184      	bne.n	80a1006 <_ZN17Adafruit_NeoPixel4showEv+0xc8e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
 80a10fc:	468e      	mov	lr, r1
 80a10fe:	e6d5      	b.n	80a0eac <_ZN17Adafruit_NeoPixel4showEv+0xb34>
 80a1100:	4a17      	ldr	r2, [pc, #92]	; (80a1160 <_ZN17Adafruit_NeoPixel4showEv+0xde8>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a1102:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a1106:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1108:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a110c:	b29b      	uxth	r3, r3
 80a110e:	2b00      	cmp	r3, #0
 80a1110:	f43f ad00 	beq.w	80a0b14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a1114:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a1116:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a111a:	f10e 0103 	add.w	r1, lr, #3
 80a111e:	3b03      	subs	r3, #3
 80a1120:	b29b      	uxth	r3, r3
 80a1122:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a1126:	f89e 3000 	ldrb.w	r3, [lr]
 80a112a:	b2db      	uxtb	r3, r3
 80a112c:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next blue byte value
 80a1130:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a1134:	b2db      	uxtb	r3, r3
 80a1136:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next green byte value
 80a113a:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a113e:	b2db      	uxtb	r3, r3
 80a1140:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a1144:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a1148:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a114c:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a1150:	021b      	lsls	r3, r3, #8
 80a1152:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a1156:	4303      	orrs	r3, r0
 80a1158:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a115a:	f88d 6005 	strb.w	r6, [sp, #5]
 80a115e:	e0e0      	b.n	80a1322 <_ZN17Adafruit_NeoPixel4showEv+0xfaa>
 80a1160:	200000f0 	.word	0x200000f0
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1164:	4600      	mov	r0, r0
 80a1166:	bf00      	nop
 80a1168:	bf00      	nop
 80a116a:	bf00      	nop
 80a116c:	bf00      	nop
 80a116e:	bf00      	nop
 80a1170:	bf00      	nop
 80a1172:	bf00      	nop
 80a1174:	bf00      	nop
 80a1176:	bf00      	nop
 80a1178:	bf00      	nop
 80a117a:	bf00      	nop
 80a117c:	bf00      	nop
 80a117e:	bf00      	nop
 80a1180:	bf00      	nop
 80a1182:	bf00      	nop
 80a1184:	bf00      	nop
 80a1186:	bf00      	nop
 80a1188:	bf00      	nop
 80a118a:	bf00      	nop
 80a118c:	bf00      	nop
 80a118e:	bf00      	nop
 80a1190:	bf00      	nop
 80a1192:	bf00      	nop
 80a1194:	bf00      	nop
 80a1196:	bf00      	nop
 80a1198:	bf00      	nop
 80a119a:	bf00      	nop
 80a119c:	bf00      	nop
 80a119e:	bf00      	nop
 80a11a0:	bf00      	nop
 80a11a2:	bf00      	nop
 80a11a4:	bf00      	nop
 80a11a6:	bf00      	nop
 80a11a8:	bf00      	nop
 80a11aa:	bf00      	nop
 80a11ac:	bf00      	nop
 80a11ae:	bf00      	nop
 80a11b0:	bf00      	nop
 80a11b2:	bf00      	nop
 80a11b4:	bf00      	nop
 80a11b6:	bf00      	nop
 80a11b8:	bf00      	nop
 80a11ba:	bf00      	nop
 80a11bc:	bf00      	nop
 80a11be:	bf00      	nop
 80a11c0:	bf00      	nop
 80a11c2:	bf00      	nop
 80a11c4:	bf00      	nop
 80a11c6:	bf00      	nop
 80a11c8:	bf00      	nop
 80a11ca:	bf00      	nop
 80a11cc:	bf00      	nop
 80a11ce:	bf00      	nop
 80a11d0:	bf00      	nop
 80a11d2:	bf00      	nop
 80a11d4:	bf00      	nop
 80a11d6:	bf00      	nop
 80a11d8:	bf00      	nop
 80a11da:	bf00      	nop
 80a11dc:	bf00      	nop
 80a11de:	bf00      	nop
 80a11e0:	bf00      	nop
 80a11e2:	bf00      	nop
 80a11e4:	bf00      	nop
 80a11e6:	bf00      	nop
 80a11e8:	bf00      	nop
 80a11ea:	bf00      	nop
 80a11ec:	bf00      	nop
 80a11ee:	bf00      	nop
 80a11f0:	bf00      	nop
 80a11f2:	bf00      	nop
 80a11f4:	bf00      	nop
 80a11f6:	bf00      	nop
 80a11f8:	bf00      	nop
 80a11fa:	bf00      	nop
 80a11fc:	bf00      	nop
 80a11fe:	bf00      	nop
 80a1200:	bf00      	nop
 80a1202:	bf00      	nop
 80a1204:	bf00      	nop
 80a1206:	bf00      	nop
 80a1208:	bf00      	nop
 80a120a:	bf00      	nop
 80a120c:	bf00      	nop
 80a120e:	bf00      	nop
 80a1210:	bf00      	nop
 80a1212:	bf00      	nop
 80a1214:	bf00      	nop
 80a1216:	bf00      	nop
 80a1218:	bf00      	nop
 80a121a:	bf00      	nop
 80a121c:	bf00      	nop
 80a121e:	bf00      	nop
 80a1220:	bf00      	nop
 80a1222:	bf00      	nop
 80a1224:	bf00      	nop
 80a1226:	bf00      	nop
 80a1228:	bf00      	nop
 80a122a:	bf00      	nop
 80a122c:	bf00      	nop
 80a122e:	bf00      	nop
 80a1230:	bf00      	nop
 80a1232:	bf00      	nop
 80a1234:	bf00      	nop
 80a1236:	bf00      	nop
 80a1238:	bf00      	nop
 80a123a:	bf00      	nop
 80a123c:	bf00      	nop
 80a123e:	bf00      	nop
 80a1240:	bf00      	nop
 80a1242:	bf00      	nop
 80a1244:	bf00      	nop
 80a1246:	bf00      	nop
 80a1248:	bf00      	nop
 80a124a:	bf00      	nop
 80a124c:	bf00      	nop
 80a124e:	bf00      	nop
 80a1250:	bf00      	nop
 80a1252:	bf00      	nop
 80a1254:	bf00      	nop
 80a1256:	bf00      	nop
 80a1258:	bf00      	nop
 80a125a:	bf00      	nop
 80a125c:	bf00      	nop
 80a125e:	bf00      	nop
 80a1260:	bf00      	nop
 80a1262:	bf00      	nop
 80a1264:	bf00      	nop
 80a1266:	bf00      	nop
 80a1268:	bf00      	nop
 80a126a:	bf00      	nop
 80a126c:	bf00      	nop
 80a126e:	bf00      	nop
 80a1270:	bf00      	nop
 80a1272:	bf00      	nop
 80a1274:	bf00      	nop
 80a1276:	bf00      	nop
 80a1278:	bf00      	nop
 80a127a:	bf00      	nop
 80a127c:	bf00      	nop
 80a127e:	bf00      	nop
 80a1280:	bf00      	nop
 80a1282:	bf00      	nop
 80a1284:	bf00      	nop
          // TM1803 spec             680ns LOW
          // Pololu on Arduino      (meas. 1.024us)
          // This lib on Spark Core (meas. 680ns)
          // This lib on Photon     (meas. 684ns)
          pinSet(pin, LOW); // LOW
 80a1286:	79e3      	ldrb	r3, [r4, #7]
 80a1288:	6810      	ldr	r0, [r2, #0]
 80a128a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a128e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1292:	88bf      	ldrh	r7, [r7, #4]
 80a1294:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1298:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a129a:	4600      	mov	r0, r0
 80a129c:	bf00      	nop
 80a129e:	bf00      	nop
 80a12a0:	bf00      	nop
 80a12a2:	bf00      	nop
 80a12a4:	bf00      	nop
 80a12a6:	bf00      	nop
 80a12a8:	bf00      	nop
 80a12aa:	bf00      	nop
 80a12ac:	bf00      	nop
 80a12ae:	bf00      	nop
 80a12b0:	bf00      	nop
 80a12b2:	bf00      	nop
 80a12b4:	bf00      	nop
 80a12b6:	bf00      	nop
 80a12b8:	bf00      	nop
 80a12ba:	bf00      	nop
 80a12bc:	bf00      	nop
 80a12be:	bf00      	nop
 80a12c0:	bf00      	nop
 80a12c2:	bf00      	nop
 80a12c4:	bf00      	nop
 80a12c6:	bf00      	nop
 80a12c8:	bf00      	nop
 80a12ca:	bf00      	nop
 80a12cc:	bf00      	nop
 80a12ce:	bf00      	nop
 80a12d0:	bf00      	nop
 80a12d2:	bf00      	nop
 80a12d4:	bf00      	nop
 80a12d6:	bf00      	nop
 80a12d8:	bf00      	nop
 80a12da:	bf00      	nop
 80a12dc:	bf00      	nop
 80a12de:	bf00      	nop
 80a12e0:	bf00      	nop
 80a12e2:	bf00      	nop
 80a12e4:	bf00      	nop
 80a12e6:	bf00      	nop
 80a12e8:	bf00      	nop
 80a12ea:	bf00      	nop
 80a12ec:	bf00      	nop
 80a12ee:	bf00      	nop
 80a12f0:	bf00      	nop
 80a12f2:	bf00      	nop
 80a12f4:	bf00      	nop
 80a12f6:	bf00      	nop
 80a12f8:	bf00      	nop
 80a12fa:	bf00      	nop
 80a12fc:	bf00      	nop
 80a12fe:	bf00      	nop
 80a1300:	bf00      	nop
 80a1302:	bf00      	nop
 80a1304:	bf00      	nop
 80a1306:	bf00      	nop
 80a1308:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a130a:	9b04      	ldr	r3, [sp, #16]
 80a130c:	085b      	lsrs	r3, r3, #1
 80a130e:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a1310:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1314:	3301      	adds	r3, #1
 80a1316:	b2db      	uxtb	r3, r3
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a1318:	2b17      	cmp	r3, #23
 80a131a:	f88d 3005 	strb.w	r3, [sp, #5]
 80a131e:	f200 80e3 	bhi.w	80a14e8 <_ZN17Adafruit_NeoPixel4showEv+0x1170>
        pinSet(pin, HIGH); // HIGH
 80a1322:	79e3      	ldrb	r3, [r4, #7]
 80a1324:	6810      	ldr	r0, [r2, #0]
 80a1326:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a132a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a132e:	88bf      	ldrh	r7, [r7, #4]
 80a1330:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1334:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a1336:	9803      	ldr	r0, [sp, #12]
 80a1338:	9b04      	ldr	r3, [sp, #16]
 80a133a:	4218      	tst	r0, r3
 80a133c:	f47f af12 	bne.w	80a1164 <_ZN17Adafruit_NeoPixel4showEv+0xdec>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1340:	4600      	mov	r0, r0
 80a1342:	bf00      	nop
 80a1344:	bf00      	nop
 80a1346:	bf00      	nop
 80a1348:	bf00      	nop
 80a134a:	bf00      	nop
 80a134c:	bf00      	nop
 80a134e:	bf00      	nop
 80a1350:	bf00      	nop
 80a1352:	bf00      	nop
 80a1354:	bf00      	nop
 80a1356:	bf00      	nop
 80a1358:	bf00      	nop
 80a135a:	bf00      	nop
 80a135c:	bf00      	nop
 80a135e:	bf00      	nop
 80a1360:	bf00      	nop
 80a1362:	bf00      	nop
 80a1364:	bf00      	nop
 80a1366:	bf00      	nop
 80a1368:	bf00      	nop
 80a136a:	bf00      	nop
 80a136c:	bf00      	nop
 80a136e:	bf00      	nop
 80a1370:	bf00      	nop
 80a1372:	bf00      	nop
 80a1374:	bf00      	nop
 80a1376:	bf00      	nop
 80a1378:	bf00      	nop
 80a137a:	bf00      	nop
 80a137c:	bf00      	nop
 80a137e:	bf00      	nop
 80a1380:	bf00      	nop
 80a1382:	bf00      	nop
 80a1384:	bf00      	nop
 80a1386:	bf00      	nop
 80a1388:	bf00      	nop
 80a138a:	bf00      	nop
 80a138c:	bf00      	nop
 80a138e:	bf00      	nop
 80a1390:	bf00      	nop
 80a1392:	bf00      	nop
 80a1394:	bf00      	nop
 80a1396:	bf00      	nop
 80a1398:	bf00      	nop
 80a139a:	bf00      	nop
 80a139c:	bf00      	nop
 80a139e:	bf00      	nop
 80a13a0:	bf00      	nop
 80a13a2:	bf00      	nop
 80a13a4:	bf00      	nop
 80a13a6:	bf00      	nop
 80a13a8:	bf00      	nop
 80a13aa:	bf00      	nop
 80a13ac:	bf00      	nop
 80a13ae:	bf00      	nop
 80a13b0:	bf00      	nop
 80a13b2:	bf00      	nop
 80a13b4:	bf00      	nop
 80a13b6:	bf00      	nop
 80a13b8:	bf00      	nop
 80a13ba:	bf00      	nop
 80a13bc:	bf00      	nop
 80a13be:	bf00      	nop
 80a13c0:	bf00      	nop
          // TM1803 spec             1.36us LOW
          // Pololu on Arduino      (meas. 2.00us)
          // This lib on Spark Core (meas. 1.36us)
          // This lib on Photon     (meas. 1.36us)
          pinSet(pin, LOW); // LOW
 80a13c2:	79e3      	ldrb	r3, [r4, #7]
 80a13c4:	6810      	ldr	r0, [r2, #0]
 80a13c6:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a13ca:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a13ce:	88bf      	ldrh	r7, [r7, #4]
 80a13d0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a13d4:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a13d6:	4600      	mov	r0, r0
 80a13d8:	bf00      	nop
 80a13da:	bf00      	nop
 80a13dc:	bf00      	nop
 80a13de:	bf00      	nop
 80a13e0:	bf00      	nop
 80a13e2:	bf00      	nop
 80a13e4:	bf00      	nop
 80a13e6:	bf00      	nop
 80a13e8:	bf00      	nop
 80a13ea:	bf00      	nop
 80a13ec:	bf00      	nop
 80a13ee:	bf00      	nop
 80a13f0:	bf00      	nop
 80a13f2:	bf00      	nop
 80a13f4:	bf00      	nop
 80a13f6:	bf00      	nop
 80a13f8:	bf00      	nop
 80a13fa:	bf00      	nop
 80a13fc:	bf00      	nop
 80a13fe:	bf00      	nop
 80a1400:	bf00      	nop
 80a1402:	bf00      	nop
 80a1404:	bf00      	nop
 80a1406:	bf00      	nop
 80a1408:	bf00      	nop
 80a140a:	bf00      	nop
 80a140c:	bf00      	nop
 80a140e:	bf00      	nop
 80a1410:	bf00      	nop
 80a1412:	bf00      	nop
 80a1414:	bf00      	nop
 80a1416:	bf00      	nop
 80a1418:	bf00      	nop
 80a141a:	bf00      	nop
 80a141c:	bf00      	nop
 80a141e:	bf00      	nop
 80a1420:	bf00      	nop
 80a1422:	bf00      	nop
 80a1424:	bf00      	nop
 80a1426:	bf00      	nop
 80a1428:	bf00      	nop
 80a142a:	bf00      	nop
 80a142c:	bf00      	nop
 80a142e:	bf00      	nop
 80a1430:	bf00      	nop
 80a1432:	bf00      	nop
 80a1434:	bf00      	nop
 80a1436:	bf00      	nop
 80a1438:	bf00      	nop
 80a143a:	bf00      	nop
 80a143c:	bf00      	nop
 80a143e:	bf00      	nop
 80a1440:	bf00      	nop
 80a1442:	bf00      	nop
 80a1444:	bf00      	nop
 80a1446:	bf00      	nop
 80a1448:	bf00      	nop
 80a144a:	bf00      	nop
 80a144c:	bf00      	nop
 80a144e:	bf00      	nop
 80a1450:	bf00      	nop
 80a1452:	bf00      	nop
 80a1454:	bf00      	nop
 80a1456:	bf00      	nop
 80a1458:	bf00      	nop
 80a145a:	bf00      	nop
 80a145c:	bf00      	nop
 80a145e:	bf00      	nop
 80a1460:	bf00      	nop
 80a1462:	bf00      	nop
 80a1464:	bf00      	nop
 80a1466:	bf00      	nop
 80a1468:	bf00      	nop
 80a146a:	bf00      	nop
 80a146c:	bf00      	nop
 80a146e:	bf00      	nop
 80a1470:	bf00      	nop
 80a1472:	bf00      	nop
 80a1474:	bf00      	nop
 80a1476:	bf00      	nop
 80a1478:	bf00      	nop
 80a147a:	bf00      	nop
 80a147c:	bf00      	nop
 80a147e:	bf00      	nop
 80a1480:	bf00      	nop
 80a1482:	bf00      	nop
 80a1484:	bf00      	nop
 80a1486:	bf00      	nop
 80a1488:	bf00      	nop
 80a148a:	bf00      	nop
 80a148c:	bf00      	nop
 80a148e:	bf00      	nop
 80a1490:	bf00      	nop
 80a1492:	bf00      	nop
 80a1494:	bf00      	nop
 80a1496:	bf00      	nop
 80a1498:	bf00      	nop
 80a149a:	bf00      	nop
 80a149c:	bf00      	nop
 80a149e:	bf00      	nop
 80a14a0:	bf00      	nop
 80a14a2:	bf00      	nop
 80a14a4:	bf00      	nop
 80a14a6:	bf00      	nop
 80a14a8:	bf00      	nop
 80a14aa:	bf00      	nop
 80a14ac:	bf00      	nop
 80a14ae:	bf00      	nop
 80a14b0:	bf00      	nop
 80a14b2:	bf00      	nop
 80a14b4:	bf00      	nop
 80a14b6:	bf00      	nop
 80a14b8:	bf00      	nop
 80a14ba:	bf00      	nop
 80a14bc:	bf00      	nop
 80a14be:	bf00      	nop
 80a14c0:	bf00      	nop
 80a14c2:	bf00      	nop
 80a14c4:	bf00      	nop
 80a14c6:	bf00      	nop
 80a14c8:	bf00      	nop
 80a14ca:	bf00      	nop
 80a14cc:	bf00      	nop
 80a14ce:	bf00      	nop
 80a14d0:	bf00      	nop
 80a14d2:	bf00      	nop
 80a14d4:	bf00      	nop
 80a14d6:	bf00      	nop
 80a14d8:	bf00      	nop
 80a14da:	bf00      	nop
 80a14dc:	bf00      	nop
 80a14de:	bf00      	nop
 80a14e0:	bf00      	nop
 80a14e2:	bf00      	nop
 80a14e4:	bf00      	nop
 80a14e6:	e710      	b.n	80a130a <_ZN17Adafruit_NeoPixel4showEv+0xf92>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
 80a14e8:	468e      	mov	lr, r1
 80a14ea:	e60d      	b.n	80a1108 <_ZN17Adafruit_NeoPixel4showEv+0xd90>

080a14ec <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>:
  endTime = micros(); // Save EOD time for latch on next call
}

// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
 80a14ec:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(n < numLEDs) {
 80a14ee:	8844      	ldrh	r4, [r0, #2]
  endTime = micros(); // Save EOD time for latch on next call
}

// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
 80a14f0:	f89d 5014 	ldrb.w	r5, [sp, #20]
  if(n < numLEDs) {
 80a14f4:	428c      	cmp	r4, r1
 80a14f6:	d927      	bls.n	80a1548 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x5c>
    if(brightness) { // See notes in setBrightness()
 80a14f8:	7a04      	ldrb	r4, [r0, #8]
 80a14fa:	b144      	cbz	r4, 80a150e <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x22>
      r = (r * brightness) >> 8;
 80a14fc:	4362      	muls	r2, r4
      g = (g * brightness) >> 8;
 80a14fe:	4363      	muls	r3, r4
      b = (b * brightness) >> 8;
 80a1500:	436c      	muls	r4, r5
// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
  if(n < numLEDs) {
    if(brightness) { // See notes in setBrightness()
      r = (r * brightness) >> 8;
 80a1502:	f3c2 2207 	ubfx	r2, r2, #8, #8
      g = (g * brightness) >> 8;
 80a1506:	f3c3 2307 	ubfx	r3, r3, #8, #8
      b = (b * brightness) >> 8;
 80a150a:	f3c4 2507 	ubfx	r5, r4, #8, #8
    }
    uint8_t *p = &pixels[n * 3];
    switch(type) {
 80a150e:	7987      	ldrb	r7, [r0, #6]
    if(brightness) { // See notes in setBrightness()
      r = (r * brightness) >> 8;
      g = (g * brightness) >> 8;
      b = (b * brightness) >> 8;
    }
    uint8_t *p = &pixels[n * 3];
 80a1510:	68c6      	ldr	r6, [r0, #12]
 80a1512:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80a1516:	2f08      	cmp	r7, #8
 80a1518:	eb06 0401 	add.w	r4, r6, r1
 80a151c:	d811      	bhi.n	80a1542 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x56>
 80a151e:	2001      	movs	r0, #1
 80a1520:	40b8      	lsls	r0, r7
 80a1522:	f410 7fd2 	tst.w	r0, #420	; 0x1a4
 80a1526:	d108      	bne.n	80a153a <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x4e>
 80a1528:	06c0      	lsls	r0, r0, #27
 80a152a:	d50a      	bpl.n	80a1542 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x56>
          *p++ = g;
          *p++ = r;
          *p = b;
        } break;
      case TM1829: { // TM1829 is special RBG order
          if(r == 255) r = 254; // 255 on RED channel causes display to be in a special mode.
 80a152c:	2aff      	cmp	r2, #255	; 0xff
 80a152e:	bf08      	it	eq
 80a1530:	22fe      	moveq	r2, #254	; 0xfe
          *p++ = r;
 80a1532:	5472      	strb	r2, [r6, r1]
          *p++ = b;
 80a1534:	7065      	strb	r5, [r4, #1]
          *p = g;
 80a1536:	70a3      	strb	r3, [r4, #2]
 80a1538:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch(type) {
      case WS2812B: // WS2812, WS2812B & WS2813 is GRB order.
      case WS2812B_FAST:
      case WS2812B2:
      case WS2812B2_FAST: {
          *p++ = g;
 80a153a:	5473      	strb	r3, [r6, r1]
          *p++ = r;
 80a153c:	7062      	strb	r2, [r4, #1]
          *p = b;
 80a153e:	70a5      	strb	r5, [r4, #2]
 80a1540:	bdf0      	pop	{r4, r5, r6, r7, pc}
          *p = g;
        } break;
      case WS2811: // WS2811 is RGB order
      case TM1803: // TM1803 is RGB order
      default: {   // default is RGB order
          *p++ = r;
 80a1542:	5472      	strb	r2, [r6, r1]
          *p++ = g;
 80a1544:	7063      	strb	r3, [r4, #1]
          *p = b;
 80a1546:	70a5      	strb	r5, [r4, #2]
 80a1548:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a154a <_ZNK17Adafruit_NeoPixel9numPixelsEv>:
 80a154a:	8840      	ldrh	r0, [r0, #2]
 80a154c:	4770      	bx	lr

080a154e <_ZN17Adafruit_NeoPixel13setBrightnessEh>:
  // This simplifies the actual scaling math later, allowing a fast
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
 80a154e:	1c4a      	adds	r2, r1, #1
  if(newBrightness != brightness) { // Compare against prior value
 80a1550:	7a03      	ldrb	r3, [r0, #8]
  // This simplifies the actual scaling math later, allowing a fast
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
 80a1552:	b2d2      	uxtb	r2, r2
  if(newBrightness != brightness) { // Compare against prior value
 80a1554:	429a      	cmp	r2, r3
// and scale it (subsequent graphics commands also work at this
// brightness level).  If there's a significant step up in brightness,
// the limited number of steps (quantization) in the old data will be
// quite visible in the re-scaled version.  For a non-destructive
// change, you'll need to re-render the full strip data.  C'est la vie.
void Adafruit_NeoPixel::setBrightness(uint8_t b) {
 80a1556:	b570      	push	{r4, r5, r6, lr}
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
 80a1558:	d01e      	beq.n	80a1598 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x4a>
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
             oldBrightness = brightness - 1; // De-wrap old brightness value
 80a155a:	3b01      	subs	r3, #1
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
 80a155c:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
 80a1560:	68c4      	ldr	r4, [r0, #12]
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
 80a1562:	d00c      	beq.n	80a157e <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x30>
    else if(b == 255) scale = 65535 / oldBrightness;
 80a1564:	29ff      	cmp	r1, #255	; 0xff
 80a1566:	bf0f      	iteee	eq
 80a1568:	f64f 71ff 	movweq	r1, #65535	; 0xffff
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
 80a156c:	0211      	lslne	r1, r2, #8
 80a156e:	f101 31ff 	addne.w	r1, r1, #4294967295
 80a1572:	fb91 f3f3 	sdivne	r3, r1, r3
    uint8_t  c,
            *ptr           = pixels,
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
    else if(b == 255) scale = 65535 / oldBrightness;
 80a1576:	bf0c      	ite	eq
 80a1578:	fb91 f3f3 	sdiveq	r3, r1, r3
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
 80a157c:	b29b      	uxthne	r3, r3
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
 80a157e:	4625      	mov	r5, r4
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
    else if(b == 255) scale = 65535 / oldBrightness;
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    for(uint16_t i=0; i<numBytes; i++) {
 80a1580:	1b29      	subs	r1, r5, r4
 80a1582:	8886      	ldrh	r6, [r0, #4]
 80a1584:	b289      	uxth	r1, r1
 80a1586:	428e      	cmp	r6, r1
 80a1588:	d905      	bls.n	80a1596 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x48>
      c      = *ptr;
 80a158a:	7829      	ldrb	r1, [r5, #0]
      *ptr++ = (c * scale) >> 8;
 80a158c:	4359      	muls	r1, r3
 80a158e:	1209      	asrs	r1, r1, #8
 80a1590:	f805 1b01 	strb.w	r1, [r5], #1
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
    else if(b == 255) scale = 65535 / oldBrightness;
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    for(uint16_t i=0; i<numBytes; i++) {
 80a1594:	e7f4      	b.n	80a1580 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x32>
      c      = *ptr;
      *ptr++ = (c * scale) >> 8;
    }
    brightness = newBrightness;
 80a1596:	7202      	strb	r2, [r0, #8]
 80a1598:	bd70      	pop	{r4, r5, r6, pc}

080a159a <_ZN17Adafruit_NeoPixel5clearEv>:
uint8_t Adafruit_NeoPixel::getBrightness(void) const {
  return brightness - 1;
}

void Adafruit_NeoPixel::clear(void) {
  memset(pixels, 0, numBytes);
 80a159a:	8882      	ldrh	r2, [r0, #4]
 80a159c:	2100      	movs	r1, #0
 80a159e:	68c0      	ldr	r0, [r0, #12]
 80a15a0:	f001 b931 	b.w	80a2806 <memset>

080a15a4 <_GLOBAL__sub_I_PIN_MAP2>:
}
 80a15a4:	b508      	push	{r3, lr}
 80a15a6:	f000 f807 	bl	80a15b8 <HAL_Pin_Map>

#if PLATFORM_ID == 0 // Core (0)
  #define pinLO(_pin) (PIN_MAP[_pin].gpio_peripheral->BRR = PIN_MAP[_pin].gpio_pin)
  #define pinHI(_pin) (PIN_MAP[_pin].gpio_peripheral->BSRR = PIN_MAP[_pin].gpio_pin)
#elif (PLATFORM_ID == 6) || (PLATFORM_ID == 8) || (PLATFORM_ID == 10) || (PLATFORM_ID == 88) // Photon (6), P1 (8), Electron (10) or Redbear Duo (88)
  STM32_Pin_Info* PIN_MAP2 = HAL_Pin_Map(); // Pointer required for highest access speed
 80a15aa:	f000 f805 	bl	80a15b8 <HAL_Pin_Map>
 80a15ae:	4b01      	ldr	r3, [pc, #4]	; (80a15b4 <_GLOBAL__sub_I_PIN_MAP2+0x10>)
 80a15b0:	6018      	str	r0, [r3, #0]
 80a15b2:	bd08      	pop	{r3, pc}
 80a15b4:	200000f0 	.word	0x200000f0

080a15b8 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
 80a15b8:	b508      	push	{r3, lr}
 80a15ba:	4b02      	ldr	r3, [pc, #8]	; (80a15c4 <HAL_Pin_Map+0xc>)
 80a15bc:	681b      	ldr	r3, [r3, #0]
 80a15be:	681b      	ldr	r3, [r3, #0]
 80a15c0:	9301      	str	r3, [sp, #4]
 80a15c2:	bd08      	pop	{r3, pc}
 80a15c4:	080601b0 	.word	0x080601b0

080a15c8 <HAL_Pin_Mode>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a15c8:	b508      	push	{r3, lr}
 80a15ca:	4b02      	ldr	r3, [pc, #8]	; (80a15d4 <HAL_Pin_Mode+0xc>)
 80a15cc:	681b      	ldr	r3, [r3, #0]
 80a15ce:	689b      	ldr	r3, [r3, #8]
 80a15d0:	9301      	str	r3, [sp, #4]
 80a15d2:	bd08      	pop	{r3, pc}
 80a15d4:	080601b0 	.word	0x080601b0

080a15d8 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a15d8:	b508      	push	{r3, lr}
 80a15da:	4b02      	ldr	r3, [pc, #8]	; (80a15e4 <HAL_Get_Pin_Mode+0xc>)
 80a15dc:	681b      	ldr	r3, [r3, #0]
 80a15de:	68db      	ldr	r3, [r3, #12]
 80a15e0:	9301      	str	r3, [sp, #4]
 80a15e2:	bd08      	pop	{r3, pc}
 80a15e4:	080601b0 	.word	0x080601b0

080a15e8 <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a15e8:	b508      	push	{r3, lr}
 80a15ea:	4b02      	ldr	r3, [pc, #8]	; (80a15f4 <HAL_GPIO_Write+0xc>)
 80a15ec:	681b      	ldr	r3, [r3, #0]
 80a15ee:	691b      	ldr	r3, [r3, #16]
 80a15f0:	9301      	str	r3, [sp, #4]
 80a15f2:	bd08      	pop	{r3, pc}
 80a15f4:	080601b0 	.word	0x080601b0

080a15f8 <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a15f8:	b508      	push	{r3, lr}
 80a15fa:	4b02      	ldr	r3, [pc, #8]	; (80a1604 <HAL_SPI_Init+0xc>)
 80a15fc:	681b      	ldr	r3, [r3, #0]
 80a15fe:	69db      	ldr	r3, [r3, #28]
 80a1600:	9301      	str	r3, [sp, #4]
 80a1602:	bd08      	pop	{r3, pc}
 80a1604:	080601b4 	.word	0x080601b4

080a1608 <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a1608:	b508      	push	{r3, lr}
 80a160a:	4b02      	ldr	r3, [pc, #8]	; (80a1614 <HAL_SPI_Is_Enabled+0xc>)
 80a160c:	681b      	ldr	r3, [r3, #0]
 80a160e:	6a1b      	ldr	r3, [r3, #32]
 80a1610:	9301      	str	r3, [sp, #4]
 80a1612:	bd08      	pop	{r3, pc}
 80a1614:	080601b4 	.word	0x080601b4

080a1618 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a1618:	b508      	push	{r3, lr}
 80a161a:	4b02      	ldr	r3, [pc, #8]	; (80a1624 <HAL_RNG_GetRandomNumber+0xc>)
 80a161c:	681b      	ldr	r3, [r3, #0]
 80a161e:	685b      	ldr	r3, [r3, #4]
 80a1620:	9301      	str	r3, [sp, #4]
 80a1622:	bd08      	pop	{r3, pc}
 80a1624:	0806019c 	.word	0x0806019c

080a1628 <HAL_Timer_Get_Micro_Seconds>:
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
 80a1628:	b508      	push	{r3, lr}
 80a162a:	4b02      	ldr	r3, [pc, #8]	; (80a1634 <HAL_Timer_Get_Micro_Seconds+0xc>)
 80a162c:	681b      	ldr	r3, [r3, #0]
 80a162e:	691b      	ldr	r3, [r3, #16]
 80a1630:	9301      	str	r3, [sp, #4]
 80a1632:	bd08      	pop	{r3, pc}
 80a1634:	0806019c 	.word	0x0806019c

080a1638 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a1638:	b508      	push	{r3, lr}
 80a163a:	4b02      	ldr	r3, [pc, #8]	; (80a1644 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a163c:	681b      	ldr	r3, [r3, #0]
 80a163e:	695b      	ldr	r3, [r3, #20]
 80a1640:	9301      	str	r3, [sp, #4]
 80a1642:	bd08      	pop	{r3, pc}
 80a1644:	0806019c 	.word	0x0806019c

080a1648 <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
 80a1648:	b508      	push	{r3, lr}
 80a164a:	4b02      	ldr	r3, [pc, #8]	; (80a1654 <os_mutex_recursive_create+0xc>)
 80a164c:	681b      	ldr	r3, [r3, #0]
 80a164e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a1650:	9301      	str	r3, [sp, #4]
 80a1652:	bd08      	pop	{r3, pc}
 80a1654:	080601d0 	.word	0x080601d0

080a1658 <os_mutex_recursive_destroy>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
 80a1658:	b508      	push	{r3, lr}
 80a165a:	4b02      	ldr	r3, [pc, #8]	; (80a1664 <os_mutex_recursive_destroy+0xc>)
 80a165c:	681b      	ldr	r3, [r3, #0]
 80a165e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a1660:	9301      	str	r3, [sp, #4]
 80a1662:	bd08      	pop	{r3, pc}
 80a1664:	080601d0 	.word	0x080601d0

080a1668 <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a1668:	b508      	push	{r3, lr}
 80a166a:	4b02      	ldr	r3, [pc, #8]	; (80a1674 <HAL_USART_Init+0xc>)
 80a166c:	681b      	ldr	r3, [r3, #0]
 80a166e:	699b      	ldr	r3, [r3, #24]
 80a1670:	9301      	str	r3, [sp, #4]
 80a1672:	bd08      	pop	{r3, pc}
 80a1674:	080601c4 	.word	0x080601c4

080a1678 <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a1678:	b508      	push	{r3, lr}
 80a167a:	4b02      	ldr	r3, [pc, #8]	; (80a1684 <HAL_USART_Write_Data+0xc>)
 80a167c:	681b      	ldr	r3, [r3, #0]
 80a167e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a1680:	9301      	str	r3, [sp, #4]
 80a1682:	bd08      	pop	{r3, pc}
 80a1684:	080601c4 	.word	0x080601c4

080a1688 <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a1688:	b508      	push	{r3, lr}
 80a168a:	4b02      	ldr	r3, [pc, #8]	; (80a1694 <HAL_USART_Available_Data+0xc>)
 80a168c:	681b      	ldr	r3, [r3, #0]
 80a168e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a1690:	9301      	str	r3, [sp, #4]
 80a1692:	bd08      	pop	{r3, pc}
 80a1694:	080601c4 	.word	0x080601c4

080a1698 <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a1698:	b508      	push	{r3, lr}
 80a169a:	4b02      	ldr	r3, [pc, #8]	; (80a16a4 <HAL_USART_Read_Data+0xc>)
 80a169c:	681b      	ldr	r3, [r3, #0]
 80a169e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a16a0:	9301      	str	r3, [sp, #4]
 80a16a2:	bd08      	pop	{r3, pc}
 80a16a4:	080601c4 	.word	0x080601c4

080a16a8 <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a16a8:	b508      	push	{r3, lr}
 80a16aa:	4b02      	ldr	r3, [pc, #8]	; (80a16b4 <HAL_USART_Peek_Data+0xc>)
 80a16ac:	681b      	ldr	r3, [r3, #0]
 80a16ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a16b0:	9301      	str	r3, [sp, #4]
 80a16b2:	bd08      	pop	{r3, pc}
 80a16b4:	080601c4 	.word	0x080601c4

080a16b8 <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a16b8:	b508      	push	{r3, lr}
 80a16ba:	4b02      	ldr	r3, [pc, #8]	; (80a16c4 <HAL_USART_Flush_Data+0xc>)
 80a16bc:	681b      	ldr	r3, [r3, #0]
 80a16be:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a16c0:	9301      	str	r3, [sp, #4]
 80a16c2:	bd08      	pop	{r3, pc}
 80a16c4:	080601c4 	.word	0x080601c4

080a16c8 <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a16c8:	b508      	push	{r3, lr}
 80a16ca:	4b02      	ldr	r3, [pc, #8]	; (80a16d4 <HAL_USART_Is_Enabled+0xc>)
 80a16cc:	681b      	ldr	r3, [r3, #0]
 80a16ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a16d0:	9301      	str	r3, [sp, #4]
 80a16d2:	bd08      	pop	{r3, pc}
 80a16d4:	080601c4 	.word	0x080601c4

080a16d8 <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a16d8:	b508      	push	{r3, lr}
 80a16da:	4b02      	ldr	r3, [pc, #8]	; (80a16e4 <HAL_USART_Available_Data_For_Write+0xc>)
 80a16dc:	681b      	ldr	r3, [r3, #0]
 80a16de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a16e0:	9301      	str	r3, [sp, #4]
 80a16e2:	bd08      	pop	{r3, pc}
 80a16e4:	080601c4 	.word	0x080601c4

080a16e8 <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, const HAL_I2C_Transmission_Config*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a16e8:	b508      	push	{r3, lr}
 80a16ea:	4b02      	ldr	r3, [pc, #8]	; (80a16f4 <HAL_I2C_Write_Data+0xc>)
 80a16ec:	681b      	ldr	r3, [r3, #0]
 80a16ee:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a16f0:	9301      	str	r3, [sp, #4]
 80a16f2:	bd08      	pop	{r3, pc}
 80a16f4:	080601ac 	.word	0x080601ac

080a16f8 <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a16f8:	b508      	push	{r3, lr}
 80a16fa:	4b02      	ldr	r3, [pc, #8]	; (80a1704 <HAL_I2C_Available_Data+0xc>)
 80a16fc:	681b      	ldr	r3, [r3, #0]
 80a16fe:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a1700:	9301      	str	r3, [sp, #4]
 80a1702:	bd08      	pop	{r3, pc}
 80a1704:	080601ac 	.word	0x080601ac

080a1708 <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a1708:	b508      	push	{r3, lr}
 80a170a:	4b02      	ldr	r3, [pc, #8]	; (80a1714 <HAL_I2C_Read_Data+0xc>)
 80a170c:	681b      	ldr	r3, [r3, #0]
 80a170e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a1710:	9301      	str	r3, [sp, #4]
 80a1712:	bd08      	pop	{r3, pc}
 80a1714:	080601ac 	.word	0x080601ac

080a1718 <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a1718:	b508      	push	{r3, lr}
 80a171a:	4b02      	ldr	r3, [pc, #8]	; (80a1724 <HAL_I2C_Peek_Data+0xc>)
 80a171c:	681b      	ldr	r3, [r3, #0]
 80a171e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a1720:	9301      	str	r3, [sp, #4]
 80a1722:	bd08      	pop	{r3, pc}
 80a1724:	080601ac 	.word	0x080601ac

080a1728 <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a1728:	b508      	push	{r3, lr}
 80a172a:	4b02      	ldr	r3, [pc, #8]	; (80a1734 <HAL_I2C_Flush_Data+0xc>)
 80a172c:	681b      	ldr	r3, [r3, #0]
 80a172e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a1730:	9301      	str	r3, [sp, #4]
 80a1732:	bd08      	pop	{r3, pc}
 80a1734:	080601ac 	.word	0x080601ac

080a1738 <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a1738:	b508      	push	{r3, lr}
 80a173a:	4b02      	ldr	r3, [pc, #8]	; (80a1744 <HAL_I2C_Is_Enabled+0xc>)
 80a173c:	681b      	ldr	r3, [r3, #0]
 80a173e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a1740:	9301      	str	r3, [sp, #4]
 80a1742:	bd08      	pop	{r3, pc}
 80a1744:	080601ac 	.word	0x080601ac

080a1748 <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, int(HAL_I2C_Interface, const HAL_I2C_Config*))
 80a1748:	b508      	push	{r3, lr}
 80a174a:	4b03      	ldr	r3, [pc, #12]	; (80a1758 <HAL_I2C_Init+0x10>)
 80a174c:	681b      	ldr	r3, [r3, #0]
 80a174e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a1752:	9301      	str	r3, [sp, #4]
 80a1754:	bd08      	pop	{r3, pc}
 80a1756:	0000      	.short	0x0000
 80a1758:	080601ac 	.word	0x080601ac

080a175c <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a175c:	b508      	push	{r3, lr}
 80a175e:	4b02      	ldr	r3, [pc, #8]	; (80a1768 <HAL_USB_USART_Init+0xc>)
 80a1760:	681b      	ldr	r3, [r3, #0]
 80a1762:	681b      	ldr	r3, [r3, #0]
 80a1764:	9301      	str	r3, [sp, #4]
 80a1766:	bd08      	pop	{r3, pc}
 80a1768:	080601d8 	.word	0x080601d8

080a176c <HAL_USB_USART_Available_Data>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a176c:	b508      	push	{r3, lr}
 80a176e:	4b02      	ldr	r3, [pc, #8]	; (80a1778 <HAL_USB_USART_Available_Data+0xc>)
 80a1770:	681b      	ldr	r3, [r3, #0]
 80a1772:	691b      	ldr	r3, [r3, #16]
 80a1774:	9301      	str	r3, [sp, #4]
 80a1776:	bd08      	pop	{r3, pc}
 80a1778:	080601d8 	.word	0x080601d8

080a177c <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a177c:	b508      	push	{r3, lr}
 80a177e:	4b02      	ldr	r3, [pc, #8]	; (80a1788 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a1780:	681b      	ldr	r3, [r3, #0]
 80a1782:	695b      	ldr	r3, [r3, #20]
 80a1784:	9301      	str	r3, [sp, #4]
 80a1786:	bd08      	pop	{r3, pc}
 80a1788:	080601d8 	.word	0x080601d8

080a178c <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a178c:	b508      	push	{r3, lr}
 80a178e:	4b02      	ldr	r3, [pc, #8]	; (80a1798 <HAL_USB_USART_Receive_Data+0xc>)
 80a1790:	681b      	ldr	r3, [r3, #0]
 80a1792:	699b      	ldr	r3, [r3, #24]
 80a1794:	9301      	str	r3, [sp, #4]
 80a1796:	bd08      	pop	{r3, pc}
 80a1798:	080601d8 	.word	0x080601d8

080a179c <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a179c:	b508      	push	{r3, lr}
 80a179e:	4b02      	ldr	r3, [pc, #8]	; (80a17a8 <HAL_USB_USART_Send_Data+0xc>)
 80a17a0:	681b      	ldr	r3, [r3, #0]
 80a17a2:	69db      	ldr	r3, [r3, #28]
 80a17a4:	9301      	str	r3, [sp, #4]
 80a17a6:	bd08      	pop	{r3, pc}
 80a17a8:	080601d8 	.word	0x080601d8

080a17ac <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a17ac:	b508      	push	{r3, lr}
 80a17ae:	4b02      	ldr	r3, [pc, #8]	; (80a17b8 <HAL_USB_USART_Flush_Data+0xc>)
 80a17b0:	681b      	ldr	r3, [r3, #0]
 80a17b2:	6a1b      	ldr	r3, [r3, #32]
 80a17b4:	9301      	str	r3, [sp, #4]
 80a17b6:	bd08      	pop	{r3, pc}
 80a17b8:	080601d8 	.word	0x080601d8

080a17bc <inet_gethostbyname>:
DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, int(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a17bc:	b508      	push	{r3, lr}
 80a17be:	4b02      	ldr	r3, [pc, #8]	; (80a17c8 <inet_gethostbyname+0xc>)
 80a17c0:	681b      	ldr	r3, [r3, #0]
 80a17c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a17c4:	9301      	str	r3, [sp, #4]
 80a17c6:	bd08      	pop	{r3, pc}
 80a17c8:	080601c0 	.word	0x080601c0

080a17cc <softap_set_application_page_handler>:
DYNALIB_FN(20, hal_wlan, wlan_select_antenna, int(WLanSelectAntenna_TypeDef))
DYNALIB_FN(21, hal_wlan, wlan_set_ipaddress, void(const HAL_IPAddress*, const HAL_IPAddress*, const HAL_IPAddress*, const HAL_IPAddress*, const HAL_IPAddress*, void*))
DYNALIB_FN(22, hal_wlan, wlan_set_ipaddress_source, void(IPAddressSource, bool, void*))
DYNALIB_FN(23, hal_wlan, wlan_scan, int(wlan_scan_result_t, void*))
DYNALIB_FN(24, hal_wlan, wlan_get_credentials, int(wlan_scan_result_t, void*))
DYNALIB_FN(25, hal_wlan, softap_set_application_page_handler, int(PageProvider* provider, void* reserved))
 80a17cc:	b508      	push	{r3, lr}
 80a17ce:	4b02      	ldr	r3, [pc, #8]	; (80a17d8 <softap_set_application_page_handler+0xc>)
 80a17d0:	681b      	ldr	r3, [r3, #0]
 80a17d2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a17d4:	9301      	str	r3, [sp, #4]
 80a17d6:	bd08      	pop	{r3, pc}
 80a17d8:	080601c0 	.word	0x080601c0

080a17dc <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a17dc:	b508      	push	{r3, lr}
 80a17de:	4b02      	ldr	r3, [pc, #8]	; (80a17e8 <set_system_mode+0xc>)
 80a17e0:	681b      	ldr	r3, [r3, #0]
 80a17e2:	685b      	ldr	r3, [r3, #4]
 80a17e4:	9301      	str	r3, [sp, #4]
 80a17e6:	bd08      	pop	{r3, pc}
 80a17e8:	080601a4 	.word	0x080601a4

080a17ec <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a17ec:	b508      	push	{r3, lr}
 80a17ee:	4b02      	ldr	r3, [pc, #8]	; (80a17f8 <system_delay_ms+0xc>)
 80a17f0:	681b      	ldr	r3, [r3, #0]
 80a17f2:	695b      	ldr	r3, [r3, #20]
 80a17f4:	9301      	str	r3, [sp, #4]
 80a17f6:	bd08      	pop	{r3, pc}
 80a17f8:	080601a4 	.word	0x080601a4

080a17fc <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a17fc:	b508      	push	{r3, lr}
 80a17fe:	4b03      	ldr	r3, [pc, #12]	; (80a180c <system_ctrl_set_app_request_handler+0x10>)
 80a1800:	681b      	ldr	r3, [r3, #0]
 80a1802:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a1806:	9301      	str	r3, [sp, #4]
 80a1808:	bd08      	pop	{r3, pc}
 80a180a:	0000      	.short	0x0000
 80a180c:	080601a4 	.word	0x080601a4

080a1810 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a1810:	b508      	push	{r3, lr}
 80a1812:	4b03      	ldr	r3, [pc, #12]	; (80a1820 <system_ctrl_set_result+0x10>)
 80a1814:	681b      	ldr	r3, [r3, #0]
 80a1816:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a181a:	9301      	str	r3, [sp, #4]
 80a181c:	bd08      	pop	{r3, pc}
 80a181e:	0000      	.short	0x0000
 80a1820:	080601a4 	.word	0x080601a4

080a1824 <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
 80a1824:	b508      	push	{r3, lr}
 80a1826:	4b02      	ldr	r3, [pc, #8]	; (80a1830 <network_connect+0xc>)
 80a1828:	681b      	ldr	r3, [r3, #0]
 80a182a:	685b      	ldr	r3, [r3, #4]
 80a182c:	9301      	str	r3, [sp, #4]
 80a182e:	bd08      	pop	{r3, pc}
 80a1830:	080601c8 	.word	0x080601c8

080a1834 <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
 80a1834:	b508      	push	{r3, lr}
 80a1836:	4b02      	ldr	r3, [pc, #8]	; (80a1840 <network_connecting+0xc>)
 80a1838:	681b      	ldr	r3, [r3, #0]
 80a183a:	689b      	ldr	r3, [r3, #8]
 80a183c:	9301      	str	r3, [sp, #4]
 80a183e:	bd08      	pop	{r3, pc}
 80a1840:	080601c8 	.word	0x080601c8

080a1844 <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
 80a1844:	b508      	push	{r3, lr}
 80a1846:	4b02      	ldr	r3, [pc, #8]	; (80a1850 <network_disconnect+0xc>)
 80a1848:	681b      	ldr	r3, [r3, #0]
 80a184a:	68db      	ldr	r3, [r3, #12]
 80a184c:	9301      	str	r3, [sp, #4]
 80a184e:	bd08      	pop	{r3, pc}
 80a1850:	080601c8 	.word	0x080601c8

080a1854 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a1854:	b508      	push	{r3, lr}
 80a1856:	4b02      	ldr	r3, [pc, #8]	; (80a1860 <network_ready+0xc>)
 80a1858:	681b      	ldr	r3, [r3, #0]
 80a185a:	691b      	ldr	r3, [r3, #16]
 80a185c:	9301      	str	r3, [sp, #4]
 80a185e:	bd08      	pop	{r3, pc}
 80a1860:	080601c8 	.word	0x080601c8

080a1864 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
 80a1864:	b508      	push	{r3, lr}
 80a1866:	4b02      	ldr	r3, [pc, #8]	; (80a1870 <network_on+0xc>)
 80a1868:	681b      	ldr	r3, [r3, #0]
 80a186a:	695b      	ldr	r3, [r3, #20]
 80a186c:	9301      	str	r3, [sp, #4]
 80a186e:	bd08      	pop	{r3, pc}
 80a1870:	080601c8 	.word	0x080601c8

080a1874 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
 80a1874:	b508      	push	{r3, lr}
 80a1876:	4b02      	ldr	r3, [pc, #8]	; (80a1880 <network_off+0xc>)
 80a1878:	681b      	ldr	r3, [r3, #0]
 80a187a:	699b      	ldr	r3, [r3, #24]
 80a187c:	9301      	str	r3, [sp, #4]
 80a187e:	bd08      	pop	{r3, pc}
 80a1880:	080601c8 	.word	0x080601c8

080a1884 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
 80a1884:	b508      	push	{r3, lr}
 80a1886:	4b02      	ldr	r3, [pc, #8]	; (80a1890 <network_listen+0xc>)
 80a1888:	681b      	ldr	r3, [r3, #0]
 80a188a:	69db      	ldr	r3, [r3, #28]
 80a188c:	9301      	str	r3, [sp, #4]
 80a188e:	bd08      	pop	{r3, pc}
 80a1890:	080601c8 	.word	0x080601c8

080a1894 <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
 80a1894:	b508      	push	{r3, lr}
 80a1896:	4b02      	ldr	r3, [pc, #8]	; (80a18a0 <network_listening+0xc>)
 80a1898:	681b      	ldr	r3, [r3, #0]
 80a189a:	6a1b      	ldr	r3, [r3, #32]
 80a189c:	9301      	str	r3, [sp, #4]
 80a189e:	bd08      	pop	{r3, pc}
 80a18a0:	080601c8 	.word	0x080601c8

080a18a4 <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
 80a18a4:	b508      	push	{r3, lr}
 80a18a6:	4b02      	ldr	r3, [pc, #8]	; (80a18b0 <network_set_listen_timeout+0xc>)
 80a18a8:	681b      	ldr	r3, [r3, #0]
 80a18aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a18ac:	9301      	str	r3, [sp, #4]
 80a18ae:	bd08      	pop	{r3, pc}
 80a18b0:	080601c8 	.word	0x080601c8

080a18b4 <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
 80a18b4:	b508      	push	{r3, lr}
 80a18b6:	4b02      	ldr	r3, [pc, #8]	; (80a18c0 <network_get_listen_timeout+0xc>)
 80a18b8:	681b      	ldr	r3, [r3, #0]
 80a18ba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a18bc:	9301      	str	r3, [sp, #4]
 80a18be:	bd08      	pop	{r3, pc}
 80a18c0:	080601c8 	.word	0x080601c8

080a18c4 <spark_function>:


DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
 80a18c4:	b508      	push	{r3, lr}
 80a18c6:	4b02      	ldr	r3, [pc, #8]	; (80a18d0 <spark_function+0xc>)
 80a18c8:	681b      	ldr	r3, [r3, #0]
 80a18ca:	685b      	ldr	r3, [r3, #4]
 80a18cc:	9301      	str	r3, [sp, #4]
 80a18ce:	bd08      	pop	{r3, pc}
 80a18d0:	080601cc 	.word	0x080601cc

080a18d4 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a18d4:	b508      	push	{r3, lr}
 80a18d6:	4b02      	ldr	r3, [pc, #8]	; (80a18e0 <spark_set_random_seed_from_cloud_handler+0xc>)
 80a18d8:	681b      	ldr	r3, [r3, #0]
 80a18da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a18dc:	9301      	str	r3, [sp, #4]
 80a18de:	bd08      	pop	{r3, pc}
 80a18e0:	080601cc 	.word	0x080601cc

080a18e4 <malloc>:
#include <assert.h>
#endif

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a18e4:	b508      	push	{r3, lr}
 80a18e6:	4b02      	ldr	r3, [pc, #8]	; (80a18f0 <malloc+0xc>)
 80a18e8:	681b      	ldr	r3, [r3, #0]
 80a18ea:	681b      	ldr	r3, [r3, #0]
 80a18ec:	9301      	str	r3, [sp, #4]
 80a18ee:	bd08      	pop	{r3, pc}
 80a18f0:	080601a0 	.word	0x080601a0

080a18f4 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a18f4:	b508      	push	{r3, lr}
 80a18f6:	4b02      	ldr	r3, [pc, #8]	; (80a1900 <free+0xc>)
 80a18f8:	681b      	ldr	r3, [r3, #0]
 80a18fa:	685b      	ldr	r3, [r3, #4]
 80a18fc:	9301      	str	r3, [sp, #4]
 80a18fe:	bd08      	pop	{r3, pc}
 80a1900:	080601a0 	.word	0x080601a0

080a1904 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a1904:	b508      	push	{r3, lr}
 80a1906:	4b02      	ldr	r3, [pc, #8]	; (80a1910 <realloc+0xc>)
 80a1908:	681b      	ldr	r3, [r3, #0]
 80a190a:	689b      	ldr	r3, [r3, #8]
 80a190c:	9301      	str	r3, [sp, #4]
 80a190e:	bd08      	pop	{r3, pc}
 80a1910:	080601a0 	.word	0x080601a0

080a1914 <vsnprintf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a1914:	b508      	push	{r3, lr}
 80a1916:	4b02      	ldr	r3, [pc, #8]	; (80a1920 <vsnprintf+0xc>)
 80a1918:	681b      	ldr	r3, [r3, #0]
 80a191a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a191c:	9301      	str	r3, [sp, #4]
 80a191e:	bd08      	pop	{r3, pc}
 80a1920:	080601a0 	.word	0x080601a0

080a1924 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
    }
    return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}
} // namespace

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a1924:	b570      	push	{r4, r5, r6, lr}
 80a1926:	4604      	mov	r4, r0
 80a1928:	460e      	mov	r6, r1
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
 80a192a:	2500      	movs	r5, #0
 80a192c:	f840 5f08 	str.w	r5, [r0, #8]!
    {
        os_mutex_recursive_create(&handle_);
 80a1930:	f7ff fe8a 	bl	80a1648 <os_mutex_recursive_create>
{
    _spi = spi;
    HAL_SPI_Init(_spi);
 80a1934:	4630      	mov	r0, r6
}
} // namespace

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
    _spi = spi;
 80a1936:	7026      	strb	r6, [r4, #0]
    HAL_SPI_Init(_spi);
 80a1938:	f7ff fe5e 	bl	80a15f8 <HAL_SPI_Init>
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
 80a193c:	6065      	str	r5, [r4, #4]
}
 80a193e:	4620      	mov	r0, r4
 80a1940:	bd70      	pop	{r4, r5, r6, pc}

080a1942 <_ZN8SPIClass9isEnabledEv>:
bool SPIClass::isEnabled()
{
    // XXX: pinAvailable() will call this method potentially even from
    // interrupt context. `enabled` flag in HAL is usually just a volatile
    // variable, so it's fine not to acquire the lock here.
    return HAL_SPI_Is_Enabled(_spi);
 80a1942:	7800      	ldrb	r0, [r0, #0]
 80a1944:	f7ff be60 	b.w	80a1608 <HAL_SPI_Is_Enabled>

080a1948 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>:
    operator SleepResult() {
        return toSleepResult();
    }

private:
    void freeWakeupSourceMemory() {
 80a1948:	b510      	push	{r4, lr}
 80a194a:	4604      	mov	r4, r0
        if (wakeupSource_) {
 80a194c:	6800      	ldr	r0, [r0, #0]
 80a194e:	b118      	cbz	r0, 80a1958 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2+0x10>
            free(wakeupSource_);
 80a1950:	f7ff ffd0 	bl	80a18f4 <free>
            wakeupSource_ = nullptr;
 80a1954:	2300      	movs	r3, #0
 80a1956:	6023      	str	r3, [r4, #0]
 80a1958:	bd10      	pop	{r4, pc}

080a195a <_ZN11SystemClassD1Ev>:
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
 80a195a:	b510      	push	{r4, lr}
 80a195c:	4604      	mov	r4, r0
        }
        return *this;
    }

    ~SystemSleepResult() {
        freeWakeupSourceMemory();
 80a195e:	f7ff fff3 	bl	80a1948 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
 80a1962:	4620      	mov	r0, r4
 80a1964:	bd10      	pop	{r4, pc}
	...

080a1968 <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
 80a1968:	f64f 73ff 	movw	r3, #65535	; 0xffff
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
 80a196c:	b510      	push	{r4, lr}

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
 80a196e:	4c08      	ldr	r4, [pc, #32]	; (80a1990 <_GLOBAL__sub_I_System+0x28>)
 80a1970:	2000      	movs	r0, #0
 80a1972:	6020      	str	r0, [r4, #0]
 80a1974:	80a0      	strh	r0, [r4, #4]
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
 80a1976:	71a0      	strb	r0, [r4, #6]
 80a1978:	8120      	strh	r0, [r4, #8]
 80a197a:	8163      	strh	r3, [r4, #10]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a197c:	f7ff ff2e 	bl	80a17dc <set_system_mode>

#if Wiring_LogConfig
extern void(*log_process_ctrl_request_callback)(ctrl_request* req);
#endif

SystemClass System;
 80a1980:	4620      	mov	r0, r4
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
 80a1982:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

#if Wiring_LogConfig
extern void(*log_process_ctrl_request_callback)(ctrl_request* req);
#endif

SystemClass System;
 80a1986:	4a03      	ldr	r2, [pc, #12]	; (80a1994 <_GLOBAL__sub_I_System+0x2c>)
 80a1988:	4903      	ldr	r1, [pc, #12]	; (80a1998 <_GLOBAL__sub_I_System+0x30>)
 80a198a:	f000 bdb9 	b.w	80a2500 <__aeabi_atexit>
 80a198e:	bf00      	nop
 80a1990:	200000f4 	.word	0x200000f4
 80a1994:	200000d8 	.word	0x200000d8
 80a1998:	080a195b 	.word	0x080a195b

080a199c <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a199c:	b510      	push	{r4, lr}
 80a199e:	4604      	mov	r4, r0
{
	free(buffer);
 80a19a0:	6800      	ldr	r0, [r0, #0]
 80a19a2:	f7ff ffa7 	bl	80a18f4 <free>
}
 80a19a6:	4620      	mov	r0, r4
 80a19a8:	bd10      	pop	{r4, pc}

080a19aa <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a19aa:	b510      	push	{r4, lr}
 80a19ac:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a19ae:	6800      	ldr	r0, [r0, #0]
 80a19b0:	b108      	cbz	r0, 80a19b6 <_ZN6String10invalidateEv+0xc>
 80a19b2:	f7ff ff9f 	bl	80a18f4 <free>
	buffer = NULL;
 80a19b6:	2300      	movs	r3, #0
 80a19b8:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a19ba:	60a3      	str	r3, [r4, #8]
 80a19bc:	6063      	str	r3, [r4, #4]
 80a19be:	bd10      	pop	{r4, pc}

080a19c0 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a19c0:	b538      	push	{r3, r4, r5, lr}
 80a19c2:	4604      	mov	r4, r0
 80a19c4:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a19c6:	6800      	ldr	r0, [r0, #0]
 80a19c8:	3101      	adds	r1, #1
 80a19ca:	f7ff ff9b 	bl	80a1904 <realloc>
	if (newbuffer) {
 80a19ce:	b110      	cbz	r0, 80a19d6 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a19d0:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a19d4:	2001      	movs	r0, #1
	}
	return 0;
}
 80a19d6:	bd38      	pop	{r3, r4, r5, pc}

080a19d8 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a19d8:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a19da:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a19dc:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a19de:	b113      	cbz	r3, 80a19e6 <_ZN6String7reserveEj+0xe>
 80a19e0:	6843      	ldr	r3, [r0, #4]
 80a19e2:	428b      	cmp	r3, r1
 80a19e4:	d207      	bcs.n	80a19f6 <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a19e6:	4620      	mov	r0, r4
 80a19e8:	f7ff ffea 	bl	80a19c0 <_ZN6String12changeBufferEj>
 80a19ec:	b120      	cbz	r0, 80a19f8 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a19ee:	68a3      	ldr	r3, [r4, #8]
 80a19f0:	b90b      	cbnz	r3, 80a19f6 <_ZN6String7reserveEj+0x1e>
 80a19f2:	6822      	ldr	r2, [r4, #0]
 80a19f4:	7013      	strb	r3, [r2, #0]
 80a19f6:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a19f8:	bd10      	pop	{r4, pc}

080a19fa <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a19fa:	b570      	push	{r4, r5, r6, lr}
 80a19fc:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a19fe:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a1a00:	4604      	mov	r4, r0
 80a1a02:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a1a04:	f7ff ffe8 	bl	80a19d8 <_ZN6String7reserveEj>
 80a1a08:	b918      	cbnz	r0, 80a1a12 <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a1a0a:	4620      	mov	r0, r4
 80a1a0c:	f7ff ffcd 	bl	80a19aa <_ZN6String10invalidateEv>
		return *this;
 80a1a10:	e009      	b.n	80a1a26 <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a1a12:	462a      	mov	r2, r5
 80a1a14:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a1a16:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a1a18:	6820      	ldr	r0, [r4, #0]
 80a1a1a:	f000 fee9 	bl	80a27f0 <memcpy>
	buffer[len] = 0;
 80a1a1e:	6822      	ldr	r2, [r4, #0]
 80a1a20:	68a3      	ldr	r3, [r4, #8]
 80a1a22:	2100      	movs	r1, #0
 80a1a24:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a1a26:	4620      	mov	r0, r4
 80a1a28:	bd70      	pop	{r4, r5, r6, pc}

080a1a2a <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a1a2a:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a1a2c:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a1a2e:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a1a30:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a1a32:	6043      	str	r3, [r0, #4]
	len = 0;
 80a1a34:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a1a36:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
 80a1a38:	460d      	mov	r5, r1
 80a1a3a:	b139      	cbz	r1, 80a1a4c <_ZN6StringC1EPK19__FlashStringHelper+0x22>
 80a1a3c:	4608      	mov	r0, r1
 80a1a3e:	f000 ff57 	bl	80a28f0 <strlen>
 80a1a42:	4629      	mov	r1, r5
 80a1a44:	4602      	mov	r2, r0
 80a1a46:	4620      	mov	r0, r4
 80a1a48:	f7ff ffd7 	bl	80a19fa <_ZN6String4copyEPKcj>
}
 80a1a4c:	4620      	mov	r0, r4
 80a1a4e:	bd38      	pop	{r3, r4, r5, pc}

080a1a50 <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a1a50:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
 80a1a52:	b510      	push	{r4, lr}
 80a1a54:	460b      	mov	r3, r1
 80a1a56:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a1a58:	d007      	beq.n	80a1a6a <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a1a5a:	6809      	ldr	r1, [r1, #0]
 80a1a5c:	b119      	cbz	r1, 80a1a66 <_ZN6StringaSERKS_+0x16>
 80a1a5e:	689a      	ldr	r2, [r3, #8]
 80a1a60:	f7ff ffcb 	bl	80a19fa <_ZN6String4copyEPKcj>
 80a1a64:	e001      	b.n	80a1a6a <_ZN6StringaSERKS_+0x1a>
	else invalidate();
 80a1a66:	f7ff ffa0 	bl	80a19aa <_ZN6String10invalidateEv>

	return *this;
}
 80a1a6a:	4620      	mov	r0, r4
 80a1a6c:	bd10      	pop	{r4, pc}

080a1a6e <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
 80a1a6e:	b510      	push	{r4, lr}
 80a1a70:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a1a72:	2300      	movs	r3, #0
 80a1a74:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a1a76:	6043      	str	r3, [r0, #4]
	len = 0;
 80a1a78:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a1a7a:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
 80a1a7c:	f7ff ffe8 	bl	80a1a50 <_ZN6StringaSERKS_>
}
 80a1a80:	4620      	mov	r0, r4
 80a1a82:	bd10      	pop	{r4, pc}

080a1a84 <_ZNK6String6equalsEPKc>:
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a1a84:	b508      	push	{r3, lr}
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a1a86:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a1a88:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a1a8a:	b912      	cbnz	r2, 80a1a92 <_ZNK6String6equalsEPKc+0xe>
 80a1a8c:	b919      	cbnz	r1, 80a1a96 <_ZNK6String6equalsEPKc+0x12>
 80a1a8e:	2001      	movs	r0, #1
 80a1a90:	bd08      	pop	{r3, pc}
	if (cstr == NULL) return buffer[0] == 0;
 80a1a92:	b911      	cbnz	r1, 80a1a9a <_ZNK6String6equalsEPKc+0x16>
 80a1a94:	6803      	ldr	r3, [r0, #0]
 80a1a96:	7818      	ldrb	r0, [r3, #0]
 80a1a98:	e002      	b.n	80a1aa0 <_ZNK6String6equalsEPKc+0x1c>
	return strcmp(buffer, cstr) == 0;
 80a1a9a:	6800      	ldr	r0, [r0, #0]
 80a1a9c:	f000 ff1e 	bl	80a28dc <strcmp>
 80a1aa0:	fab0 f080 	clz	r0, r0
 80a1aa4:	0940      	lsrs	r0, r0, #5
}
 80a1aa6:	bd08      	pop	{r3, pc}

080a1aa8 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a1aa8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1aaa:	4606      	mov	r6, r0
 80a1aac:	460d      	mov	r5, r1
 80a1aae:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a1ab0:	2400      	movs	r4, #0
  while (size--) {
 80a1ab2:	42bd      	cmp	r5, r7
 80a1ab4:	d00c      	beq.n	80a1ad0 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a1ab6:	6833      	ldr	r3, [r6, #0]
 80a1ab8:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a1abc:	689b      	ldr	r3, [r3, #8]
 80a1abe:	4630      	mov	r0, r6
 80a1ac0:	4798      	blx	r3
     if (chunk>=0)
 80a1ac2:	2800      	cmp	r0, #0
 80a1ac4:	db01      	blt.n	80a1aca <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a1ac6:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a1ac8:	e7f3      	b.n	80a1ab2 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a1aca:	2c00      	cmp	r4, #0
 80a1acc:	bf08      	it	eq
 80a1ace:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a1ad0:	4620      	mov	r0, r4
 80a1ad2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1ad4 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a1ad4:	b570      	push	{r4, r5, r6, lr}
 80a1ad6:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a1ad8:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a1ada:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a1adc:	b149      	cbz	r1, 80a1af2 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a1ade:	f000 ff07 	bl	80a28f0 <strlen>
 80a1ae2:	682b      	ldr	r3, [r5, #0]
 80a1ae4:	4602      	mov	r2, r0
 80a1ae6:	4621      	mov	r1, r4
 80a1ae8:	4628      	mov	r0, r5
    }
 80a1aea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a1aee:	68db      	ldr	r3, [r3, #12]
 80a1af0:	4718      	bx	r3
    }
 80a1af2:	bd70      	pop	{r4, r5, r6, pc}

080a1af4 <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a1af4:	6803      	ldr	r3, [r0, #0]
 80a1af6:	689b      	ldr	r3, [r3, #8]
 80a1af8:	4718      	bx	r3

080a1afa <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a1afa:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a1afc:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a1afe:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a1b00:	f7ff fff8 	bl	80a1af4 <_ZN5Print5printEc>
  n += print('\n');
 80a1b04:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a1b06:	4604      	mov	r4, r0
  n += print('\n');
 80a1b08:	4628      	mov	r0, r5
 80a1b0a:	f7ff fff3 	bl	80a1af4 <_ZN5Print5printEc>
  return n;
}
 80a1b0e:	4420      	add	r0, r4
 80a1b10:	bd38      	pop	{r3, r4, r5, pc}

080a1b12 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a1b12:	b538      	push	{r3, r4, r5, lr}
 80a1b14:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a1b16:	f7ff ffdd 	bl	80a1ad4 <_ZN5Print5writeEPKc>
 80a1b1a:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a1b1c:	4628      	mov	r0, r5
 80a1b1e:	f7ff ffec 	bl	80a1afa <_ZN5Print7printlnEv>
  return n;
}
 80a1b22:	4420      	add	r0, r4
 80a1b24:	bd38      	pop	{r3, r4, r5, pc}

080a1b26 <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a1b26:	2a01      	cmp	r2, #1
 80a1b28:	bf98      	it	ls
 80a1b2a:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a1b2c:	b530      	push	{r4, r5, lr}
 80a1b2e:	460b      	mov	r3, r1
 80a1b30:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a1b32:	2100      	movs	r1, #0
 80a1b34:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a1b38:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
   decltype(n) m = n;
   n /= base;
 80a1b3c:	fbb3 f5f2 	udiv	r5, r3, r2
   char c = m - base * n;
 80a1b40:	fb05 3312 	mls	r3, r5, r2, r3
 80a1b44:	b2db      	uxtb	r3, r3
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a1b46:	2b09      	cmp	r3, #9
 80a1b48:	bf94      	ite	ls
 80a1b4a:	3330      	addls	r3, #48	; 0x30
 80a1b4c:	3337      	addhi	r3, #55	; 0x37
 80a1b4e:	b2db      	uxtb	r3, r3
 80a1b50:	4621      	mov	r1, r4
 80a1b52:	f804 3901 	strb.w	r3, [r4], #-1
 80a1b56:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a1b58:	2d00      	cmp	r5, #0
 80a1b5a:	d1ef      	bne.n	80a1b3c <_ZN5Print11printNumberEmh+0x16>
   n /= base;
   char c = m - base * n;
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a1b5c:	f7ff ffba 	bl	80a1ad4 <_ZN5Print5writeEPKc>
}
 80a1b60:	b00b      	add	sp, #44	; 0x2c
 80a1b62:	bd30      	pop	{r4, r5, pc}

080a1b64 <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
 80a1b64:	b40c      	push	{r2, r3}
 80a1b66:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a1b6a:	b087      	sub	sp, #28
 80a1b6c:	af00      	add	r7, sp, #0
 80a1b6e:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80a1b72:	f854 9b04 	ldr.w	r9, [r4], #4
 80a1b76:	4605      	mov	r5, r0
 80a1b78:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a1b7a:	4623      	mov	r3, r4
 80a1b7c:	464a      	mov	r2, r9
 80a1b7e:	2114      	movs	r1, #20
 80a1b80:	1d38      	adds	r0, r7, #4
size_t Print::printf_impl(bool newline, const char* format, ...)
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
 80a1b82:	603c      	str	r4, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a1b84:	f7ff fec6 	bl	80a1914 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
 80a1b88:	2813      	cmp	r0, #19
 80a1b8a:	d805      	bhi.n	80a1b98 <_ZN5Print11printf_implEbPKcz+0x34>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a1b8c:	1d39      	adds	r1, r7, #4
 80a1b8e:	4628      	mov	r0, r5
 80a1b90:	f7ff ffa0 	bl	80a1ad4 <_ZN5Print5writeEPKc>
 80a1b94:	4604      	mov	r4, r0
 80a1b96:	e013      	b.n	80a1bc0 <_ZN5Print11printf_implEbPKcz+0x5c>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a1b98:	f100 0308 	add.w	r3, r0, #8
 80a1b9c:	f023 0307 	bic.w	r3, r3, #7
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
 80a1ba0:	46e8      	mov	r8, sp
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a1ba2:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
 80a1ba6:	1c41      	adds	r1, r0, #1
 80a1ba8:	4623      	mov	r3, r4
 80a1baa:	464a      	mov	r2, r9
 80a1bac:	4668      	mov	r0, sp
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
 80a1bae:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
 80a1bb0:	f7ff feb0 	bl	80a1914 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a1bb4:	4669      	mov	r1, sp
 80a1bb6:	4628      	mov	r0, r5
 80a1bb8:	f7ff ff8c 	bl	80a1ad4 <_ZN5Print5writeEPKc>
 80a1bbc:	4604      	mov	r4, r0
 80a1bbe:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
 80a1bc0:	b11e      	cbz	r6, 80a1bca <_ZN5Print11printf_implEbPKcz+0x66>
        n += println();
 80a1bc2:	4628      	mov	r0, r5
 80a1bc4:	f7ff ff99 	bl	80a1afa <_ZN5Print7printlnEv>
 80a1bc8:	4404      	add	r4, r0
    return n;
}
 80a1bca:	4620      	mov	r0, r4
 80a1bcc:	371c      	adds	r7, #28
 80a1bce:	46bd      	mov	sp, r7
 80a1bd0:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a1bd4:	b002      	add	sp, #8
 80a1bd6:	4770      	bx	lr

080a1bd8 <_ZN5spark9WiFiClass2onEv>:
    bool ready(void) {
        return network_ready(*this, 0, NULL);
    }

    void on(void) {
        network_on(*this, 0, 0, NULL);
 80a1bd8:	2300      	movs	r3, #0
 80a1bda:	461a      	mov	r2, r3
 80a1bdc:	4619      	mov	r1, r3
 80a1bde:	6840      	ldr	r0, [r0, #4]
 80a1be0:	f7ff be40 	b.w	80a1864 <network_on>

080a1be4 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a1be4:	4a01      	ldr	r2, [pc, #4]	; (80a1bec <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a1be6:	4b02      	ldr	r3, [pc, #8]	; (80a1bf0 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a1be8:	601a      	str	r2, [r3, #0]
 80a1bea:	4770      	bx	lr
 80a1bec:	080a7d9e 	.word	0x080a7d9e
 80a1bf0:	20000100 	.word	0x20000100

080a1bf4 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a1bf4:	4b02      	ldr	r3, [pc, #8]	; (80a1c00 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a1bf6:	681a      	ldr	r2, [r3, #0]
 80a1bf8:	4b02      	ldr	r3, [pc, #8]	; (80a1c04 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a1bfa:	601a      	str	r2, [r3, #0]
 80a1bfc:	4770      	bx	lr
 80a1bfe:	bf00      	nop
 80a1c00:	20000070 	.word	0x20000070
 80a1c04:	20000104 	.word	0x20000104

080a1c08 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a1c08:	2100      	movs	r1, #0
 80a1c0a:	f7ff bdef 	b.w	80a17ec <system_delay_ms>

080a1c0e <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a1c0e:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a1c10:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a1c12:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a1c14:	b113      	cbz	r3, 80a1c1c <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a1c16:	2203      	movs	r2, #3
 80a1c18:	4601      	mov	r1, r0
 80a1c1a:	4798      	blx	r3
    }
 80a1c1c:	4620      	mov	r0, r4
 80a1c1e:	bd10      	pop	{r4, pc}

080a1c20 <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a1c20:	b510      	push	{r4, lr}
 80a1c22:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a1c24:	f7ff fff3 	bl	80a1c0e <_ZNSt14_Function_baseD1Ev>
 80a1c28:	4620      	mov	r0, r4
 80a1c2a:	bd10      	pop	{r4, pc}

080a1c2c <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a1c2c:	4803      	ldr	r0, [pc, #12]	; (80a1c3c <_GLOBAL__sub_I_RGB+0x10>)
 80a1c2e:	2300      	movs	r3, #0
 80a1c30:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a1c32:	4a03      	ldr	r2, [pc, #12]	; (80a1c40 <_GLOBAL__sub_I_RGB+0x14>)
 80a1c34:	4903      	ldr	r1, [pc, #12]	; (80a1c44 <_GLOBAL__sub_I_RGB+0x18>)
 80a1c36:	f000 bc63 	b.w	80a2500 <__aeabi_atexit>
 80a1c3a:	bf00      	nop
 80a1c3c:	20000108 	.word	0x20000108
 80a1c40:	200000d8 	.word	0x200000d8
 80a1c44:	080a1c21 	.word	0x080a1c21

080a1c48 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a1c48:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a1c4a:	4b14      	ldr	r3, [pc, #80]	; (80a1c9c <serialEventRun+0x54>)
 80a1c4c:	b133      	cbz	r3, 80a1c5c <serialEventRun+0x14>
 80a1c4e:	f000 f993 	bl	80a1f78 <_Z16_fetch_usbserialv>
 80a1c52:	6803      	ldr	r3, [r0, #0]
 80a1c54:	691b      	ldr	r3, [r3, #16]
 80a1c56:	4798      	blx	r3
 80a1c58:	2800      	cmp	r0, #0
 80a1c5a:	dc16      	bgt.n	80a1c8a <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a1c5c:	4b10      	ldr	r3, [pc, #64]	; (80a1ca0 <serialEventRun+0x58>)
 80a1c5e:	b133      	cbz	r3, 80a1c6e <serialEventRun+0x26>
 80a1c60:	f000 fa48 	bl	80a20f4 <_Z22__fetch_global_Serial1v>
 80a1c64:	6803      	ldr	r3, [r0, #0]
 80a1c66:	691b      	ldr	r3, [r3, #16]
 80a1c68:	4798      	blx	r3
 80a1c6a:	2800      	cmp	r0, #0
 80a1c6c:	dc10      	bgt.n	80a1c90 <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a1c6e:	4b0d      	ldr	r3, [pc, #52]	; (80a1ca4 <serialEventRun+0x5c>)
 80a1c70:	b10b      	cbz	r3, 80a1c76 <serialEventRun+0x2e>
 80a1c72:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a1c76:	4b0c      	ldr	r3, [pc, #48]	; (80a1ca8 <serialEventRun+0x60>)
 80a1c78:	b17b      	cbz	r3, 80a1c9a <serialEventRun+0x52>
 80a1c7a:	f000 f9b9 	bl	80a1ff0 <_Z17_fetch_usbserial1v>
 80a1c7e:	6803      	ldr	r3, [r0, #0]
 80a1c80:	691b      	ldr	r3, [r3, #16]
 80a1c82:	4798      	blx	r3
 80a1c84:	2800      	cmp	r0, #0
 80a1c86:	dc06      	bgt.n	80a1c96 <serialEventRun+0x4e>
 80a1c88:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a1c8a:	f3af 8000 	nop.w
 80a1c8e:	e7e5      	b.n	80a1c5c <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a1c90:	f3af 8000 	nop.w
 80a1c94:	e7eb      	b.n	80a1c6e <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a1c96:	f3af 8000 	nop.w
 80a1c9a:	bd08      	pop	{r3, pc}
	...

080a1cac <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a1cac:	b508      	push	{r3, lr}
	serialEventRun();
 80a1cae:	f7ff ffcb 	bl	80a1c48 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a1cb2:	f7ff fcc1 	bl	80a1638 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a1cb6:	4b01      	ldr	r3, [pc, #4]	; (80a1cbc <_post_loop+0x10>)
 80a1cb8:	6018      	str	r0, [r3, #0]
 80a1cba:	bd08      	pop	{r3, pc}
 80a1cbc:	2000059c 	.word	0x2000059c

080a1cc0 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a1cc0:	4802      	ldr	r0, [pc, #8]	; (80a1ccc <_Z33system_initialize_user_backup_ramv+0xc>)
 80a1cc2:	4a03      	ldr	r2, [pc, #12]	; (80a1cd0 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a1cc4:	4903      	ldr	r1, [pc, #12]	; (80a1cd4 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a1cc6:	1a12      	subs	r2, r2, r0
 80a1cc8:	f000 bd92 	b.w	80a27f0 <memcpy>
 80a1ccc:	40024000 	.word	0x40024000
 80a1cd0:	40024004 	.word	0x40024004
 80a1cd4:	080a7fe0 	.word	0x080a7fe0

080a1cd8 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a1cd8:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a1cda:	2300      	movs	r3, #0
 80a1cdc:	9300      	str	r3, [sp, #0]
 80a1cde:	461a      	mov	r2, r3
 80a1ce0:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a1ce4:	f7ff fd94 	bl	80a1810 <system_ctrl_set_result>
}
 80a1ce8:	b003      	add	sp, #12
 80a1cea:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a1cf0 <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a1cf0:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a1cf2:	8843      	ldrh	r3, [r0, #2]
 80a1cf4:	2b0a      	cmp	r3, #10
 80a1cf6:	d008      	beq.n	80a1d0a <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a1cf8:	2b50      	cmp	r3, #80	; 0x50
 80a1cfa:	d109      	bne.n	80a1d10 <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a1cfc:	4b09      	ldr	r3, [pc, #36]	; (80a1d24 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a1cfe:	681b      	ldr	r3, [r3, #0]
 80a1d00:	b13b      	cbz	r3, 80a1d12 <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a1d02:	b003      	add	sp, #12
 80a1d04:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a1d08:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a1d0a:	f7ff ffe5 	bl	80a1cd8 <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a1d0e:	e006      	b.n	80a1d1e <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a1d10:	2300      	movs	r3, #0
 80a1d12:	9300      	str	r3, [sp, #0]
 80a1d14:	461a      	mov	r2, r3
 80a1d16:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a1d1a:	f7ff fd79 	bl	80a1810 <system_ctrl_set_result>
        break;
    }
}
 80a1d1e:	b003      	add	sp, #12
 80a1d20:	f85d fb04 	ldr.w	pc, [sp], #4
 80a1d24:	20000118 	.word	0x20000118

080a1d28 <module_user_init_hook>:

void module_user_init_hook()
{
 80a1d28:	b538      	push	{r3, r4, r5, lr}
#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a1d2a:	4c10      	ldr	r4, [pc, #64]	; (80a1d6c <module_user_init_hook+0x44>)
 80a1d2c:	4d10      	ldr	r5, [pc, #64]	; (80a1d70 <module_user_init_hook+0x48>)
 80a1d2e:	6823      	ldr	r3, [r4, #0]
 80a1d30:	42ab      	cmp	r3, r5
 80a1d32:	4b10      	ldr	r3, [pc, #64]	; (80a1d74 <module_user_init_hook+0x4c>)
 80a1d34:	bf0c      	ite	eq
 80a1d36:	2201      	moveq	r2, #1
 80a1d38:	2200      	movne	r2, #0
 80a1d3a:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a1d3c:	d002      	beq.n	80a1d44 <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a1d3e:	f7ff ffbf 	bl	80a1cc0 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a1d42:	6025      	str	r5, [r4, #0]
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
 80a1d44:	f7ff fc68 	bl	80a1618 <HAL_RNG_GetRandomNumber>
 80a1d48:	4604      	mov	r4, r0
    srand(seed);
 80a1d4a:	f000 fd65 	bl	80a2818 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a1d4e:	4b0a      	ldr	r3, [pc, #40]	; (80a1d78 <module_user_init_hook+0x50>)
 80a1d50:	b113      	cbz	r3, 80a1d58 <module_user_init_hook+0x30>
        random_seed_from_cloud(seed);
 80a1d52:	4620      	mov	r0, r4
 80a1d54:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a1d58:	2100      	movs	r1, #0
 80a1d5a:	4807      	ldr	r0, [pc, #28]	; (80a1d78 <module_user_init_hook+0x50>)
 80a1d5c:	f7ff fdba 	bl	80a18d4 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a1d60:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a1d64:	2100      	movs	r1, #0
 80a1d66:	4805      	ldr	r0, [pc, #20]	; (80a1d7c <module_user_init_hook+0x54>)
 80a1d68:	f7ff bd48 	b.w	80a17fc <system_ctrl_set_app_request_handler>
 80a1d6c:	40024000 	.word	0x40024000
 80a1d70:	9a271c1e 	.word	0x9a271c1e
 80a1d74:	2000011c 	.word	0x2000011c
 80a1d78:	00000000 	.word	0x00000000
 80a1d7c:	080a1cf1 	.word	0x080a1cf1

080a1d80 <_ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
}

} // namespace

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
 80a1d80:	b510      	push	{r4, lr}
 80a1d82:	b088      	sub	sp, #32
 80a1d84:	4604      	mov	r4, r0
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
 80a1d86:	4668      	mov	r0, sp
 80a1d88:	f7ff fe4f 	bl	80a1a2a <_ZN6StringC1EPK19__FlashStringHelper>
    return (*fn)(p);
 80a1d8c:	4669      	mov	r1, sp
 80a1d8e:	a804      	add	r0, sp, #16
 80a1d90:	f7ff fe6d 	bl	80a1a6e <_ZN6StringC1ERKS_>
 80a1d94:	a804      	add	r0, sp, #16
 80a1d96:	47a0      	blx	r4
 80a1d98:	4604      	mov	r4, r0
 80a1d9a:	a804      	add	r0, sp, #16
 80a1d9c:	f7ff fdfe 	bl	80a199c <_ZN6StringD1Ev>
} // namespace

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
 80a1da0:	4668      	mov	r0, sp
 80a1da2:	f7ff fdfb 	bl	80a199c <_ZN6StringD1Ev>
    return (*fn)(p);
}
 80a1da6:	4620      	mov	r0, r4
 80a1da8:	b008      	add	sp, #32
 80a1daa:	bd10      	pop	{r4, pc}

080a1dac <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
 80a1dac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a1dae:	4607      	mov	r7, r0
 80a1db0:	460e      	mov	r6, r1
 80a1db2:	4615      	mov	r5, r2
 80a1db4:	b085      	sub	sp, #20
    const char *funcKey;
    cloud_function_t fn;
    void* data;

     cloud_function_descriptor() {
         memset(this, 0, sizeof(*this));
 80a1db6:	2410      	movs	r4, #16
 80a1db8:	4622      	mov	r2, r4
 80a1dba:	2100      	movs	r1, #0
 80a1dbc:	4668      	mov	r0, sp
 80a1dbe:	f000 fd22 	bl	80a2806 <memset>
    cloud_function_descriptor desc = {};
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a1dc2:	2200      	movs	r2, #0
 80a1dc4:	4669      	mov	r1, sp
 80a1dc6:	4610      	mov	r0, r2
         size = sizeof(*this);
 80a1dc8:	f8ad 4000 	strh.w	r4, [sp]

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
    cloud_function_descriptor desc = {};
    desc.size = sizeof(desc);
    desc.fn = fn;
 80a1dcc:	9702      	str	r7, [sp, #8]
    desc.data = (void*)data;
 80a1dce:	9603      	str	r6, [sp, #12]
    desc.funcKey = funcKey;
 80a1dd0:	9501      	str	r5, [sp, #4]
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a1dd2:	f7ff fd77 	bl	80a18c4 <spark_function>
}
 80a1dd6:	b005      	add	sp, #20
 80a1dd8:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a1dda <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a1dda:	4770      	bx	lr

080a1ddc <_ZN9IPAddressD0Ev>:
 80a1ddc:	b510      	push	{r4, lr}
 80a1dde:	4604      	mov	r4, r0
 80a1de0:	2118      	movs	r1, #24
 80a1de2:	f000 fb9b 	bl	80a251c <_ZdlPvj>
 80a1de6:	4620      	mov	r0, r4
 80a1de8:	bd10      	pop	{r4, pc}

080a1dea <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a1dea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1dec:	460f      	mov	r7, r1
 80a1dee:	f100 0608 	add.w	r6, r0, #8
 80a1df2:	1d05      	adds	r5, r0, #4
 80a1df4:	2400      	movs	r4, #0
            t = print('-');
            val = -n;
        } else {
            val = n;
        }
        return printNumber(val, base) + t;
 80a1df6:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a1dfa:	220a      	movs	r2, #10
 80a1dfc:	4638      	mov	r0, r7
 80a1dfe:	f7ff fe92 	bl	80a1b26 <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a1e02:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a1e04:	4404      	add	r4, r0
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a1e06:	d007      	beq.n	80a1e18 <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a1e08:	2c00      	cmp	r4, #0
 80a1e0a:	d0f4      	beq.n	80a1df6 <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a1e0c:	212e      	movs	r1, #46	; 0x2e
 80a1e0e:	4638      	mov	r0, r7
 80a1e10:	f7ff fe70 	bl	80a1af4 <_ZN5Print5printEc>
 80a1e14:	4404      	add	r4, r0
 80a1e16:	e7ee      	b.n	80a1df6 <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a1e18:	4620      	mov	r0, r4
 80a1e1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1e1c <_ZN9IPAddressC1Ev>:

#if HAL_USE_INET_HAL_POSIX
#include <arpa/inet.h>
#endif // HAL_USE_INET_HAL_POSIX

IPAddress::IPAddress()
 80a1e1c:	b510      	push	{r4, lr}
 80a1e1e:	4604      	mov	r4, r0
 80a1e20:	4b04      	ldr	r3, [pc, #16]	; (80a1e34 <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a1e22:	2211      	movs	r2, #17
 80a1e24:	f840 3b04 	str.w	r3, [r0], #4
 80a1e28:	2100      	movs	r1, #0
 80a1e2a:	f000 fcec 	bl	80a2806 <memset>
{
    clear();
}
 80a1e2e:	4620      	mov	r0, r4
 80a1e30:	bd10      	pop	{r4, pc}
 80a1e32:	bf00      	nop
 80a1e34:	080a7e3c 	.word	0x080a7e3c

080a1e38 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:

IPAddress::IPAddress(const HAL_IPAddress& address)
 80a1e38:	4603      	mov	r3, r0
 80a1e3a:	4a07      	ldr	r2, [pc, #28]	; (80a1e58 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
 80a1e3c:	b510      	push	{r4, lr}
 80a1e3e:	f843 2b04 	str.w	r2, [r3], #4
{
    memcpy(&this->address, &address, sizeof(address));
 80a1e42:	f101 0210 	add.w	r2, r1, #16
 80a1e46:	f851 4b04 	ldr.w	r4, [r1], #4
 80a1e4a:	4291      	cmp	r1, r2
 80a1e4c:	f843 4b04 	str.w	r4, [r3], #4
 80a1e50:	d1f9      	bne.n	80a1e46 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
 80a1e52:	780a      	ldrb	r2, [r1, #0]
 80a1e54:	701a      	strb	r2, [r3, #0]
}
 80a1e56:	bd10      	pop	{r4, pc}
 80a1e58:	080a7e3c 	.word	0x080a7e3c

080a1e5c <_ZN9IPAddressC1Em>:
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
}

IPAddress::IPAddress(uint32_t address)
 80a1e5c:	4a02      	ldr	r2, [pc, #8]	; (80a1e68 <_ZN9IPAddressC1Em+0xc>)
    return *this;
}

IPAddress& IPAddress::operator=(uint32_t ipv4)
{
    address.ipv4 = ipv4;
 80a1e5e:	6041      	str	r1, [r0, #4]
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
}

IPAddress::IPAddress(uint32_t address)
 80a1e60:	6002      	str	r2, [r0, #0]
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a1e62:	2204      	movs	r2, #4
 80a1e64:	7502      	strb	r2, [r0, #20]
{
    *this = address;
}
 80a1e66:	4770      	bx	lr
 80a1e68:	080a7e3c 	.word	0x080a7e3c

080a1e6c <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a1e6c:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a1e6e:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a1e72:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a1e76:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a1e7a:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
 80a1e7e:	2304      	movs	r3, #4
 80a1e80:	6041      	str	r1, [r0, #4]
 80a1e82:	7503      	strb	r3, [r0, #20]
 80a1e84:	bd10      	pop	{r4, pc}
	...

080a1e88 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a1e88:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1e8a:	4d04      	ldr	r5, [pc, #16]	; (80a1e9c <_ZN9IPAddressC1Ehhhh+0x14>)
 80a1e8c:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a1e8e:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a1e92:	9500      	str	r5, [sp, #0]
 80a1e94:	f7ff ffea 	bl	80a1e6c <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a1e98:	b003      	add	sp, #12
 80a1e9a:	bd30      	pop	{r4, r5, pc}
 80a1e9c:	080a7e3c 	.word	0x080a7e3c

080a1ea0 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a1ea0:	7441      	strb	r1, [r0, #17]
 80a1ea2:	4770      	bx	lr

080a1ea4 <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
 80a1ea4:	4770      	bx	lr

080a1ea6 <_ZN9USBSerial4readEv>:
}


// Read data from buffer
int USBSerial::read()
{
 80a1ea6:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
 80a1ea8:	2100      	movs	r1, #0
 80a1eaa:	7c00      	ldrb	r0, [r0, #16]
 80a1eac:	f7ff fc6e 	bl	80a178c <HAL_USB_USART_Receive_Data>
}
 80a1eb0:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a1eb4:	bf28      	it	cs
 80a1eb6:	f04f 30ff 	movcs.w	r0, #4294967295
 80a1eba:	bd08      	pop	{r3, pc}

080a1ebc <_ZN9USBSerial4peekEv>:
{
  _blocking = block;
}

int USBSerial::peek()
{
 80a1ebc:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
 80a1ebe:	2101      	movs	r1, #1
 80a1ec0:	7c00      	ldrb	r0, [r0, #16]
 80a1ec2:	f7ff fc63 	bl	80a178c <HAL_USB_USART_Receive_Data>
}
 80a1ec6:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a1eca:	bf28      	it	cs
 80a1ecc:	f04f 30ff 	movcs.w	r0, #4294967295
 80a1ed0:	bd08      	pop	{r3, pc}

080a1ed2 <_ZN9USBSerial17availableForWriteEv>:
{
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
}

int USBSerial::availableForWrite()
{
 80a1ed2:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
 80a1ed4:	7c00      	ldrb	r0, [r0, #16]
 80a1ed6:	f7ff fc51 	bl	80a177c <HAL_USB_USART_Available_Data_For_Write>
}
 80a1eda:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a1ede:	bd08      	pop	{r3, pc}

080a1ee0 <_ZN9USBSerial9availableEv>:

int USBSerial::available()
{
 80a1ee0:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
 80a1ee2:	7c00      	ldrb	r0, [r0, #16]
 80a1ee4:	f7ff fc42 	bl	80a176c <HAL_USB_USART_Available_Data>
}
 80a1ee8:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a1eec:	bd08      	pop	{r3, pc}

080a1eee <_ZN9USBSerial5flushEv>:
  return 0;
}

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a1eee:	7c00      	ldrb	r0, [r0, #16]
 80a1ef0:	f7ff bc5c 	b.w	80a17ac <HAL_USB_USART_Flush_Data>

080a1ef4 <_ZN9USBSerialD0Ev>:
 80a1ef4:	b510      	push	{r4, lr}
 80a1ef6:	4604      	mov	r4, r0
 80a1ef8:	2114      	movs	r1, #20
 80a1efa:	f000 fb0f 	bl	80a251c <_ZdlPvj>
 80a1efe:	4620      	mov	r0, r4
 80a1f00:	bd10      	pop	{r4, pc}

080a1f02 <_ZN9USBSerial5writeEh>:
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
 80a1f02:	b538      	push	{r3, r4, r5, lr}
 80a1f04:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a1f06:	7c00      	ldrb	r0, [r0, #16]
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
 80a1f08:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a1f0a:	f7ff fc37 	bl	80a177c <HAL_USB_USART_Available_Data_For_Write>
 80a1f0e:	2800      	cmp	r0, #0
 80a1f10:	dc01      	bgt.n	80a1f16 <_ZN9USBSerial5writeEh+0x14>
 80a1f12:	7c60      	ldrb	r0, [r4, #17]
 80a1f14:	b128      	cbz	r0, 80a1f22 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
 80a1f16:	4629      	mov	r1, r5
 80a1f18:	7c20      	ldrb	r0, [r4, #16]
 80a1f1a:	f7ff fc3f 	bl	80a179c <HAL_USB_USART_Send_Data>
 80a1f1e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
  }
  return 0;
}
 80a1f22:	bd38      	pop	{r3, r4, r5, pc}

080a1f24 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a1f24:	b510      	push	{r4, lr}
 80a1f26:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a1f28:	2300      	movs	r3, #0
 80a1f2a:	6063      	str	r3, [r4, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a1f2c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a1f30:	60a3      	str	r3, [r4, #8]
 80a1f32:	4b05      	ldr	r3, [pc, #20]	; (80a1f48 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a1f34:	4608      	mov	r0, r1
 80a1f36:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a1f38:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a1f3a:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a1f3c:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a1f3e:	4611      	mov	r1, r2
 80a1f40:	f7ff fc0c 	bl	80a175c <HAL_USB_USART_Init>
}
 80a1f44:	4620      	mov	r0, r4
 80a1f46:	bd10      	pop	{r4, pc}
 80a1f48:	080a7e50 	.word	0x080a7e50

080a1f4c <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a1f4c:	b510      	push	{r4, lr}
 80a1f4e:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a1f50:	2214      	movs	r2, #20
 80a1f52:	2100      	movs	r1, #0
 80a1f54:	f000 fc57 	bl	80a2806 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a1f58:	4b05      	ldr	r3, [pc, #20]	; (80a1f70 <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a1f5a:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a1f5c:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a1f5e:	4b05      	ldr	r3, [pc, #20]	; (80a1f74 <_Z19acquireSerialBufferv+0x28>)
 80a1f60:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a1f62:	f240 1301 	movw	r3, #257	; 0x101
 80a1f66:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a1f68:	2381      	movs	r3, #129	; 0x81
 80a1f6a:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a1f6c:	bd10      	pop	{r4, pc}
 80a1f6e:	bf00      	nop
 80a1f70:	200001a5 	.word	0x200001a5
 80a1f74:	20000124 	.word	0x20000124

080a1f78 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a1f78:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a1f7a:	4d0e      	ldr	r5, [pc, #56]	; (80a1fb4 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a1f7c:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a1f7e:	a801      	add	r0, sp, #4
 80a1f80:	f7ff ffe4 	bl	80a1f4c <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a1f84:	6829      	ldr	r1, [r5, #0]
 80a1f86:	f011 0401 	ands.w	r4, r1, #1
 80a1f8a:	d110      	bne.n	80a1fae <_Z16_fetch_usbserialv+0x36>
 80a1f8c:	4628      	mov	r0, r5
 80a1f8e:	f7fe f886 	bl	80a009e <__cxa_guard_acquire>
 80a1f92:	b160      	cbz	r0, 80a1fae <_Z16_fetch_usbserialv+0x36>
 80a1f94:	aa01      	add	r2, sp, #4
 80a1f96:	4621      	mov	r1, r4
 80a1f98:	4807      	ldr	r0, [pc, #28]	; (80a1fb8 <_Z16_fetch_usbserialv+0x40>)
 80a1f9a:	f7ff ffc3 	bl	80a1f24 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a1f9e:	4628      	mov	r0, r5
 80a1fa0:	f7fe f882 	bl	80a00a8 <__cxa_guard_release>
 80a1fa4:	4a05      	ldr	r2, [pc, #20]	; (80a1fbc <_Z16_fetch_usbserialv+0x44>)
 80a1fa6:	4906      	ldr	r1, [pc, #24]	; (80a1fc0 <_Z16_fetch_usbserialv+0x48>)
 80a1fa8:	4803      	ldr	r0, [pc, #12]	; (80a1fb8 <_Z16_fetch_usbserialv+0x40>)
 80a1faa:	f000 faa9 	bl	80a2500 <__aeabi_atexit>
	return _usbserial;
}
 80a1fae:	4802      	ldr	r0, [pc, #8]	; (80a1fb8 <_Z16_fetch_usbserialv+0x40>)
 80a1fb0:	b007      	add	sp, #28
 80a1fb2:	bd30      	pop	{r4, r5, pc}
 80a1fb4:	20000120 	.word	0x20000120
 80a1fb8:	200002a8 	.word	0x200002a8
 80a1fbc:	200000d8 	.word	0x200000d8
 80a1fc0:	080a1ea5 	.word	0x080a1ea5

080a1fc4 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a1fc4:	b510      	push	{r4, lr}
 80a1fc6:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a1fc8:	2214      	movs	r2, #20
 80a1fca:	2100      	movs	r1, #0
 80a1fcc:	f000 fc1b 	bl	80a2806 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a1fd0:	4b05      	ldr	r3, [pc, #20]	; (80a1fe8 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a1fd2:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a1fd4:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a1fd6:	4b05      	ldr	r3, [pc, #20]	; (80a1fec <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a1fd8:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a1fda:	f240 1301 	movw	r3, #257	; 0x101
 80a1fde:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a1fe0:	2381      	movs	r3, #129	; 0x81
 80a1fe2:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a1fe4:	bd10      	pop	{r4, pc}
 80a1fe6:	bf00      	nop
 80a1fe8:	20000358 	.word	0x20000358
 80a1fec:	200002c0 	.word	0x200002c0

080a1ff0 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a1ff0:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a1ff2:	4c0e      	ldr	r4, [pc, #56]	; (80a202c <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a1ff4:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a1ff6:	a801      	add	r0, sp, #4
 80a1ff8:	f7ff ffe4 	bl	80a1fc4 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a1ffc:	6823      	ldr	r3, [r4, #0]
 80a1ffe:	07db      	lsls	r3, r3, #31
 80a2000:	d410      	bmi.n	80a2024 <_Z17_fetch_usbserial1v+0x34>
 80a2002:	4620      	mov	r0, r4
 80a2004:	f7fe f84b 	bl	80a009e <__cxa_guard_acquire>
 80a2008:	b160      	cbz	r0, 80a2024 <_Z17_fetch_usbserial1v+0x34>
 80a200a:	aa01      	add	r2, sp, #4
 80a200c:	2101      	movs	r1, #1
 80a200e:	4808      	ldr	r0, [pc, #32]	; (80a2030 <_Z17_fetch_usbserial1v+0x40>)
 80a2010:	f7ff ff88 	bl	80a1f24 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a2014:	4620      	mov	r0, r4
 80a2016:	f7fe f847 	bl	80a00a8 <__cxa_guard_release>
 80a201a:	4a06      	ldr	r2, [pc, #24]	; (80a2034 <_Z17_fetch_usbserial1v+0x44>)
 80a201c:	4906      	ldr	r1, [pc, #24]	; (80a2038 <_Z17_fetch_usbserial1v+0x48>)
 80a201e:	4804      	ldr	r0, [pc, #16]	; (80a2030 <_Z17_fetch_usbserial1v+0x40>)
 80a2020:	f000 fa6e 	bl	80a2500 <__aeabi_atexit>
  return _usbserial1;
}
 80a2024:	4802      	ldr	r0, [pc, #8]	; (80a2030 <_Z17_fetch_usbserial1v+0x40>)
 80a2026:	b006      	add	sp, #24
 80a2028:	bd10      	pop	{r4, pc}
 80a202a:	bf00      	nop
 80a202c:	200002bc 	.word	0x200002bc
 80a2030:	20000344 	.word	0x20000344
 80a2034:	200000d8 	.word	0x200000d8
 80a2038:	080a1ea5 	.word	0x080a1ea5

080a203c <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a203c:	4770      	bx	lr

080a203e <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a203e:	7441      	strb	r1, [r0, #17]
 80a2040:	4770      	bx	lr

080a2042 <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
 80a2042:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data_For_Write(_serial));
 80a2044:	7c00      	ldrb	r0, [r0, #16]
 80a2046:	f7ff fb47 	bl	80a16d8 <HAL_USART_Available_Data_For_Write>
}
 80a204a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a204e:	bd08      	pop	{r3, pc}

080a2050 <_ZN11USARTSerial9availableEv>:

int USARTSerial::available(void)
{
 80a2050:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data(_serial));
 80a2052:	7c00      	ldrb	r0, [r0, #16]
 80a2054:	f7ff fb18 	bl	80a1688 <HAL_USART_Available_Data>
}
 80a2058:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a205c:	bd08      	pop	{r3, pc}

080a205e <_ZN11USARTSerial4peekEv>:

int USARTSerial::peek(void)
{
 80a205e:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Peek_Data(_serial));
 80a2060:	7c00      	ldrb	r0, [r0, #16]
 80a2062:	f7ff fb21 	bl	80a16a8 <HAL_USART_Peek_Data>
}
 80a2066:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a206a:	bf28      	it	cs
 80a206c:	f04f 30ff 	movcs.w	r0, #4294967295
 80a2070:	bd08      	pop	{r3, pc}

080a2072 <_ZN11USARTSerial4readEv>:

int USARTSerial::read(void)
{
 80a2072:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Read_Data(_serial));
 80a2074:	7c00      	ldrb	r0, [r0, #16]
 80a2076:	f7ff fb0f 	bl	80a1698 <HAL_USART_Read_Data>
}
 80a207a:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a207e:	bf28      	it	cs
 80a2080:	f04f 30ff 	movcs.w	r0, #4294967295
 80a2084:	bd08      	pop	{r3, pc}

080a2086 <_ZN11USARTSerial5flushEv>:

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a2086:	7c00      	ldrb	r0, [r0, #16]
 80a2088:	f7ff bb16 	b.w	80a16b8 <HAL_USART_Flush_Data>

080a208c <_ZN11USARTSerialD0Ev>:
 80a208c:	b510      	push	{r4, lr}
 80a208e:	4604      	mov	r4, r0
 80a2090:	2114      	movs	r1, #20
 80a2092:	f000 fa43 	bl	80a251c <_ZdlPvj>
 80a2096:	4620      	mov	r0, r4
 80a2098:	bd10      	pop	{r4, pc}

080a209a <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a209a:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a209c:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a209e:	4604      	mov	r4, r0
 80a20a0:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a20a2:	b925      	cbnz	r5, 80a20ae <_ZN11USARTSerial5writeEh+0x14>
 80a20a4:	7c00      	ldrb	r0, [r0, #16]
 80a20a6:	f7ff fb17 	bl	80a16d8 <HAL_USART_Available_Data_For_Write>
 80a20aa:	2800      	cmp	r0, #0
 80a20ac:	dd05      	ble.n	80a20ba <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a20ae:	4631      	mov	r1, r6
 80a20b0:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a20b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a20b6:	f7ff badf 	b.w	80a1678 <HAL_USART_Write_Data>
  }
  return 0;
}
 80a20ba:	4628      	mov	r0, r5
 80a20bc:	bd70      	pop	{r4, r5, r6, pc}
	...

080a20c0 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a20c0:	b510      	push	{r4, lr}
 80a20c2:	4604      	mov	r4, r0
 80a20c4:	4608      	mov	r0, r1
 80a20c6:	4611      	mov	r1, r2
 80a20c8:	2200      	movs	r2, #0
 80a20ca:	6062      	str	r2, [r4, #4]
 80a20cc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a20d0:	60a2      	str	r2, [r4, #8]
 80a20d2:	4a05      	ldr	r2, [pc, #20]	; (80a20e8 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a20d4:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a20d6:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a20d8:	2201      	movs	r2, #1
 80a20da:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a20dc:	461a      	mov	r2, r3
 80a20de:	f7ff fac3 	bl	80a1668 <HAL_USART_Init>
}
 80a20e2:	4620      	mov	r0, r4
 80a20e4:	bd10      	pop	{r4, pc}
 80a20e6:	bf00      	nop
 80a20e8:	080a7e80 	.word	0x080a7e80

080a20ec <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a20ec:	7c00      	ldrb	r0, [r0, #16]
 80a20ee:	f7ff baeb 	b.w	80a16c8 <HAL_USART_Is_Enabled>
	...

080a20f4 <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a20f4:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a20f6:	4d0c      	ldr	r5, [pc, #48]	; (80a2128 <_Z22__fetch_global_Serial1v+0x34>)
 80a20f8:	6829      	ldr	r1, [r5, #0]
 80a20fa:	f011 0401 	ands.w	r4, r1, #1
 80a20fe:	d111      	bne.n	80a2124 <_Z22__fetch_global_Serial1v+0x30>
 80a2100:	4628      	mov	r0, r5
 80a2102:	f7fd ffcc 	bl	80a009e <__cxa_guard_acquire>
 80a2106:	b168      	cbz	r0, 80a2124 <_Z22__fetch_global_Serial1v+0x30>
 80a2108:	4a08      	ldr	r2, [pc, #32]	; (80a212c <_Z22__fetch_global_Serial1v+0x38>)
 80a210a:	4621      	mov	r1, r4
 80a210c:	4b08      	ldr	r3, [pc, #32]	; (80a2130 <_Z22__fetch_global_Serial1v+0x3c>)
 80a210e:	4809      	ldr	r0, [pc, #36]	; (80a2134 <_Z22__fetch_global_Serial1v+0x40>)
 80a2110:	f7ff ffd6 	bl	80a20c0 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a2114:	4628      	mov	r0, r5
 80a2116:	f7fd ffc7 	bl	80a00a8 <__cxa_guard_release>
 80a211a:	4a07      	ldr	r2, [pc, #28]	; (80a2138 <_Z22__fetch_global_Serial1v+0x44>)
 80a211c:	4907      	ldr	r1, [pc, #28]	; (80a213c <_Z22__fetch_global_Serial1v+0x48>)
 80a211e:	4805      	ldr	r0, [pc, #20]	; (80a2134 <_Z22__fetch_global_Serial1v+0x40>)
 80a2120:	f000 f9ee 	bl	80a2500 <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a2124:	4803      	ldr	r0, [pc, #12]	; (80a2134 <_Z22__fetch_global_Serial1v+0x40>)
 80a2126:	bd38      	pop	{r3, r4, r5, pc}
 80a2128:	200004f4 	.word	0x200004f4
 80a212c:	200004f8 	.word	0x200004f8
 80a2130:	20000470 	.word	0x20000470
 80a2134:	2000045c 	.word	0x2000045c
 80a2138:	200000d8 	.word	0x200000d8
 80a213c:	080a203d 	.word	0x080a203d

080a2140 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& config);
  virtual ~TwoWire() {};
 80a2140:	4770      	bx	lr

080a2142 <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a2142:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2144:	4606      	mov	r6, r0
 80a2146:	4615      	mov	r5, r2
 80a2148:	460c      	mov	r4, r1
 80a214a:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a214c:	42bc      	cmp	r4, r7
 80a214e:	d006      	beq.n	80a215e <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a2150:	6833      	ldr	r3, [r6, #0]
 80a2152:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a2156:	689b      	ldr	r3, [r3, #8]
 80a2158:	4630      	mov	r0, r6
 80a215a:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a215c:	e7f6      	b.n	80a214c <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a215e:	4628      	mov	r0, r5
 80a2160:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2162 <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a2162:	2200      	movs	r2, #0
 80a2164:	7c00      	ldrb	r0, [r0, #16]
 80a2166:	f7ff babf 	b.w	80a16e8 <HAL_I2C_Write_Data>

080a216a <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a216a:	2100      	movs	r1, #0
 80a216c:	7c00      	ldrb	r0, [r0, #16]
 80a216e:	f7ff bac3 	b.w	80a16f8 <HAL_I2C_Available_Data>

080a2172 <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a2172:	2100      	movs	r1, #0
 80a2174:	7c00      	ldrb	r0, [r0, #16]
 80a2176:	f7ff bac7 	b.w	80a1708 <HAL_I2C_Read_Data>

080a217a <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a217a:	2100      	movs	r1, #0
 80a217c:	7c00      	ldrb	r0, [r0, #16]
 80a217e:	f7ff bacb 	b.w	80a1718 <HAL_I2C_Peek_Data>

080a2182 <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a2182:	2100      	movs	r1, #0
 80a2184:	7c00      	ldrb	r0, [r0, #16]
 80a2186:	f7ff bacf 	b.w	80a1728 <HAL_I2C_Flush_Data>

080a218a <_ZN7TwoWireD0Ev>:
 80a218a:	b510      	push	{r4, lr}
 80a218c:	4604      	mov	r4, r0
 80a218e:	2114      	movs	r1, #20
 80a2190:	f000 f9c4 	bl	80a251c <_ZdlPvj>
 80a2194:	4620      	mov	r0, r4
 80a2196:	bd10      	pop	{r4, pc}

080a2198 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& conf)
 80a2198:	b510      	push	{r4, lr}
 80a219a:	4604      	mov	r4, r0
 80a219c:	2300      	movs	r3, #0
 80a219e:	6063      	str	r3, [r4, #4]
 80a21a0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a21a4:	60a3      	str	r3, [r4, #8]
 80a21a6:	4b04      	ldr	r3, [pc, #16]	; (80a21b8 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config+0x20>)
{
  _i2c = i2c;
 80a21a8:	7421      	strb	r1, [r4, #16]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& conf)
 80a21aa:	4608      	mov	r0, r1
 80a21ac:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, &conf);
 80a21ae:	4611      	mov	r1, r2
 80a21b0:	f7ff faca 	bl	80a1748 <HAL_I2C_Init>
}
 80a21b4:	4620      	mov	r0, r4
 80a21b6:	bd10      	pop	{r4, pc}
 80a21b8:	080a7eb0 	.word	0x080a7eb0

080a21bc <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a21bc:	2100      	movs	r1, #0
 80a21be:	7c00      	ldrb	r0, [r0, #16]
 80a21c0:	f7ff baba 	b.w	80a1738 <HAL_I2C_Is_Enabled>

080a21c4 <_Z6randomi>:
#include "spark_wiring_random.h"
#include <stdlib.h>

int random(int max)
{
 80a21c4:	b510      	push	{r4, lr}
  if (0 == max) {
 80a21c6:	4604      	mov	r4, r0
 80a21c8:	b130      	cbz	r0, 80a21d8 <_Z6randomi+0x14>
    return 0;
  }
  return rand() % max;
 80a21ca:	f000 fb4d 	bl	80a2868 <rand>
 80a21ce:	fb90 f3f4 	sdiv	r3, r0, r4
 80a21d2:	fb03 0014 	mls	r0, r3, r4, r0
 80a21d6:	bd10      	pop	{r4, pc}
}
 80a21d8:	bd10      	pop	{r4, pc}

080a21da <_Z6randomii>:

int random(int min, int max)
{
  if (min >= max) {
 80a21da:	4288      	cmp	r0, r1
  }
  return rand() % max;
}

int random(int min, int max)
{
 80a21dc:	b510      	push	{r4, lr}
 80a21de:	4604      	mov	r4, r0
  if (min >= max) {
 80a21e0:	da04      	bge.n	80a21ec <_Z6randomii+0x12>
    return min;
  }
  return random(max - min) + min;
 80a21e2:	1a08      	subs	r0, r1, r0
 80a21e4:	f7ff ffee 	bl	80a21c4 <_Z6randomi>
 80a21e8:	4420      	add	r0, r4
 80a21ea:	bd10      	pop	{r4, pc}
}
 80a21ec:	bd10      	pop	{r4, pc}

080a21ee <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a21ee:	2200      	movs	r2, #0
 80a21f0:	4611      	mov	r1, r2
 80a21f2:	6840      	ldr	r0, [r0, #4]
 80a21f4:	f7ff bb2e 	b.w	80a1854 <network_ready>

080a21f8 <_ZN5spark9WiFiClass7resolveEPKc>:
    WLanSelectAntenna_TypeDef getAntenna() {
        return wlan_get_antenna(nullptr);
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
 80a21f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a21fa:	4616      	mov	r6, r2
 80a21fc:	b089      	sub	sp, #36	; 0x24
    {
        HAL_IPAddress ip = {};
 80a21fe:	2211      	movs	r2, #17
    WLanSelectAntenna_TypeDef getAntenna() {
        return wlan_get_antenna(nullptr);
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
 80a2200:	460f      	mov	r7, r1
 80a2202:	4604      	mov	r4, r0
    {
        HAL_IPAddress ip = {};
 80a2204:	2100      	movs	r1, #0
 80a2206:	a803      	add	r0, sp, #12
 80a2208:	f000 fafd 	bl	80a2806 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a220c:	4630      	mov	r0, r6
 80a220e:	f000 fb6f 	bl	80a28f0 <strlen>
 80a2212:	2500      	movs	r5, #0
 80a2214:	9500      	str	r5, [sp, #0]
 80a2216:	b281      	uxth	r1, r0
 80a2218:	687b      	ldr	r3, [r7, #4]
 80a221a:	aa03      	add	r2, sp, #12
 80a221c:	4630      	mov	r0, r6
 80a221e:	f7ff facd 	bl	80a17bc <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a2222:	b120      	cbz	r0, 80a222e <_ZN5spark9WiFiClass7resolveEPKc+0x36>
 80a2224:	4629      	mov	r1, r5
 80a2226:	4620      	mov	r0, r4
 80a2228:	f7ff fe18 	bl	80a1e5c <_ZN9IPAddressC1Em>
 80a222c:	e003      	b.n	80a2236 <_ZN5spark9WiFiClass7resolveEPKc+0x3e>
 80a222e:	a903      	add	r1, sp, #12
 80a2230:	4620      	mov	r0, r4
 80a2232:	f7ff fe01 	bl	80a1e38 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    }
 80a2236:	4620      	mov	r0, r4
 80a2238:	b009      	add	sp, #36	; 0x24
 80a223a:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a223c <_ZN5spark9WiFiClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
 80a223c:	2200      	movs	r2, #0
 80a223e:	4611      	mov	r1, r2
 80a2240:	6840      	ldr	r0, [r0, #4]
 80a2242:	f7ff bb27 	b.w	80a1894 <network_listening>

080a2246 <_ZN5spark9WiFiClass16getListenTimeoutEv>:
        network_set_listen_timeout(*this, timeout, NULL);
    }
    inline void setListenTimeout(std::chrono::seconds s) { setListenTimeout(s.count()); }

    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
 80a2246:	2200      	movs	r2, #0
 80a2248:	4611      	mov	r1, r2
 80a224a:	6840      	ldr	r0, [r0, #4]
 80a224c:	f7ff bb32 	b.w	80a18b4 <network_get_listen_timeout>

080a2250 <_ZN5spark9WiFiClass16setListenTimeoutEt>:
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
    }

    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
 80a2250:	2200      	movs	r2, #0
 80a2252:	6840      	ldr	r0, [r0, #4]
 80a2254:	f7ff bb26 	b.w	80a18a4 <network_set_listen_timeout>

080a2258 <_ZN5spark9WiFiClass6listenEb>:
    void off(void) {
        network_off(*this, 0, 0, NULL);
    }

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
 80a2258:	2200      	movs	r2, #0
 80a225a:	f081 0101 	eor.w	r1, r1, #1
 80a225e:	6840      	ldr	r0, [r0, #4]
 80a2260:	f7ff bb10 	b.w	80a1884 <network_listen>

080a2264 <_ZN5spark9WiFiClass3offEv>:
    void on(void) {
        network_on(*this, 0, 0, NULL);
    }

    void off(void) {
        network_off(*this, 0, 0, NULL);
 80a2264:	2300      	movs	r3, #0
 80a2266:	461a      	mov	r2, r3
 80a2268:	4619      	mov	r1, r3
 80a226a:	6840      	ldr	r0, [r0, #4]
 80a226c:	f7ff bb02 	b.w	80a1874 <network_off>

080a2270 <_ZN5spark9WiFiClass10connectingEv>:
    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
    }

    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
 80a2270:	2200      	movs	r2, #0
 80a2272:	4611      	mov	r1, r2
 80a2274:	6840      	ldr	r0, [r0, #4]
 80a2276:	f7ff badd 	b.w	80a1834 <network_connecting>

080a227a <_ZN5spark9WiFiClass10disconnectEv>:
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }

    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
 80a227a:	2200      	movs	r2, #0
 80a227c:	2102      	movs	r1, #2
 80a227e:	6840      	ldr	r0, [r0, #4]
 80a2280:	f7ff bae0 	b.w	80a1844 <network_disconnect>

080a2284 <_ZN5spark9WiFiClass7connectEj>:
    uint32_t ping(IPAddress remoteIP, uint8_t nTries) {
        return inet_ping(&remoteIP.raw(), *this, nTries, NULL);
    }

    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
 80a2284:	2300      	movs	r3, #0
 80a2286:	461a      	mov	r2, r3
 80a2288:	6840      	ldr	r0, [r0, #4]
 80a228a:	f7ff bacb 	b.w	80a1824 <network_connect>
	...

080a2290 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
 80a2290:	4b02      	ldr	r3, [pc, #8]	; (80a229c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0xc>)
 80a2292:	2204      	movs	r2, #4
 80a2294:	605a      	str	r2, [r3, #4]
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() :
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
 80a2296:	4a02      	ldr	r2, [pc, #8]	; (80a22a0 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a2298:	601a      	str	r2, [r3, #0]
 80a229a:	4770      	bx	lr
 80a229c:	2000057c 	.word	0x2000057c
 80a22a0:	080a7ed8 	.word	0x080a7ed8

080a22a4 <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
 80a22a4:	2300      	movs	r3, #0
 80a22a6:	461a      	mov	r2, r3
 80a22a8:	6840      	ldr	r0, [r0, #4]
 80a22aa:	f7ff babb 	b.w	80a1824 <network_connect>

080a22ae <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
 80a22ae:	2200      	movs	r2, #0
 80a22b0:	2102      	movs	r1, #2
 80a22b2:	6840      	ldr	r0, [r0, #4]
 80a22b4:	f7ff bac6 	b.w	80a1844 <network_disconnect>

080a22b8 <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
 80a22b8:	2200      	movs	r2, #0
 80a22ba:	4611      	mov	r1, r2
 80a22bc:	6840      	ldr	r0, [r0, #4]
 80a22be:	f7ff bab9 	b.w	80a1834 <network_connecting>

080a22c2 <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
 80a22c2:	2200      	movs	r2, #0
 80a22c4:	4611      	mov	r1, r2
 80a22c6:	6840      	ldr	r0, [r0, #4]
 80a22c8:	f7ff bac4 	b.w	80a1854 <network_ready>

080a22cc <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
 80a22cc:	2300      	movs	r3, #0
 80a22ce:	461a      	mov	r2, r3
 80a22d0:	4619      	mov	r1, r3
 80a22d2:	6840      	ldr	r0, [r0, #4]
 80a22d4:	f7ff bac6 	b.w	80a1864 <network_on>

080a22d8 <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
 80a22d8:	2300      	movs	r3, #0
 80a22da:	461a      	mov	r2, r3
 80a22dc:	4619      	mov	r1, r3
 80a22de:	6840      	ldr	r0, [r0, #4]
 80a22e0:	f7ff bac8 	b.w	80a1874 <network_off>

080a22e4 <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
 80a22e4:	2200      	movs	r2, #0
 80a22e6:	f081 0101 	eor.w	r1, r1, #1
 80a22ea:	6840      	ldr	r0, [r0, #4]
 80a22ec:	f7ff baca 	b.w	80a1884 <network_listen>

080a22f0 <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
 80a22f0:	2200      	movs	r2, #0
 80a22f2:	6840      	ldr	r0, [r0, #4]
 80a22f4:	f7ff bad6 	b.w	80a18a4 <network_set_listen_timeout>

080a22f8 <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
 80a22f8:	2200      	movs	r2, #0
 80a22fa:	4611      	mov	r1, r2
 80a22fc:	6840      	ldr	r0, [r0, #4]
 80a22fe:	f7ff bad9 	b.w	80a18b4 <network_get_listen_timeout>

080a2302 <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
 80a2302:	2200      	movs	r2, #0
 80a2304:	4611      	mov	r1, r2
 80a2306:	6840      	ldr	r0, [r0, #4]
 80a2308:	f7ff bac4 	b.w	80a1894 <network_listening>

080a230c <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
 80a230c:	b570      	push	{r4, r5, r6, lr}
 80a230e:	4616      	mov	r6, r2
 80a2310:	b08e      	sub	sp, #56	; 0x38
 80a2312:	4604      	mov	r4, r0
    IPAddress addr;
 80a2314:	a808      	add	r0, sp, #32
 80a2316:	f7ff fd81 	bl	80a1e1c <_ZN9IPAddressC1Ev>
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
    {
        HAL_IPAddress ip = {};
 80a231a:	2211      	movs	r2, #17
 80a231c:	2100      	movs	r1, #0
 80a231e:	a803      	add	r0, sp, #12
 80a2320:	f000 fa71 	bl	80a2806 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a2324:	4630      	mov	r0, r6
 80a2326:	f000 fae3 	bl	80a28f0 <strlen>
 80a232a:	2500      	movs	r5, #0
 80a232c:	4b0a      	ldr	r3, [pc, #40]	; (80a2358 <_ZN5spark12NetworkClass7resolveEPKc+0x4c>)
 80a232e:	9500      	str	r5, [sp, #0]
 80a2330:	b281      	uxth	r1, r0
 80a2332:	685b      	ldr	r3, [r3, #4]
 80a2334:	aa03      	add	r2, sp, #12
 80a2336:	4630      	mov	r0, r6
 80a2338:	f7ff fa40 	bl	80a17bc <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a233c:	b120      	cbz	r0, 80a2348 <_ZN5spark12NetworkClass7resolveEPKc+0x3c>
 80a233e:	4629      	mov	r1, r5
 80a2340:	4620      	mov	r0, r4
 80a2342:	f7ff fd8b 	bl	80a1e5c <_ZN9IPAddressC1Em>
 80a2346:	e003      	b.n	80a2350 <_ZN5spark12NetworkClass7resolveEPKc+0x44>
 80a2348:	a903      	add	r1, sp, #12
 80a234a:	4620      	mov	r0, r4
 80a234c:	f7ff fd74 	bl	80a1e38 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
 80a2350:	4620      	mov	r0, r4
 80a2352:	b00e      	add	sp, #56	; 0x38
 80a2354:	bd70      	pop	{r4, r5, r6, pc}
 80a2356:	bf00      	nop
 80a2358:	2000057c 	.word	0x2000057c

080a235c <_GLOBAL__sub_I__ZN5spark7NetworkE>:
 80a235c:	4b02      	ldr	r3, [pc, #8]	; (80a2368 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
 80a235e:	4a03      	ldr	r2, [pc, #12]	; (80a236c <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
 80a2360:	601a      	str	r2, [r3, #0]
 80a2362:	2200      	movs	r2, #0
 80a2364:	605a      	str	r2, [r3, #4]
 80a2366:	4770      	bx	lr
 80a2368:	20000584 	.word	0x20000584
 80a236c:	080a7f0c 	.word	0x080a7f0c

080a2370 <_ZN8SPIClassD1Ev>:
  RecursiveMutex _mutex;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  ~SPIClass() = default;
 80a2370:	b510      	push	{r4, lr}
 80a2372:	4604      	mov	r4, r0
        dispose();
    }

    void dispose()
    {
        if (handle_) {
 80a2374:	6880      	ldr	r0, [r0, #8]
 80a2376:	b108      	cbz	r0, 80a237c <_ZN8SPIClassD1Ev+0xc>
            os_mutex_recursive_destroy(handle_);
 80a2378:	f7ff f96e 	bl	80a1658 <os_mutex_recursive_destroy>
 80a237c:	4620      	mov	r0, r4
 80a237e:	bd10      	pop	{r4, pc}

080a2380 <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a2380:	b570      	push	{r4, r5, r6, lr}

template <HAL_SPI_Interface Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
 80a2382:	4e1a      	ldr	r6, [pc, #104]	; (80a23ec <pinAvailable+0x6c>)
 80a2384:	4604      	mov	r4, r0
 80a2386:	6831      	ldr	r1, [r6, #0]
 80a2388:	f011 0501 	ands.w	r5, r1, #1
 80a238c:	d10f      	bne.n	80a23ae <pinAvailable+0x2e>
 80a238e:	4630      	mov	r0, r6
 80a2390:	f7fd fe85 	bl	80a009e <__cxa_guard_acquire>
 80a2394:	b158      	cbz	r0, 80a23ae <pinAvailable+0x2e>
 80a2396:	4629      	mov	r1, r5
 80a2398:	4815      	ldr	r0, [pc, #84]	; (80a23f0 <pinAvailable+0x70>)
 80a239a:	f7ff fac3 	bl	80a1924 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a239e:	4630      	mov	r0, r6
 80a23a0:	f7fd fe82 	bl	80a00a8 <__cxa_guard_release>
 80a23a4:	4a13      	ldr	r2, [pc, #76]	; (80a23f4 <pinAvailable+0x74>)
 80a23a6:	4914      	ldr	r1, [pc, #80]	; (80a23f8 <pinAvailable+0x78>)
 80a23a8:	4811      	ldr	r0, [pc, #68]	; (80a23f0 <pinAvailable+0x70>)
 80a23aa:	f000 f8a9 	bl	80a2500 <__aeabi_atexit>
    }
    void detachInterrupt() {
        instance().detachInterrupt();
    }
    bool isEnabled(void) {
        return instance().isEnabled();
 80a23ae:	4810      	ldr	r0, [pc, #64]	; (80a23f0 <pinAvailable+0x70>)
 80a23b0:	f7ff fac7 	bl	80a1942 <_ZN8SPIClass9isEnabledEv>

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a23b4:	b128      	cbz	r0, 80a23c2 <pinAvailable+0x42>
 80a23b6:	f1a4 030d 	sub.w	r3, r4, #13
 80a23ba:	2b02      	cmp	r3, #2
 80a23bc:	d801      	bhi.n	80a23c2 <pinAvailable+0x42>
  {
    return 0; // 'pin' is used
 80a23be:	2000      	movs	r0, #0
 80a23c0:	bd70      	pop	{r4, r5, r6, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a23c2:	f000 f877 	bl	80a24b4 <_Z19__fetch_global_Wirev>
 80a23c6:	f7ff fef9 	bl	80a21bc <_ZN7TwoWire9isEnabledEv>
 80a23ca:	b108      	cbz	r0, 80a23d0 <pinAvailable+0x50>
 80a23cc:	2c01      	cmp	r4, #1
 80a23ce:	d9f6      	bls.n	80a23be <pinAvailable+0x3e>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a23d0:	f7ff fe90 	bl	80a20f4 <_Z22__fetch_global_Serial1v>
 80a23d4:	f7ff fe8a 	bl	80a20ec <_ZN11USARTSerial9isEnabledEv>
 80a23d8:	b118      	cbz	r0, 80a23e2 <pinAvailable+0x62>
 80a23da:	f1a4 0312 	sub.w	r3, r4, #18
 80a23de:	2b01      	cmp	r3, #1
 80a23e0:	d9ed      	bls.n	80a23be <pinAvailable+0x3e>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a23e2:	2c17      	cmp	r4, #23
 80a23e4:	bf8c      	ite	hi
 80a23e6:	2000      	movhi	r0, #0
 80a23e8:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a23ea:	bd70      	pop	{r4, r5, r6, pc}
 80a23ec:	2000058c 	.word	0x2000058c
 80a23f0:	20000590 	.word	0x20000590
 80a23f4:	200000d8 	.word	0x200000d8
 80a23f8:	080a2371 	.word	0x080a2371

080a23fc <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a23fc:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a23fe:	b538      	push	{r3, r4, r5, lr}
 80a2400:	4604      	mov	r4, r0
 80a2402:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a2404:	d80a      	bhi.n	80a241c <pinMode+0x20>
 80a2406:	29ff      	cmp	r1, #255	; 0xff
 80a2408:	d008      	beq.n	80a241c <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a240a:	f7ff ffb9 	bl	80a2380 <pinAvailable>
 80a240e:	b128      	cbz	r0, 80a241c <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a2410:	4629      	mov	r1, r5
 80a2412:	4620      	mov	r0, r4
}
 80a2414:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a2418:	f7ff b8d6 	b.w	80a15c8 <HAL_Pin_Mode>
 80a241c:	bd38      	pop	{r3, r4, r5, pc}

080a241e <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a241e:	b538      	push	{r3, r4, r5, lr}
 80a2420:	4604      	mov	r4, r0
 80a2422:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a2424:	f7ff f8d8 	bl	80a15d8 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a2428:	28ff      	cmp	r0, #255	; 0xff
 80a242a:	d010      	beq.n	80a244e <digitalWrite+0x30>
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
            mode == INPUT_PULLUP ||
            mode == INPUT_PULLDOWN ||
 80a242c:	2806      	cmp	r0, #6
 80a242e:	d804      	bhi.n	80a243a <digitalWrite+0x1c>
 80a2430:	234d      	movs	r3, #77	; 0x4d
 80a2432:	fa23 f000 	lsr.w	r0, r3, r0
 80a2436:	07c3      	lsls	r3, r0, #31
 80a2438:	d409      	bmi.n	80a244e <digitalWrite+0x30>
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a243a:	4620      	mov	r0, r4
 80a243c:	f7ff ffa0 	bl	80a2380 <pinAvailable>
 80a2440:	b128      	cbz	r0, 80a244e <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a2442:	4629      	mov	r1, r5
 80a2444:	4620      	mov	r0, r4
}
 80a2446:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a244a:	f7ff b8cd 	b.w	80a15e8 <HAL_GPIO_Write>
 80a244e:	bd38      	pop	{r3, r4, r5, pc}

080a2450 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

#if !HAL_USE_SOCKET_HAL_POSIX
const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a2450:	b513      	push	{r0, r1, r4, lr}
 80a2452:	4c08      	ldr	r4, [pc, #32]	; (80a2474 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a2454:	2300      	movs	r3, #0
 80a2456:	461a      	mov	r2, r3
 80a2458:	4619      	mov	r1, r3
 80a245a:	9300      	str	r3, [sp, #0]
 80a245c:	4620      	mov	r0, r4
 80a245e:	f7ff fd13 	bl	80a1e88 <_ZN9IPAddressC1Ehhhh>
 80a2462:	4620      	mov	r0, r4
 80a2464:	4a04      	ldr	r2, [pc, #16]	; (80a2478 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a2466:	4905      	ldr	r1, [pc, #20]	; (80a247c <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a2468:	b002      	add	sp, #8
 80a246a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a246e:	f000 b847 	b.w	80a2500 <__aeabi_atexit>
 80a2472:	bf00      	nop
 80a2474:	200005a0 	.word	0x200005a0
 80a2478:	200000d8 	.word	0x200000d8
 80a247c:	080a1ddb 	.word	0x080a1ddb

080a2480 <_Z17acquireWireBufferv>:
}

} // anonymous

HAL_I2C_Config __attribute__((weak)) acquireWireBuffer()
{
 80a2480:	b570      	push	{r4, r5, r6, lr}
 80a2482:	4604      	mov	r4, r0
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a2484:	2514      	movs	r5, #20
 80a2486:	462a      	mov	r2, r5

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a2488:	4e09      	ldr	r6, [pc, #36]	; (80a24b0 <_Z17acquireWireBufferv+0x30>)
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a248a:	2100      	movs	r1, #0
 80a248c:	f000 f9bb 	bl	80a2806 <memset>
 80a2490:	8025      	strh	r5, [r4, #0]
 80a2492:	2520      	movs	r5, #32

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a2494:	4631      	mov	r1, r6
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a2496:	60a5      	str	r5, [r4, #8]
 80a2498:	6125      	str	r5, [r4, #16]

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a249a:	4628      	mov	r0, r5
 80a249c:	f000 f840 	bl	80a2520 <_ZnajRKSt9nothrow_t>
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a24a0:	4631      	mov	r1, r6
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a24a2:	6060      	str	r0, [r4, #4]
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a24a4:	4628      	mov	r0, r5
 80a24a6:	f000 f83b 	bl	80a2520 <_ZnajRKSt9nothrow_t>
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a24aa:	60e0      	str	r0, [r4, #12]
} // anonymous

HAL_I2C_Config __attribute__((weak)) acquireWireBuffer()
{
	return defaultWireConfig();
}
 80a24ac:	4620      	mov	r0, r4
 80a24ae:	bd70      	pop	{r4, r5, r6, pc}
 80a24b0:	080a7f38 	.word	0x080a7f38

080a24b4 <_Z19__fetch_global_Wirev>:
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
 80a24b4:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a24b6:	4d0e      	ldr	r5, [pc, #56]	; (80a24f0 <_Z19__fetch_global_Wirev+0x3c>)
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
 80a24b8:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a24ba:	6829      	ldr	r1, [r5, #0]
 80a24bc:	f011 0401 	ands.w	r4, r1, #1
 80a24c0:	d113      	bne.n	80a24ea <_Z19__fetch_global_Wirev+0x36>
 80a24c2:	4628      	mov	r0, r5
 80a24c4:	f7fd fdeb 	bl	80a009e <__cxa_guard_acquire>
 80a24c8:	b178      	cbz	r0, 80a24ea <_Z19__fetch_global_Wirev+0x36>
 80a24ca:	a801      	add	r0, sp, #4
 80a24cc:	f7ff ffd8 	bl	80a2480 <_Z17acquireWireBufferv>
 80a24d0:	aa01      	add	r2, sp, #4
 80a24d2:	4621      	mov	r1, r4
 80a24d4:	4807      	ldr	r0, [pc, #28]	; (80a24f4 <_Z19__fetch_global_Wirev+0x40>)
 80a24d6:	f7ff fe5f 	bl	80a2198 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>
 80a24da:	4628      	mov	r0, r5
 80a24dc:	f7fd fde4 	bl	80a00a8 <__cxa_guard_release>
 80a24e0:	4a05      	ldr	r2, [pc, #20]	; (80a24f8 <_Z19__fetch_global_Wirev+0x44>)
 80a24e2:	4906      	ldr	r1, [pc, #24]	; (80a24fc <_Z19__fetch_global_Wirev+0x48>)
 80a24e4:	4803      	ldr	r0, [pc, #12]	; (80a24f4 <_Z19__fetch_global_Wirev+0x40>)
 80a24e6:	f000 f80b 	bl	80a2500 <__aeabi_atexit>
	return wire;
}
 80a24ea:	4802      	ldr	r0, [pc, #8]	; (80a24f4 <_Z19__fetch_global_Wirev+0x40>)
 80a24ec:	b007      	add	sp, #28
 80a24ee:	bd30      	pop	{r4, r5, pc}
 80a24f0:	200005b8 	.word	0x200005b8
 80a24f4:	200005bc 	.word	0x200005bc
 80a24f8:	200000d8 	.word	0x200000d8
 80a24fc:	080a2141 	.word	0x080a2141

080a2500 <__aeabi_atexit>:
 80a2500:	460b      	mov	r3, r1
 80a2502:	4601      	mov	r1, r0
 80a2504:	4618      	mov	r0, r3
 80a2506:	f000 b965 	b.w	80a27d4 <__cxa_atexit>
	...

080a250c <_ZSt15get_new_handlerv>:
 80a250c:	4b02      	ldr	r3, [pc, #8]	; (80a2518 <_ZSt15get_new_handlerv+0xc>)
 80a250e:	6818      	ldr	r0, [r3, #0]
 80a2510:	f3bf 8f5f 	dmb	sy
 80a2514:	4770      	bx	lr
 80a2516:	bf00      	nop
 80a2518:	200005d0 	.word	0x200005d0

080a251c <_ZdlPvj>:
 80a251c:	f7fd bdbd 	b.w	80a009a <_ZdlPv>

080a2520 <_ZnajRKSt9nothrow_t>:
 80a2520:	f000 b800 	b.w	80a2524 <_ZnwjRKSt9nothrow_t>

080a2524 <_ZnwjRKSt9nothrow_t>:
 80a2524:	b510      	push	{r4, lr}
 80a2526:	2800      	cmp	r0, #0
 80a2528:	bf14      	ite	ne
 80a252a:	4604      	movne	r4, r0
 80a252c:	2401      	moveq	r4, #1
 80a252e:	4620      	mov	r0, r4
 80a2530:	f7ff f9d8 	bl	80a18e4 <malloc>
 80a2534:	b920      	cbnz	r0, 80a2540 <_ZnwjRKSt9nothrow_t+0x1c>
 80a2536:	f7ff ffe9 	bl	80a250c <_ZSt15get_new_handlerv>
 80a253a:	b108      	cbz	r0, 80a2540 <_ZnwjRKSt9nothrow_t+0x1c>
 80a253c:	4780      	blx	r0
 80a253e:	e7f6      	b.n	80a252e <_ZnwjRKSt9nothrow_t+0xa>
 80a2540:	bd10      	pop	{r4, pc}
	...

080a2544 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a2544:	4b18      	ldr	r3, [pc, #96]	; (80a25a8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a2546:	681a      	ldr	r2, [r3, #0]
 80a2548:	07d1      	lsls	r1, r2, #31
 80a254a:	bf5c      	itt	pl
 80a254c:	2201      	movpl	r2, #1
 80a254e:	601a      	strpl	r2, [r3, #0]
 80a2550:	4b16      	ldr	r3, [pc, #88]	; (80a25ac <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a2552:	681a      	ldr	r2, [r3, #0]
 80a2554:	07d2      	lsls	r2, r2, #31
 80a2556:	bf5c      	itt	pl
 80a2558:	2201      	movpl	r2, #1
 80a255a:	601a      	strpl	r2, [r3, #0]
 80a255c:	4b14      	ldr	r3, [pc, #80]	; (80a25b0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a255e:	681a      	ldr	r2, [r3, #0]
 80a2560:	07d0      	lsls	r0, r2, #31
 80a2562:	bf5c      	itt	pl
 80a2564:	2201      	movpl	r2, #1
 80a2566:	601a      	strpl	r2, [r3, #0]
 80a2568:	4b12      	ldr	r3, [pc, #72]	; (80a25b4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a256a:	681a      	ldr	r2, [r3, #0]
 80a256c:	07d1      	lsls	r1, r2, #31
 80a256e:	bf5c      	itt	pl
 80a2570:	2201      	movpl	r2, #1
 80a2572:	601a      	strpl	r2, [r3, #0]
 80a2574:	4b10      	ldr	r3, [pc, #64]	; (80a25b8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a2576:	681a      	ldr	r2, [r3, #0]
 80a2578:	07d2      	lsls	r2, r2, #31
 80a257a:	bf5c      	itt	pl
 80a257c:	2201      	movpl	r2, #1
 80a257e:	601a      	strpl	r2, [r3, #0]
 80a2580:	4b0e      	ldr	r3, [pc, #56]	; (80a25bc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a2582:	681a      	ldr	r2, [r3, #0]
 80a2584:	07d0      	lsls	r0, r2, #31
 80a2586:	bf5c      	itt	pl
 80a2588:	2201      	movpl	r2, #1
 80a258a:	601a      	strpl	r2, [r3, #0]
 80a258c:	4b0c      	ldr	r3, [pc, #48]	; (80a25c0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a258e:	681a      	ldr	r2, [r3, #0]
 80a2590:	07d1      	lsls	r1, r2, #31
 80a2592:	bf5c      	itt	pl
 80a2594:	2201      	movpl	r2, #1
 80a2596:	601a      	strpl	r2, [r3, #0]
 80a2598:	4b0a      	ldr	r3, [pc, #40]	; (80a25c4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a259a:	681a      	ldr	r2, [r3, #0]
 80a259c:	07d2      	lsls	r2, r2, #31
 80a259e:	bf5c      	itt	pl
 80a25a0:	2201      	movpl	r2, #1
 80a25a2:	601a      	strpl	r2, [r3, #0]
 80a25a4:	4770      	bx	lr
 80a25a6:	bf00      	nop
 80a25a8:	200005f0 	.word	0x200005f0
 80a25ac:	200005ec 	.word	0x200005ec
 80a25b0:	200005e8 	.word	0x200005e8
 80a25b4:	200005e4 	.word	0x200005e4
 80a25b8:	200005e0 	.word	0x200005e0
 80a25bc:	200005dc 	.word	0x200005dc
 80a25c0:	200005d8 	.word	0x200005d8
 80a25c4:	200005d4 	.word	0x200005d4

080a25c8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a25c8:	4b24      	ldr	r3, [pc, #144]	; (80a265c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a25ca:	681a      	ldr	r2, [r3, #0]
 80a25cc:	07d0      	lsls	r0, r2, #31
 80a25ce:	bf5c      	itt	pl
 80a25d0:	2201      	movpl	r2, #1
 80a25d2:	601a      	strpl	r2, [r3, #0]
 80a25d4:	4b22      	ldr	r3, [pc, #136]	; (80a2660 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a25d6:	681a      	ldr	r2, [r3, #0]
 80a25d8:	07d1      	lsls	r1, r2, #31
 80a25da:	bf5c      	itt	pl
 80a25dc:	2201      	movpl	r2, #1
 80a25de:	601a      	strpl	r2, [r3, #0]
 80a25e0:	4b20      	ldr	r3, [pc, #128]	; (80a2664 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a25e2:	681a      	ldr	r2, [r3, #0]
 80a25e4:	07d2      	lsls	r2, r2, #31
 80a25e6:	bf5c      	itt	pl
 80a25e8:	2201      	movpl	r2, #1
 80a25ea:	601a      	strpl	r2, [r3, #0]
 80a25ec:	4b1e      	ldr	r3, [pc, #120]	; (80a2668 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a25ee:	681a      	ldr	r2, [r3, #0]
 80a25f0:	07d0      	lsls	r0, r2, #31
 80a25f2:	bf5c      	itt	pl
 80a25f4:	2201      	movpl	r2, #1
 80a25f6:	601a      	strpl	r2, [r3, #0]
 80a25f8:	4b1c      	ldr	r3, [pc, #112]	; (80a266c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a25fa:	681a      	ldr	r2, [r3, #0]
 80a25fc:	07d1      	lsls	r1, r2, #31
 80a25fe:	bf5c      	itt	pl
 80a2600:	2201      	movpl	r2, #1
 80a2602:	601a      	strpl	r2, [r3, #0]
 80a2604:	4b1a      	ldr	r3, [pc, #104]	; (80a2670 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a2606:	681a      	ldr	r2, [r3, #0]
 80a2608:	07d2      	lsls	r2, r2, #31
 80a260a:	bf5c      	itt	pl
 80a260c:	2201      	movpl	r2, #1
 80a260e:	601a      	strpl	r2, [r3, #0]
 80a2610:	4b18      	ldr	r3, [pc, #96]	; (80a2674 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a2612:	681a      	ldr	r2, [r3, #0]
 80a2614:	07d0      	lsls	r0, r2, #31
 80a2616:	bf5c      	itt	pl
 80a2618:	2201      	movpl	r2, #1
 80a261a:	601a      	strpl	r2, [r3, #0]
 80a261c:	4b16      	ldr	r3, [pc, #88]	; (80a2678 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a261e:	681a      	ldr	r2, [r3, #0]
 80a2620:	07d1      	lsls	r1, r2, #31
 80a2622:	bf5c      	itt	pl
 80a2624:	2201      	movpl	r2, #1
 80a2626:	601a      	strpl	r2, [r3, #0]
 80a2628:	4b14      	ldr	r3, [pc, #80]	; (80a267c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a262a:	681a      	ldr	r2, [r3, #0]
 80a262c:	07d2      	lsls	r2, r2, #31
 80a262e:	bf5c      	itt	pl
 80a2630:	2201      	movpl	r2, #1
 80a2632:	601a      	strpl	r2, [r3, #0]
 80a2634:	4b12      	ldr	r3, [pc, #72]	; (80a2680 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a2636:	681a      	ldr	r2, [r3, #0]
 80a2638:	07d0      	lsls	r0, r2, #31
 80a263a:	bf5c      	itt	pl
 80a263c:	2201      	movpl	r2, #1
 80a263e:	601a      	strpl	r2, [r3, #0]
 80a2640:	4b10      	ldr	r3, [pc, #64]	; (80a2684 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a2642:	681a      	ldr	r2, [r3, #0]
 80a2644:	07d1      	lsls	r1, r2, #31
 80a2646:	bf5c      	itt	pl
 80a2648:	2201      	movpl	r2, #1
 80a264a:	601a      	strpl	r2, [r3, #0]
 80a264c:	4b0e      	ldr	r3, [pc, #56]	; (80a2688 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a264e:	681a      	ldr	r2, [r3, #0]
 80a2650:	07d2      	lsls	r2, r2, #31
 80a2652:	bf5c      	itt	pl
 80a2654:	2201      	movpl	r2, #1
 80a2656:	601a      	strpl	r2, [r3, #0]
 80a2658:	4770      	bx	lr
 80a265a:	bf00      	nop
 80a265c:	20000620 	.word	0x20000620
 80a2660:	2000061c 	.word	0x2000061c
 80a2664:	20000618 	.word	0x20000618
 80a2668:	20000614 	.word	0x20000614
 80a266c:	20000610 	.word	0x20000610
 80a2670:	2000060c 	.word	0x2000060c
 80a2674:	20000608 	.word	0x20000608
 80a2678:	20000604 	.word	0x20000604
 80a267c:	20000600 	.word	0x20000600
 80a2680:	200005fc 	.word	0x200005fc
 80a2684:	200005f8 	.word	0x200005f8
 80a2688:	200005f4 	.word	0x200005f4

080a268c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a268c:	4b24      	ldr	r3, [pc, #144]	; (80a2720 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a268e:	681a      	ldr	r2, [r3, #0]
 80a2690:	07d0      	lsls	r0, r2, #31
 80a2692:	bf5c      	itt	pl
 80a2694:	2201      	movpl	r2, #1
 80a2696:	601a      	strpl	r2, [r3, #0]
 80a2698:	4b22      	ldr	r3, [pc, #136]	; (80a2724 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a269a:	681a      	ldr	r2, [r3, #0]
 80a269c:	07d1      	lsls	r1, r2, #31
 80a269e:	bf5c      	itt	pl
 80a26a0:	2201      	movpl	r2, #1
 80a26a2:	601a      	strpl	r2, [r3, #0]
 80a26a4:	4b20      	ldr	r3, [pc, #128]	; (80a2728 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a26a6:	681a      	ldr	r2, [r3, #0]
 80a26a8:	07d2      	lsls	r2, r2, #31
 80a26aa:	bf5c      	itt	pl
 80a26ac:	2201      	movpl	r2, #1
 80a26ae:	601a      	strpl	r2, [r3, #0]
 80a26b0:	4b1e      	ldr	r3, [pc, #120]	; (80a272c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a26b2:	681a      	ldr	r2, [r3, #0]
 80a26b4:	07d0      	lsls	r0, r2, #31
 80a26b6:	bf5c      	itt	pl
 80a26b8:	2201      	movpl	r2, #1
 80a26ba:	601a      	strpl	r2, [r3, #0]
 80a26bc:	4b1c      	ldr	r3, [pc, #112]	; (80a2730 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a26be:	681a      	ldr	r2, [r3, #0]
 80a26c0:	07d1      	lsls	r1, r2, #31
 80a26c2:	bf5c      	itt	pl
 80a26c4:	2201      	movpl	r2, #1
 80a26c6:	601a      	strpl	r2, [r3, #0]
 80a26c8:	4b1a      	ldr	r3, [pc, #104]	; (80a2734 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a26ca:	681a      	ldr	r2, [r3, #0]
 80a26cc:	07d2      	lsls	r2, r2, #31
 80a26ce:	bf5c      	itt	pl
 80a26d0:	2201      	movpl	r2, #1
 80a26d2:	601a      	strpl	r2, [r3, #0]
 80a26d4:	4b18      	ldr	r3, [pc, #96]	; (80a2738 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a26d6:	681a      	ldr	r2, [r3, #0]
 80a26d8:	07d0      	lsls	r0, r2, #31
 80a26da:	bf5c      	itt	pl
 80a26dc:	2201      	movpl	r2, #1
 80a26de:	601a      	strpl	r2, [r3, #0]
 80a26e0:	4b16      	ldr	r3, [pc, #88]	; (80a273c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a26e2:	681a      	ldr	r2, [r3, #0]
 80a26e4:	07d1      	lsls	r1, r2, #31
 80a26e6:	bf5c      	itt	pl
 80a26e8:	2201      	movpl	r2, #1
 80a26ea:	601a      	strpl	r2, [r3, #0]
 80a26ec:	4b14      	ldr	r3, [pc, #80]	; (80a2740 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a26ee:	681a      	ldr	r2, [r3, #0]
 80a26f0:	07d2      	lsls	r2, r2, #31
 80a26f2:	bf5c      	itt	pl
 80a26f4:	2201      	movpl	r2, #1
 80a26f6:	601a      	strpl	r2, [r3, #0]
 80a26f8:	4b12      	ldr	r3, [pc, #72]	; (80a2744 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a26fa:	681a      	ldr	r2, [r3, #0]
 80a26fc:	07d0      	lsls	r0, r2, #31
 80a26fe:	bf5c      	itt	pl
 80a2700:	2201      	movpl	r2, #1
 80a2702:	601a      	strpl	r2, [r3, #0]
 80a2704:	4b10      	ldr	r3, [pc, #64]	; (80a2748 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a2706:	681a      	ldr	r2, [r3, #0]
 80a2708:	07d1      	lsls	r1, r2, #31
 80a270a:	bf5c      	itt	pl
 80a270c:	2201      	movpl	r2, #1
 80a270e:	601a      	strpl	r2, [r3, #0]
 80a2710:	4b0e      	ldr	r3, [pc, #56]	; (80a274c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a2712:	681a      	ldr	r2, [r3, #0]
 80a2714:	07d2      	lsls	r2, r2, #31
 80a2716:	bf5c      	itt	pl
 80a2718:	2201      	movpl	r2, #1
 80a271a:	601a      	strpl	r2, [r3, #0]
 80a271c:	4770      	bx	lr
 80a271e:	bf00      	nop
 80a2720:	20000650 	.word	0x20000650
 80a2724:	2000064c 	.word	0x2000064c
 80a2728:	20000648 	.word	0x20000648
 80a272c:	20000644 	.word	0x20000644
 80a2730:	20000640 	.word	0x20000640
 80a2734:	2000063c 	.word	0x2000063c
 80a2738:	20000638 	.word	0x20000638
 80a273c:	20000634 	.word	0x20000634
 80a2740:	20000630 	.word	0x20000630
 80a2744:	2000062c 	.word	0x2000062c
 80a2748:	20000628 	.word	0x20000628
 80a274c:	20000624 	.word	0x20000624

080a2750 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a2750:	4b18      	ldr	r3, [pc, #96]	; (80a27b4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a2752:	681a      	ldr	r2, [r3, #0]
 80a2754:	07d1      	lsls	r1, r2, #31
 80a2756:	bf5c      	itt	pl
 80a2758:	2201      	movpl	r2, #1
 80a275a:	601a      	strpl	r2, [r3, #0]
 80a275c:	4b16      	ldr	r3, [pc, #88]	; (80a27b8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a275e:	681a      	ldr	r2, [r3, #0]
 80a2760:	07d2      	lsls	r2, r2, #31
 80a2762:	bf5c      	itt	pl
 80a2764:	2201      	movpl	r2, #1
 80a2766:	601a      	strpl	r2, [r3, #0]
 80a2768:	4b14      	ldr	r3, [pc, #80]	; (80a27bc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a276a:	681a      	ldr	r2, [r3, #0]
 80a276c:	07d0      	lsls	r0, r2, #31
 80a276e:	bf5c      	itt	pl
 80a2770:	2201      	movpl	r2, #1
 80a2772:	601a      	strpl	r2, [r3, #0]
 80a2774:	4b12      	ldr	r3, [pc, #72]	; (80a27c0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a2776:	681a      	ldr	r2, [r3, #0]
 80a2778:	07d1      	lsls	r1, r2, #31
 80a277a:	bf5c      	itt	pl
 80a277c:	2201      	movpl	r2, #1
 80a277e:	601a      	strpl	r2, [r3, #0]
 80a2780:	4b10      	ldr	r3, [pc, #64]	; (80a27c4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a2782:	681a      	ldr	r2, [r3, #0]
 80a2784:	07d2      	lsls	r2, r2, #31
 80a2786:	bf5c      	itt	pl
 80a2788:	2201      	movpl	r2, #1
 80a278a:	601a      	strpl	r2, [r3, #0]
 80a278c:	4b0e      	ldr	r3, [pc, #56]	; (80a27c8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a278e:	681a      	ldr	r2, [r3, #0]
 80a2790:	07d0      	lsls	r0, r2, #31
 80a2792:	bf5c      	itt	pl
 80a2794:	2201      	movpl	r2, #1
 80a2796:	601a      	strpl	r2, [r3, #0]
 80a2798:	4b0c      	ldr	r3, [pc, #48]	; (80a27cc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a279a:	681a      	ldr	r2, [r3, #0]
 80a279c:	07d1      	lsls	r1, r2, #31
 80a279e:	bf5c      	itt	pl
 80a27a0:	2201      	movpl	r2, #1
 80a27a2:	601a      	strpl	r2, [r3, #0]
 80a27a4:	4b0a      	ldr	r3, [pc, #40]	; (80a27d0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a27a6:	681a      	ldr	r2, [r3, #0]
 80a27a8:	07d2      	lsls	r2, r2, #31
 80a27aa:	bf5c      	itt	pl
 80a27ac:	2201      	movpl	r2, #1
 80a27ae:	601a      	strpl	r2, [r3, #0]
 80a27b0:	4770      	bx	lr
 80a27b2:	bf00      	nop
 80a27b4:	20000670 	.word	0x20000670
 80a27b8:	2000066c 	.word	0x2000066c
 80a27bc:	20000668 	.word	0x20000668
 80a27c0:	20000664 	.word	0x20000664
 80a27c4:	20000660 	.word	0x20000660
 80a27c8:	2000065c 	.word	0x2000065c
 80a27cc:	20000658 	.word	0x20000658
 80a27d0:	20000654 	.word	0x20000654

080a27d4 <__cxa_atexit>:
 80a27d4:	b510      	push	{r4, lr}
 80a27d6:	4c05      	ldr	r4, [pc, #20]	; (80a27ec <__cxa_atexit+0x18>)
 80a27d8:	4613      	mov	r3, r2
 80a27da:	b12c      	cbz	r4, 80a27e8 <__cxa_atexit+0x14>
 80a27dc:	460a      	mov	r2, r1
 80a27de:	4601      	mov	r1, r0
 80a27e0:	2002      	movs	r0, #2
 80a27e2:	f3af 8000 	nop.w
 80a27e6:	bd10      	pop	{r4, pc}
 80a27e8:	4620      	mov	r0, r4
 80a27ea:	bd10      	pop	{r4, pc}
 80a27ec:	00000000 	.word	0x00000000

080a27f0 <memcpy>:
 80a27f0:	b510      	push	{r4, lr}
 80a27f2:	1e43      	subs	r3, r0, #1
 80a27f4:	440a      	add	r2, r1
 80a27f6:	4291      	cmp	r1, r2
 80a27f8:	d004      	beq.n	80a2804 <memcpy+0x14>
 80a27fa:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a27fe:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a2802:	e7f8      	b.n	80a27f6 <memcpy+0x6>
 80a2804:	bd10      	pop	{r4, pc}

080a2806 <memset>:
 80a2806:	4603      	mov	r3, r0
 80a2808:	4402      	add	r2, r0
 80a280a:	4293      	cmp	r3, r2
 80a280c:	d002      	beq.n	80a2814 <memset+0xe>
 80a280e:	f803 1b01 	strb.w	r1, [r3], #1
 80a2812:	e7fa      	b.n	80a280a <memset+0x4>
 80a2814:	4770      	bx	lr
	...

080a2818 <srand>:
 80a2818:	b538      	push	{r3, r4, r5, lr}
 80a281a:	4b12      	ldr	r3, [pc, #72]	; (80a2864 <srand+0x4c>)
 80a281c:	4605      	mov	r5, r0
 80a281e:	681c      	ldr	r4, [r3, #0]
 80a2820:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a2822:	b9d3      	cbnz	r3, 80a285a <srand+0x42>
 80a2824:	2018      	movs	r0, #24
 80a2826:	f7ff f85d 	bl	80a18e4 <malloc>
 80a282a:	f243 330e 	movw	r3, #13070	; 0x330e
 80a282e:	63a0      	str	r0, [r4, #56]	; 0x38
 80a2830:	8003      	strh	r3, [r0, #0]
 80a2832:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a2836:	8043      	strh	r3, [r0, #2]
 80a2838:	f241 2334 	movw	r3, #4660	; 0x1234
 80a283c:	8083      	strh	r3, [r0, #4]
 80a283e:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a2842:	80c3      	strh	r3, [r0, #6]
 80a2844:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a2848:	8103      	strh	r3, [r0, #8]
 80a284a:	2305      	movs	r3, #5
 80a284c:	8143      	strh	r3, [r0, #10]
 80a284e:	230b      	movs	r3, #11
 80a2850:	8183      	strh	r3, [r0, #12]
 80a2852:	2201      	movs	r2, #1
 80a2854:	2300      	movs	r3, #0
 80a2856:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a285a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a285c:	2200      	movs	r2, #0
 80a285e:	611d      	str	r5, [r3, #16]
 80a2860:	615a      	str	r2, [r3, #20]
 80a2862:	bd38      	pop	{r3, r4, r5, pc}
 80a2864:	200000d4 	.word	0x200000d4

080a2868 <rand>:
 80a2868:	4b19      	ldr	r3, [pc, #100]	; (80a28d0 <rand+0x68>)
 80a286a:	b510      	push	{r4, lr}
 80a286c:	681c      	ldr	r4, [r3, #0]
 80a286e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a2870:	b9d3      	cbnz	r3, 80a28a8 <rand+0x40>
 80a2872:	2018      	movs	r0, #24
 80a2874:	f7ff f836 	bl	80a18e4 <malloc>
 80a2878:	f243 330e 	movw	r3, #13070	; 0x330e
 80a287c:	63a0      	str	r0, [r4, #56]	; 0x38
 80a287e:	8003      	strh	r3, [r0, #0]
 80a2880:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a2884:	8043      	strh	r3, [r0, #2]
 80a2886:	f241 2334 	movw	r3, #4660	; 0x1234
 80a288a:	8083      	strh	r3, [r0, #4]
 80a288c:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a2890:	80c3      	strh	r3, [r0, #6]
 80a2892:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a2896:	8103      	strh	r3, [r0, #8]
 80a2898:	2305      	movs	r3, #5
 80a289a:	8143      	strh	r3, [r0, #10]
 80a289c:	230b      	movs	r3, #11
 80a289e:	8183      	strh	r3, [r0, #12]
 80a28a0:	2201      	movs	r2, #1
 80a28a2:	2300      	movs	r3, #0
 80a28a4:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a28a8:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80a28aa:	4c0a      	ldr	r4, [pc, #40]	; (80a28d4 <rand+0x6c>)
 80a28ac:	690b      	ldr	r3, [r1, #16]
 80a28ae:	6948      	ldr	r0, [r1, #20]
 80a28b0:	435c      	muls	r4, r3
 80a28b2:	4a09      	ldr	r2, [pc, #36]	; (80a28d8 <rand+0x70>)
 80a28b4:	fb02 4000 	mla	r0, r2, r0, r4
 80a28b8:	fba3 2302 	umull	r2, r3, r3, r2
 80a28bc:	3201      	adds	r2, #1
 80a28be:	4403      	add	r3, r0
 80a28c0:	f143 0300 	adc.w	r3, r3, #0
 80a28c4:	e9c1 2304 	strd	r2, r3, [r1, #16]
 80a28c8:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 80a28cc:	bd10      	pop	{r4, pc}
 80a28ce:	bf00      	nop
 80a28d0:	200000d4 	.word	0x200000d4
 80a28d4:	5851f42d 	.word	0x5851f42d
 80a28d8:	4c957f2d 	.word	0x4c957f2d

080a28dc <strcmp>:
 80a28dc:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a28e0:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a28e4:	2a01      	cmp	r2, #1
 80a28e6:	bf28      	it	cs
 80a28e8:	429a      	cmpcs	r2, r3
 80a28ea:	d0f7      	beq.n	80a28dc <strcmp>
 80a28ec:	1ad0      	subs	r0, r2, r3
 80a28ee:	4770      	bx	lr

080a28f0 <strlen>:
 80a28f0:	4603      	mov	r3, r0
 80a28f2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a28f6:	2a00      	cmp	r2, #0
 80a28f8:	d1fb      	bne.n	80a28f2 <strlen+0x2>
 80a28fa:	1a18      	subs	r0, r3, r0
 80a28fc:	3801      	subs	r0, #1
 80a28fe:	4770      	bx	lr

080a2900 <dynalib_user>:
 80a2900:	001d 080a 005d 080a 0089 080a 008d 080a     ....]...........
 80a2910:	0000 0000                                   ....

080a2914 <_ZL9script_js>:
 80a2914:	6176 2072 6162 6573 755f 6c72 273d 7468     var base_url='ht
 80a2924:	7074 2f3a 312f 3239 312e 3836 302e 312e     tp://192.168.0.1
 80a2934:	272f 763b 7261 6e20 7465 6f77 6b72 6c5f     /';var network_l
 80a2944:	7369 3b74 6176 2072 7570 6c62 6369 6b5f     ist;var public_k
 80a2954:	7965 763b 7261 7220 6173 6e3d 7765 5220     ey;var rsa=new R
 80a2964:	4153 654b 2879 3b29 6176 2072 6373 6e61     SAKey();var scan
 80a2974:	7542 7474 6e6f 643d 636f 6d75 6e65 2e74     Button=document.
 80a2984:	6567 4574 656c 656d 746e 7942 6449 2728     getElementById('
 80a2994:	6373 6e61 622d 7475 6f74 276e 3b29 6176     scan-button');va
 80a29a4:	2072 6f63 6e6e 6365 4274 7475 6f74 3d6e     r connectButton=
 80a29b4:	6f64 7563 656d 746e 672e 7465 6c45 6d65     document.getElem
 80a29c4:	6e65 4274 4979 2864 6327 6e6f 656e 7463     entById('connect
 80a29d4:	622d 7475 6f74 276e 3b29 6176 2072 6f63     -button');var co
 80a29e4:	7970 7542 7474 6e6f 643d 636f 6d75 6e65     pyButton=documen
 80a29f4:	2e74 6567 4574 656c 656d 746e 7942 6449     t.getElementById
 80a2a04:	2728 6f63 7970 622d 7475 6f74 276e 3b29     ('copy-button');
 80a2a14:	6176 2072 6873 776f 7542 7474 6e6f 643d     var showButton=d
 80a2a24:	636f 6d75 6e65 2e74 6567 4574 656c 656d     ocument.getEleme
 80a2a34:	746e 7942 6449 2728 6873 776f 622d 7475     ntById('show-but
 80a2a44:	6f74 276e 3b29 6176 2072 6564 6976 6563     ton');var device
 80a2a54:	4449 643d 636f 6d75 6e65 2e74 6567 4574     ID=document.getE
 80a2a64:	656c 656d 746e 7942 6449 2728 6564 6976     lementById('devi
 80a2a74:	6563 692d 2764 3b29 6176 2072 6f63 6e6e     ce-id');var conn
 80a2a84:	6365 4674 726f 3d6d 6f64 7563 656d 746e     ectForm=document
 80a2a94:	672e 7465 6c45 6d65 6e65 4274 4979 2864     .getElementById(
 80a2aa4:	6327 6e6f 656e 7463 662d 726f 276d 3b29     'connect-form');
 80a2ab4:	6176 2072 7570 6c62 6369 6b5f 7965 635f     var public_key_c
 80a2ac4:	6c61 626c 6361 3d6b 737b 6375 6563 7373     allback={success
 80a2ad4:	663a 6e75 7463 6f69 286e 2961 637b 6e6f     :function(a){con
 80a2ae4:	6f73 656c 6c2e 676f 2728 7550 6c62 6369     sole.log('Public
 80a2af4:	6b20 7965 203a 2b27 2e61 2962 703b 6275      key: '+a.b);pub
 80a2b04:	696c 5f63 656b 3d79 2e61 3b62 7372 2e61     lic_key=a.b;rsa.
 80a2b14:	6573 5074 6275 696c 2863 7570 6c62 6369     setPublic(public
 80a2b24:	6b5f 7965 732e 6275 7473 6972 676e 3528     _key.substring(5
 80a2b34:	2c38 3835 322b 3635 2c29 7570 6c62 6369     8,58+256),public
 80a2b44:	6b5f 7965 732e 6275 7473 6972 676e 3328     _key.substring(3
 80a2b54:	3831 332c 3831 362b 2929 7d3b 652c 7272     18,318+6));},err
 80a2b64:	726f 663a 6e75 7463 6f69 286e 2c61 2962     or:function(a,b)
 80a2b74:	637b 6e6f 6f73 656c 6c2e 676f 6128 3b29     {console.log(a);
 80a2b84:	6977 646e 776f 612e 656c 7472 2728 6854     window.alert('Th
 80a2b94:	7265 2065 6177 2073 2061 7270 626f 656c     ere was a proble
 80a2ba4:	206d 6566 6374 6968 676e 6920 706d 726f     m fetching impor
 80a2bb4:	6174 746e 6920 666e 726f 616d 6974 6e6f     tant information
 80a2bc4:	6620 6f72 206d 6f79 7275 6420 7665 6369      from your devic
 80a2bd4:	2e65 5020 656c 7361 2065 6576 6972 7966     e. Please verify
 80a2be4:	7920 756f 2072 6f63 6e6e 6365 6974 6e6f      your connection
 80a2bf4:	202c 6874 6e65 7220 6c65 616f 2064 6874     , then reload th
 80a2c04:	7369 7020 6761 2e65 2927 7d3b 3b7d 6176     is page.');}};va
 80a2c14:	2072 6564 6976 6563 695f 5f64 6163 6c6c     r device_id_call
 80a2c24:	6162 6b63 7b3d 7573 6363 7365 3a73 7566     back={success:fu
 80a2c34:	636e 6974 6e6f 6128 7b29 6176 2072 3d62     nction(a){var b=
 80a2c44:	2e61 6469 643b 7665 6369 4965 2e44 6176     a.id;deviceID.va
 80a2c54:	756c 3d65 3b62 2c7d 7265 6f72 3a72 7566     lue=b;},error:fu
 80a2c64:	636e 6974 6e6f 6128 622c 7b29 6f63 736e     nction(a,b){cons
 80a2c74:	6c6f 2e65 6f6c 2867 2961 763b 7261 6320     ole.log(a);var c
 80a2c84:	273d 4f43 4d4d 4e55 4349 5441 4f49 5f4e     ='COMMUNICATION_
 80a2c94:	5245 4f52 2752 643b 7665 6369 4965 2e44     ERROR';deviceID.
 80a2ca4:	6176 756c 3d65 3b63 7d7d 763b 7261 7320     value=c;}};var s
 80a2cb4:	6163 3d6e 7566 636e 6974 6e6f 2928 637b     can=function(){c
 80a2cc4:	6e6f 6f73 656c 6c2e 676f 2728 6353 6e61     onsole.log('Scan
 80a2cd4:	696e 676e 2e2e 212e 2927 643b 7369 6261     ning...!');disab
 80a2ce4:	656c 7542 7474 6e6f 2873 3b29 6373 6e61     leButtons();scan
 80a2cf4:	7542 7474 6e6f 692e 6e6e 7265 5448 4c4d     Button.innerHTML
 80a2d04:	273d 6353 6e61 696e 676e 2e2e 272e 633b     ='Scanning...';c
 80a2d14:	6e6f 656e 7463 7542 7474 6e6f 692e 6e6e     onnectButton.inn
 80a2d24:	7265 5448 4c4d 273d 6f43 6e6e 6365 2774     erHTML='Connect'
 80a2d34:	643b 636f 6d75 6e65 2e74 6567 4574 656c     ;document.getEle
 80a2d44:	656d 746e 7942 6449 2728 6f63 6e6e 6365     mentById('connec
 80a2d54:	2d74 6964 2776 2e29 7473 6c79 2e65 6964     t-div').style.di
 80a2d64:	7073 616c 3d79 6e27 6e6f 2765 643b 636f     splay='none';doc
 80a2d74:	6d75 6e65 2e74 6567 4574 656c 656d 746e     ument.getElement
 80a2d84:	7942 6449 2728 656e 7774 726f 736b 642d     ById('networks-d
 80a2d94:	7669 2927 732e 7974 656c 642e 7369 6c70     iv').style.displ
 80a2da4:	7961 273d 6f6e 656e 3b27 6567 5274 7165     ay='none';getReq
 80a2db4:	6575 7473 6228 7361 5f65 7275 2b6c 7327     uest(base_url+'s
 80a2dc4:	6163 2d6e 7061 2c27 6373 6e61 635f 6c61     can-ap',scan_cal
 80a2dd4:	626c 6361 296b 7d3b 763b 7261 7320 6163     lback);};var sca
 80a2de4:	5f6e 6163 6c6c 6162 6b63 7b3d 7573 6363     n_callback={succ
 80a2df4:	7365 3a73 7566 636e 6974 6e6f 6128 7b29     ess:function(a){
 80a2e04:	656e 7774 726f 5f6b 696c 7473 613d 732e     network_list=a.s
 80a2e14:	6163 736e 633b 6e6f 6f73 656c 6c2e 676f     cans;console.log
 80a2e24:	2728 2049 6f66 6e75 3a64 2927 763b 7261     ('I found:');var
 80a2e34:	6220 643d 636f 6d75 6e65 2e74 6567 4574      b=document.getE
 80a2e44:	656c 656d 746e 7942 6449 2728 656e 7774     lementById('netw
 80a2e54:	726f 736b 642d 7669 2927 623b 692e 6e6e     orks-div');b.inn
 80a2e64:	7265 5448 4c4d 273d 3b27 6669 6e28 7465     erHTML='';if(net
 80a2e74:	6f77 6b72 6c5f 7369 2e74 656c 676e 6874     work_list.length
 80a2e84:	303e 6629 726f 7628 7261 6320 303d 633b     >0)for(var c=0;c
 80a2e94:	6e3c 7465 6f77 6b72 6c5f 7369 2e74 656c     <network_list.le
 80a2ea4:	676e 6874 633b 2b2b 7b29 7373 6469 6e3d     ngth;c++){ssid=n
 80a2eb4:	7465 6f77 6b72 6c5f 7369 5b74 5d63 732e     etwork_list[c].s
 80a2ec4:	6973 3b64 6f63 736e 6c6f 2e65 6f6c 2867     sid;console.log(
 80a2ed4:	656e 7774 726f 5f6b 696c 7473 635b 295d     network_list[c])
 80a2ee4:	613b 6464 775f 6669 5f69 706f 6974 6e6f     ;add_wifi_option
 80a2ef4:	6228 732c 6973 2964 643b 636f 6d75 6e65     (b,ssid);documen
 80a2f04:	2e74 6567 4574 656c 656d 746e 7942 6449     t.getElementById
 80a2f14:	2728 6f63 6e6e 6365 2d74 6964 2776 2e29     ('connect-div').
 80a2f24:	7473 6c79 2e65 6964 7073 616c 3d79 6227     style.display='b
 80a2f34:	6f6c 6b63 3b27 657d 736c 2065 2e62 6e69     lock';}else b.in
 80a2f44:	656e 4872 4d54 3d4c 3c27 2070 6c63 7361     nerHTML='<p clas
 80a2f54:	3d73 275c 6373 6e61 696e 676e 652d 7272     s=\'scanning-err
 80a2f64:	726f 275c 4e3e 206f 656e 7774 726f 736b     or\'>No networks
 80a2f74:	6620 756f 646e 3c2e 702f 273e 7d3b 652c      found.</p>';},e
 80a2f84:	7272 726f 663a 6e75 7463 6f69 286e 2961     rror:function(a)
 80a2f94:	637b 6e6f 6f73 656c 6c2e 676f 2728 6353     {console.log('Sc
 80a2fa4:	6e61 696e 676e 6520 7272 726f 273a 612b     anning error:'+a
 80a2fb4:	3b29 6f64 7563 656d 746e 672e 7465 6c45     );document.getEl
 80a2fc4:	6d65 6e65 4274 4979 2864 6e27 7465 6f77     ementById('netwo
 80a2fd4:	6b72 2d73 6964 2776 2e29 6e69 656e 4872     rks-div').innerH
 80a2fe4:	4d54 3d4c 3c27 2070 6c63 7361 3d73 275c     TML='<p class=\'
 80a2ff4:	6373 6e61 696e 676e 652d 7272 726f 275c     scanning-error\'
 80a3004:	533e 6163 6e6e 6e69 2067 7265 6f72 2e72     >Scanning error.
 80a3014:	2f3c 3e70 3b27 2c7d 6572 6167 6472 656c     </p>';},regardle
 80a3024:	7373 663a 6e75 7463 6f69 286e 7b29 6373     ss:function(){sc
 80a3034:	6e61 7542 7474 6e6f 692e 6e6e 7265 5448     anButton.innerHT
 80a3044:	4c4d 273d 6552 532d 6163 276e 653b 616e     ML='Re-Scan';ena
 80a3054:	6c62 4265 7475 6f74 736e 2928 643b 636f     bleButtons();doc
 80a3064:	6d75 6e65 2e74 6567 4574 656c 656d 746e     ument.getElement
 80a3074:	7942 6449 2728 656e 7774 726f 736b 642d     ById('networks-d
 80a3084:	7669 2927 732e 7974 656c 642e 7369 6c70     iv').style.displ
 80a3094:	7961 273d 6c62 636f 276b 7d3b 3b7d 6176     ay='block';}};va
 80a30a4:	2072 6f63 666e 6769 7275 3d65 7566 636e     r configure=func
 80a30b4:	6974 6e6f 6128 7b29 2e61 7270 7665 6e65     tion(a){a.preven
 80a30c4:	4474 6665 7561 746c 2928 763b 7261 6220     tDefault();var b
 80a30d4:	673d 7465 735f 6c65 6365 6574 5f64 656e     =get_selected_ne
 80a30e4:	7774 726f 286b 3b29 6176 2072 3d63 6f64     twork();var c=do
 80a30f4:	7563 656d 746e 672e 7465 6c45 6d65 6e65     cument.getElemen
 80a3104:	4274 4979 2864 7027 7361 7773 726f 2764     tById('password'
 80a3114:	2e29 6176 756c 3b65 6669 2128 2962 777b     ).value;if(!b){w
 80a3124:	6e69 6f64 2e77 6c61 7265 2874 5027 656c     indow.alert('Ple
 80a3134:	7361 2065 6573 656c 7463 6120 6e20 7465     ase select a net
 80a3144:	6f77 6b72 2721 3b29 6572 7574 6e72 6620     work!');return f
 80a3154:	6c61 6573 7d3b 6176 2072 3d64 697b 7864     alse;}var d={idx
 80a3164:	303a 732c 6973 3a64 2e62 7373 6469 702c     :0,ssid:b.ssid,p
 80a3174:	6477 723a 6173 652e 636e 7972 7470 6328     wd:rsa.encrypt(c
 80a3184:	2c29 6573 3a63 2e62 6573 2c63 6863 623a     ),sec:b.sec,ch:b
 80a3194:	632e 7d68 633b 6e6f 656e 7463 7542 7474     .ch};connectButt
 80a31a4:	6e6f 692e 6e6e 7265 5448 4c4d 273d 6553     on.innerHTML='Se
 80a31b4:	646e 6e69 2067 7263 6465 6e65 6974 6c61     nding credential
 80a31c4:	2e73 2e2e 3b27 6964 6173 6c62 4265 7475     s...';disableBut
 80a31d4:	6f74 736e 2928 633b 6e6f 6f73 656c 6c2e     tons();console.l
 80a31e4:	676f 2728 6553 646e 6e69 2067 7263 6465     og('Sending cred
 80a31f4:	6e65 6974 6c61 3a73 2720 4a2b 4f53 2e4e     entials: '+JSON.
 80a3204:	7473 6972 676e 6669 2879 2964 3b29 6f70     stringify(d));po
 80a3214:	7473 6552 7571 7365 2874 6162 6573 755f     stRequest(base_u
 80a3224:	6c72 272b 6f63 666e 6769 7275 2d65 7061     rl+'configure-ap
 80a3234:	2c27 2c64 6f63 666e 6769 7275 5f65 6163     ',d,configure_ca
 80a3244:	6c6c 6162 6b63 3b29 3b7d 6176 2072 6f63     llback);};var co
 80a3254:	666e 6769 7275 5f65 6163 6c6c 6162 6b63     nfigure_callback
 80a3264:	7b3d 7573 6363 7365 3a73 7566 636e 6974     ={success:functi
 80a3274:	6e6f 6128 7b29 6f63 736e 6c6f 2e65 6f6c     on(a){console.lo
 80a3284:	2867 4327 6572 6564 746e 6169 736c 7220     g('Credentials r
 80a3294:	6365 6965 6576 2e64 2927 633b 6e6f 656e     eceived.');conne
 80a32a4:	7463 7542 7474 6e6f 692e 6e6e 7265 5448     ctButton.innerHT
 80a32b4:	4c4d 273d 7243 6465 6e65 6974 6c61 2073     ML='Credentials 
 80a32c4:	6572 6563 7669 6465 2e2e 272e 703b 736f     received...';pos
 80a32d4:	5274 7165 6575 7473 6228 7361 5f65 7275     tRequest(base_ur
 80a32e4:	2b6c 6327 6e6f 656e 7463 612d 2770 7b2c     l+'connect-ap',{
 80a32f4:	6469 3a78 7d30 632c 6e6f 656e 7463 635f     idx:0},connect_c
 80a3304:	6c61 626c 6361 296b 7d3b 652c 7272 726f     allback);},error
 80a3314:	663a 6e75 7463 6f69 286e 2c61 2962 637b     :function(a,b){c
 80a3324:	6e6f 6f73 656c 6c2e 676f 2728 6f43 666e     onsole.log('Conf
 80a3334:	6769 7275 2065 7265 6f72 3a72 2720 612b     igure error: '+a
 80a3344:	3b29 6977 646e 776f 612e 656c 7472 2728     );window.alert('
 80a3354:	6854 2065 6f63 666e 6769 7275 7461 6f69     The configuratio
 80a3364:	206e 6f63 6d6d 6e61 2064 6166 6c69 6465     n command failed
 80a3374:	202c 6863 6365 206b 6874 7461 7920 756f     , check that you
 80a3384:	6120 6572 7320 6974 6c6c 7720 6c65 206c      are still well 
 80a3394:	6f63 6e6e 6365 6574 2064 6f74 7420 6568     connected to the
 80a33a4:	6420 7665 6369 5c65 7327 5720 4669 2069      device\'s WiFi 
 80a33b4:	6f68 7374 6f70 2074 6e61 2064 6572 7274     hotspot and retr
 80a33c4:	2e79 2927 633b 6e6f 656e 7463 7542 7474     y.');connectButt
 80a33d4:	6e6f 692e 6e6e 7265 5448 4c4d 273d 6552     on.innerHTML='Re
 80a33e4:	7274 2779 653b 616e 6c62 4265 7475 6f74     try';enableButto
 80a33f4:	736e 2928 7d3b 3b7d 6176 2072 6f63 6e6e     ns();}};var conn
 80a3404:	6365 5f74 6163 6c6c 6162 6b63 7b3d 7573     ect_callback={su
 80a3414:	6363 7365 3a73 7566 636e 6974 6e6f 6128     ccess:function(a
 80a3424:	7b29 6f63 736e 6c6f 2e65 6f6c 2867 4127     ){console.log('A
 80a3434:	7474 6d65 7470 6e69 2067 6f74 6320 6e6f     ttempting to con
 80a3444:	656e 7463 7420 206f 6874 2065 6c63 756f     nect to the clou
 80a3454:	2e64 2927 633b 6e6f 656e 7463 7542 7474     d.');connectButt
 80a3464:	6e6f 692e 6e6e 7265 5448 4c4d 273d 7441     on.innerHTML='At
 80a3474:	6574 706d 6974 676e 7420 206f 6f63 6e6e     tempting to conn
 80a3484:	6365 2e74 2e2e 3b27 6977 646e 776f 612e     ect...';window.a
 80a3494:	656c 7472 2728 6f59 7275 6420 7665 6369     lert('Your devic
 80a34a4:	2065 6873 756f 646c 6e20 776f 7320 6174     e should now sta
 80a34b4:	7472 6620 616c 6873 6e69 2067 7267 6565     rt flashing gree
 80a34c4:	206e 6e61 2064 7461 6574 706d 2074 6f74     n and attempt to
 80a34d4:	6320 6e6f 656e 7463 7420 206f 6874 2065      connect to the 
 80a34e4:	6c63 756f 2e64 5420 6968 2073 7375 6175     cloud. This usua
 80a34f4:	6c6c 2079 6174 656b 2073 6261 756f 2074     lly takes about 
 80a3504:	3032 7320 6365 6e6f 7364 202c 6661 6574     20 seconds, afte
 80a3514:	2072 6877 6369 2068 7469 7720 6c69 206c     r which it will 
 80a3524:	6562 6967 206e 6c73 776f 796c 6220 696c     begin slowly bli
 80a3534:	6b6e 6e69 2067 7963 6e61 202e 6e5c 6e5c     nking cyan. \n\n
 80a3544:	6e5c 6649 7420 6968 2073 7270 636f 7365     \nIf this proces
 80a3554:	2073 6166 6c69 2073 6562 6163 7375 2065     s fails because 
 80a3564:	6f79 2075 6e65 6574 6572 2064 6874 2065     you entered the 
 80a3574:	7277 6e6f 2067 6170 7373 6f77 6472 202c     wrong password, 
 80a3584:	6874 2065 6564 6976 6563 7720 6c69 206c     the device will 
 80a3594:	6c66 7361 2068 7267 6565 206e 6e69 6564     flash green inde
 80a35a4:	6966 696e 6574 796c 202e 6e49 7420 6968     finitely. In thi
 80a35b4:	2073 6163 6573 202c 6f68 646c 7420 6568     s case, hold the
 80a35c4:	7320 7465 7075 6220 7475 6f74 206e 6f66      setup button fo
 80a35d4:	2072 2036 6573 6f63 646e 2073 6e75 6974     r 6 seconds unti
 80a35e4:	206c 6874 2065 6564 6976 6563 7320 6174     l the device sta
 80a35f4:	7472 2073 6c62 6e69 696b 676e 6220 756c     rts blinking blu
 80a3604:	2065 6761 6961 2e6e 5420 6568 206e 6572     e again. Then re
 80a3614:	6f63 6e6e 6365 2074 6f74 7420 6568 5720     connect to the W
 80a3624:	4669 2069 6f68 7374 6f70 2074 7469 6720     iFi hotspot it g
 80a3634:	6e65 7265 7461 7365 6120 646e 7220 6c65     enerates and rel
 80a3644:	616f 2064 6874 7369 7020 6761 2065 6f74     oad this page to
 80a3654:	7420 7972 6120 6167 6e69 272e 3b29 2c7d      try again.');},
 80a3664:	7265 6f72 3a72 7566 636e 6974 6e6f 6128     error:function(a
 80a3674:	622c 7b29 6f63 736e 6c6f 2e65 6f6c 2867     ,b){console.log(
 80a3684:	4327 6e6f 656e 7463 6520 7272 726f 203a     'Connect error: 
 80a3694:	2b27 2961 773b 6e69 6f64 2e77 6c61 7265     '+a);window.aler
 80a36a4:	2874 5427 6568 6320 6e6f 656e 7463 6320     t('The connect c
 80a36b4:	6d6f 616d 646e 6620 6961 656c 2c64 6320     ommand failed, c
 80a36c4:	6568 6b63 7420 6168 2074 6f79 2075 7261     heck that you ar
 80a36d4:	2065 7473 6c69 206c 6577 6c6c 6320 6e6f     e still well con
 80a36e4:	656e 7463 6465 7420 206f 6874 2065 6564     nected to the de
 80a36f4:	6976 6563 275c 2073 6957 6946 6820 746f     vice\'s WiFi hot
 80a3704:	7073 746f 6120 646e 7220 7465 7972 272e     spot and retry.'
 80a3714:	3b29 6f63 6e6e 6365 4274 7475 6f74 2e6e     );connectButton.
 80a3724:	6e69 656e 4872 4d54 3d4c 5227 7465 7972     innerHTML='Retry
 80a3734:	3b27 6e65 6261 656c 7542 7474 6e6f 2873     ';enableButtons(
 80a3744:	3b29 7d7d 763b 7261 6420 7369 6261 656c     );}};var disable
 80a3754:	7542 7474 6e6f 3d73 7566 636e 6974 6e6f     Buttons=function
 80a3764:	2928 637b 6e6f 656e 7463 7542 7474 6e6f     (){connectButton
 80a3774:	642e 7369 6261 656c 3d64 7274 6575 733b     .disabled=true;s
 80a3784:	6163 426e 7475 6f74 2e6e 6964 6173 6c62     canButton.disabl
 80a3794:	6465 743d 7572 3b65 3b7d 6176 2072 6e65     ed=true;};var en
 80a37a4:	6261 656c 7542 7474 6e6f 3d73 7566 636e     ableButtons=func
 80a37b4:	6974 6e6f 2928 637b 6e6f 656e 7463 7542     tion(){connectBu
 80a37c4:	7474 6e6f 642e 7369 6261 656c 3d64 6166     tton.disabled=fa
 80a37d4:	736c 3b65 6373 6e61 7542 7474 6e6f 642e     lse;scanButton.d
 80a37e4:	7369 6261 656c 3d64 6166 736c 3b65 3b7d     isabled=false;};
 80a37f4:	6176 2072 6461 5f64 6977 6966 6f5f 7470     var add_wifi_opt
 80a3804:	6f69 3d6e 7566 636e 6974 6e6f 6128 622c     ion=function(a,b
 80a3814:	7b29 6176 2072 3d63 6f64 7563 656d 746e     ){var c=document
 80a3824:	632e 6572 7461 4565 656c 656d 746e 2728     .createElement('
 80a3834:	4e49 5550 2754 3b29 2e63 7974 6570 273d     INPUT');c.type='
 80a3844:	6172 6964 276f 633b 762e 6c61 6575 623d     radio';c.value=b
 80a3854:	633b 692e 3d64 3b62 2e63 616e 656d 273d     ;c.id=b;c.name='
 80a3864:	7373 6469 3b27 2e63 6c63 7361 4e73 6d61     ssid';c.classNam
 80a3874:	3d65 7227 6461 6f69 3b27 6176 2072 3d64     e='radio';var d=
 80a3884:	6f64 7563 656d 746e 632e 6572 7461 4565     document.createE
 80a3894:	656c 656d 746e 2728 4944 2756 3b29 2e64     lement('DIV');d.
 80a38a4:	6c63 7361 4e73 6d61 3d65 7227 6461 6f69     className='radio
 80a38b4:	642d 7669 3b27 2e64 7061 6570 646e 6843     -div';d.appendCh
 80a38c4:	6c69 2864 2963 763b 7261 6520 643d 636f     ild(c);var e=doc
 80a38d4:	6d75 6e65 2e74 7263 6165 6574 6c45 6d65     ument.createElem
 80a38e4:	6e65 2874 6c27 6261 6c65 2927 653b 682e     ent('label');e.h
 80a38f4:	6d74 466c 726f 623d 653b 692e 6e6e 7265     tmlFor=b;e.inner
 80a3904:	5448 4c4d 623d 643b 612e 7070 6e65 4364     HTML=b;d.appendC
 80a3914:	6968 646c 6528 3b29 2e61 7061 6570 646e     hild(e);a.append
 80a3924:	6843 6c69 2864 2964 7d3b 763b 7261 6720     Child(d);};var g
 80a3934:	7465 735f 6c65 6365 6574 5f64 656e 7774     et_selected_netw
 80a3944:	726f 3d6b 7566 636e 6974 6e6f 2928 667b     ork=function(){f
 80a3954:	726f 7628 7261 6120 303d 613b 6e3c 7465     or(var a=0;a<net
 80a3964:	6f77 6b72 6c5f 7369 2e74 656c 676e 6874     work_list.length
 80a3974:	613b 2b2b 7b29 7373 6469 6e3d 7465 6f77     ;a++){ssid=netwo
 80a3984:	6b72 6c5f 7369 5b74 5d61 732e 6973 3b64     rk_list[a].ssid;
 80a3994:	6669 6428 636f 6d75 6e65 2e74 6567 4574     if(document.getE
 80a39a4:	656c 656d 746e 7942 6449 7328 6973 2964     lementById(ssid)
 80a39b4:	632e 6568 6b63 6465 7229 7465 7275 206e     .checked)return 
 80a39c4:	656e 7774 726f 5f6b 696c 7473 615b 3b5d     network_list[a];
 80a39d4:	7d7d 763b 7261 6320 706f 3d79 7566 636e     }};var copy=func
 80a39e4:	6974 6e6f 2928 777b 6e69 6f64 2e77 7270     tion(){window.pr
 80a39f4:	6d6f 7470 2728 6f43 7970 7420 206f 6c63     ompt('Copy to cl
 80a3a04:	7069 6f62 7261 3a64 4320 7274 206c 202b     ipboard: Ctrl + 
 80a3a14:	2c43 4520 746e 7265 2c27 6564 6976 6563     C, Enter',device
 80a3a24:	4449 762e 6c61 6575 3b29 3b7d 6176 2072     ID.value);};var 
 80a3a34:	6f74 6767 656c 6853 776f 663d 6e75 7463     toggleShow=funct
 80a3a44:	6f69 286e 7b29 6176 2072 3d61 6f64 7563     ion(){var a=docu
 80a3a54:	656d 746e 672e 7465 6c45 6d65 6e65 4274     ment.getElementB
 80a3a64:	4979 2864 7027 7361 7773 726f 2764 3b29     yId('password');
 80a3a74:	6e69 7570 5474 7079 3d65 2e61 7974 6570     inputType=a.type
 80a3a84:	693b 2866 6e69 7570 5474 7079 3d65 3d3d     ;if(inputType===
 80a3a94:	7027 7361 7773 726f 2764 7b29 6873 776f     'password'){show
 80a3aa4:	7542 7474 6e6f 692e 6e6e 7265 5448 4c4d     Button.innerHTML
 80a3ab4:	273d 6948 6564 3b27 2e61 7974 6570 273d     ='Hide';a.type='
 80a3ac4:	6574 7478 3b27 657d 736c 7b65 6873 776f     text';}else{show
 80a3ad4:	7542 7474 6e6f 692e 6e6e 7265 5448 4c4d     Button.innerHTML
 80a3ae4:	273d 6853 776f 3b27 2e61 7974 6570 273d     ='Show';a.type='
 80a3af4:	6170 7373 6f77 6472 3b27 7d7d 763b 7261     password';}};var
 80a3b04:	6720 7465 6552 7571 7365 3d74 7566 636e      getRequest=func
 80a3b14:	6974 6e6f 6128 622c 7b29 6176 2072 3d63     tion(a,b){var c=
 80a3b24:	656e 2077 4d58 484c 7474 5270 7165 6575     new XMLHttpReque
 80a3b34:	7473 2928 633b 6f2e 6570 286e 4727 5445     st();c.open('GET
 80a3b44:	2c27 2c61 7274 6575 3b29 2e63 6974 656d     ',a,true);c.time
 80a3b54:	756f 3d74 3038 3030 633b 732e 6e65 2864     out=8000;c.send(
 80a3b64:	3b29 2e63 6e6f 6572 6461 7379 6174 6574     );c.onreadystate
 80a3b74:	6863 6e61 6567 663d 6e75 7463 6f69 286e     change=function(
 80a3b84:	7b29 6669 6328 722e 6165 7964 7453 7461     ){if(c.readyStat
 80a3b94:	3d65 343d 6929 2866 2962 697b 2866 2e63     e==4)if(b){if(c.
 80a3ba4:	7473 7461 7375 3d3d 3032 2930 697b 2866     status==200){if(
 80a3bb4:	2e62 7573 6363 7365 2973 2e62 7573 6363     b.success)b.succ
 80a3bc4:	7365 2873 534a 4e4f 702e 7261 6573 6328     ess(JSON.parse(c
 80a3bd4:	722e 7365 6f70 736e 5465 7865 2974 3b29     .responseText));
 80a3be4:	657d 736c 2065 6669 6228 652e 7272 726f     }else if(b.error
 80a3bf4:	6229 652e 7272 726f 6328 732e 6174 7574     )b.error(c.statu
 80a3c04:	2c73 2e63 6572 7073 6e6f 6573 6554 7478     s,c.responseText
 80a3c14:	3b29 6669 6228 722e 6765 7261 6c64 7365     );if(b.regardles
 80a3c24:	2973 2e62 6572 6167 6472 656c 7373 2928     s)b.regardless()
 80a3c34:	7d3b 3b7d 3b7d 6176 2072 6f70 7473 6552     ;}};};var postRe
 80a3c44:	7571 7365 3d74 7566 636e 6974 6e6f 6128     quest=function(a
 80a3c54:	622c 632c 7b29 6176 2072 3d64 534a 4e4f     ,b,c){var d=JSON
 80a3c64:	732e 7274 6e69 6967 7966 6228 3b29 6176     .stringify(b);va
 80a3c74:	2072 3d65 656e 2077 4d58 484c 7474 5270     r e=new XMLHttpR
 80a3c84:	7165 6575 7473 2928 653b 6f2e 6570 286e     equest();e.open(
 80a3c94:	5027 534f 2754 612c 742c 7572 2965 653b     'POST',a,true);e
 80a3ca4:	742e 6d69 6f65 7475 343d 3030 3b30 2e65     .timeout=4000;e.
 80a3cb4:	6573 5274 7165 6575 7473 6548 6461 7265     setRequestHeader
 80a3cc4:	2728 6f43 746e 6e65 2d74 7954 6570 2c27     ('Content-Type',
 80a3cd4:	6d27 6c75 6974 6170 7472 662f 726f 2d6d     'multipart/form-
 80a3ce4:	6164 6174 2927 653b 732e 6e65 2864 2964     data');e.send(d)
 80a3cf4:	653b 6f2e 726e 6165 7964 7473 7461 6365     ;e.onreadystatec
 80a3d04:	6168 676e 3d65 7566 636e 6974 6e6f 2928     hange=function()
 80a3d14:	697b 2866 2e65 6572 6461 5379 6174 6574     {if(e.readyState
 80a3d24:	3d3d 2934 6669 6328 7b29 6669 6528 732e     ==4)if(c){if(e.s
 80a3d34:	6174 7574 3d73 323d 3030 7b29 6669 6328     tatus==200){if(c
 80a3d44:	732e 6375 6563 7373 6329 732e 6375 6563     .success)c.succe
 80a3d54:	7373 4a28 4f53 2e4e 6170 7372 2865 2e65     ss(JSON.parse(e.
 80a3d64:	6572 7073 6e6f 6573 6554 7478 2929 7d3b     responseText));}
 80a3d74:	6c65 6573 6920 2866 2e63 7265 6f72 2972     else if(c.error)
 80a3d84:	2e63 7265 6f72 2872 2e65 7473 7461 7375     c.error(e.status
 80a3d94:	652c 722e 7365 6f70 736e 5465 7865 2974     ,e.responseText)
 80a3da4:	693b 2866 2e63 6572 6167 6472 656c 7373     ;if(c.regardless
 80a3db4:	6329 722e 6765 7261 6c64 7365 2873 3b29     )c.regardless();
 80a3dc4:	7d7d 7d3b 693b 2866 6373 6e61 7542 7474     }};};if(scanButt
 80a3dd4:	6e6f 612e 6464 7645 6e65 4c74 7369 6574     on.addEventListe
 80a3de4:	656e 2972 637b 706f 4279 7475 6f74 2e6e     ner){copyButton.
 80a3df4:	6461 4564 6576 746e 694c 7473 6e65 7265     addEventListener
 80a3e04:	2728 6c63 6369 276b 632c 706f 2979 733b     ('click',copy);s
 80a3e14:	6f68 4277 7475 6f74 2e6e 6461 4564 6576     howButton.addEve
 80a3e24:	746e 694c 7473 6e65 7265 2728 6c63 6369     ntListener('clic
 80a3e34:	276b 742c 676f 6c67 5365 6f68 2977 733b     k',toggleShow);s
 80a3e44:	6163 426e 7475 6f74 2e6e 6461 4564 6576     canButton.addEve
 80a3e54:	746e 694c 7473 6e65 7265 2728 6c63 6369     ntListener('clic
 80a3e64:	276b 732c 6163 296e 633b 6e6f 656e 7463     k',scan);connect
 80a3e74:	6f46 6d72 612e 6464 7645 6e65 4c74 7369     Form.addEventLis
 80a3e84:	6574 656e 2872 7327 6275 696d 2774 632c     tener('submit',c
 80a3e94:	6e6f 6966 7567 6572 3b29 657d 736c 2065     onfigure);}else 
 80a3ea4:	6669 7328 6163 426e 7475 6f74 2e6e 7461     if(scanButton.at
 80a3eb4:	6174 6863 7645 6e65 2974 637b 706f 4279     tachEvent){copyB
 80a3ec4:	7475 6f74 2e6e 7461 6174 6863 7645 6e65     utton.attachEven
 80a3ed4:	2874 6f27 636e 696c 6b63 2c27 6f63 7970     t('onclick',copy
 80a3ee4:	3b29 6873 776f 7542 7474 6e6f 612e 7474     );showButton.att
 80a3ef4:	6361 4568 6576 746e 2728 6e6f 6c63 6369     achEvent('onclic
 80a3f04:	276b 742c 676f 6c67 5365 6f68 2977 733b     k',toggleShow);s
 80a3f14:	6163 426e 7475 6f74 2e6e 7461 6174 6863     canButton.attach
 80a3f24:	7645 6e65 2874 6f27 636e 696c 6b63 2c27     Event('onclick',
 80a3f34:	6373 6e61 3b29 6f63 6e6e 6365 4674 726f     scan);connectFor
 80a3f44:	2e6d 7461 6174 6863 7645 6e65 2874 6f27     m.attachEvent('o
 80a3f54:	736e 6275 696d 2774 632c 6e6f 6966 7567     nsubmit',configu
 80a3f64:	6572 3b29 677d 7465 6552 7571 7365 2874     re);}getRequest(
 80a3f74:	6162 6573 755f 6c72 272b 6564 6976 6563     base_url+'device
 80a3f84:	692d 2764 642c 7665 6369 5f65 6469 635f     -id',device_id_c
 80a3f94:	6c61 626c 6361 296b 673b 7465 6552 7571     allback);getRequ
 80a3fa4:	7365 2874 6162 6573 755f 6c72 272b 7570     est(base_url+'pu
 80a3fb4:	6c62 6369 6b2d 7965 2c27 7570 6c62 6369     blic-key',public
 80a3fc4:	6b5f 7965 635f 6c61 626c 6361 296b 003b     _key_callback);.

080a3fd4 <_ZL9style_css>:
 80a3fd4:	7468 6c6d 687b 6965 6867 3a74 3031 2530     html{height:100%
 80a3fe4:	6d3b 7261 6967 3a6e 7561 6f74 623b 6361     ;margin:auto;bac
 80a3ff4:	676b 6f72 6e75 2d64 6f63 6f6c 3a72 6877     kground-color:wh
 80a4004:	7469 7d65 6f62 7964 627b 786f 732d 7a69     ite}body{box-siz
 80a4014:	6e69 3a67 6f62 6472 7265 622d 786f 6d3b     ing:border-box;m
 80a4024:	6e69 682d 6965 6867 3a74 3031 2530 703b     in-height:100%;p
 80a4034:	6461 6964 676e 323a 7030 3b78 6162 6b63     adding:20px;back
 80a4044:	7267 756f 646e 632d 6c6f 726f 233a 6131     ground-color:#1a
 80a4054:	6261 3065 663b 6e6f 2d74 6166 696d 796c     abe0;font-family
 80a4064:	273a 754c 6963 6164 5320 6e61 2073 6e55     :'Lucida Sans Un
 80a4074:	6369 646f 2765 272c 754c 6963 6164 4720     icode','Lucida G
 80a4084:	6172 646e 2765 732c 6e61 2d73 6573 6972     rande',sans-seri
 80a4094:	3b66 6f66 746e 772d 6965 6867 3a74 6f6e     f;font-weight:no
 80a40a4:	6d72 6c61 633b 6c6f 726f 773a 6968 6574     rmal;color:white
 80a40b4:	6d3b 7261 6967 2d6e 6f74 3a70 3b30 616d     ;margin-top:0;ma
 80a40c4:	6772 6e69 6c2d 6665 3a74 7561 6f74 6d3b     rgin-left:auto;m
 80a40d4:	7261 6967 2d6e 6972 6867 3a74 7561 6f74     argin-right:auto
 80a40e4:	6d3b 7261 6967 2d6e 6f62 7474 6d6f 303a     ;margin-bottom:0
 80a40f4:	6d3b 7861 772d 6469 6874 343a 3030 7870     ;max-width:400px
 80a4104:	743b 7865 2d74 6c61 6769 3a6e 6563 746e     ;text-align:cent
 80a4114:	7265 623b 726f 6564 3a72 7031 2078 6f73     er;border:1px so
 80a4124:	696c 2064 3623 3665 3765 3b30 6f62 6472     lid #6e6e70;bord
 80a4134:	7265 722d 6461 7569 3a73 7034 7d78 6964     er-radius:4px}di
 80a4144:	7b76 616d 6772 6e69 742d 706f 323a 7035     v{margin-top:25p
 80a4154:	3b78 616d 6772 6e69 622d 746f 6f74 3a6d     x;margin-bottom:
 80a4164:	3532 7870 687d 7b31 616d 6772 6e69 742d     25px}h1{margin-t
 80a4174:	706f 323a 7035 3b78 616d 6772 6e69 622d     op:25px;margin-b
 80a4184:	746f 6f74 3a6d 3532 7870 627d 7475 6f74     ottom:25px}butto
 80a4194:	7b6e 6f62 6472 7265 632d 6c6f 726f 233a     n{border-color:#
 80a41a4:	6331 3537 6562 623b 6361 676b 6f72 6e75     1c75be;backgroun
 80a41b4:	2d64 6f63 6f6c 3a72 3123 3763 6235 3b65     d-color:#1c75be;
 80a41c4:	6f63 6f6c 3a72 6877 7469 3b65 6f62 6472     color:white;bord
 80a41d4:	7265 722d 6461 7569 3a73 7035 3b78 6568     er-radius:5px;he
 80a41e4:	6769 7468 333a 7030 3b78 6f66 746e 732d     ight:30px;font-s
 80a41f4:	7a69 3a65 3531 7870 663b 6e6f 2d74 6577     ize:15px;font-we
 80a4204:	6769 7468 623a 6c6f 7d64 7562 7474 6e6f     ight:bold}button
 80a4214:	692e 706e 7475 682d 6c65 6570 7b72 6162     .input-helper{ba
 80a4224:	6b63 7267 756f 646e 632d 6c6f 726f 233a     ckground-color:#
 80a4234:	6562 6562 6562 623b 726f 6564 2d72 6f63     bebebe;border-co
 80a4244:	6f6c 3a72 6223 6265 6265 3b65 6f63 6f6c     lor:#bebebe;colo
 80a4254:	3a72 3623 3665 3765 3b30 616d 6772 6e69     r:#6e6e70;margin
 80a4264:	6c2d 6665 3a74 7033 7d78 7562 7474 6e6f     -left:3px}button
 80a4274:	643a 7369 6261 656c 7b64 6162 6b63 7267     :disabled{backgr
 80a4284:	756f 646e 632d 6c6f 726f 233a 6562 6562     ound-color:#bebe
 80a4294:	6562 623b 726f 6564 2d72 6f63 6f6c 3a72     be;border-color:
 80a42a4:	6223 6265 6265 3b65 6f63 6f6c 3a72 6877     #bebebe;color:wh
 80a42b4:	7469 7d65 6e69 7570 5b74 7974 6570 273d     ite}input[type='
 80a42c4:	6574 7478 5d27 692c 706e 7475 745b 7079     text'],input[typ
 80a42d4:	3d65 7027 7361 7773 726f 2764 7b5d 6162     e='password']{ba
 80a42e4:	6b63 7267 756f 646e 632d 6c6f 726f 773a     ckground-color:w
 80a42f4:	6968 6574 633b 6c6f 726f 233a 6536 6536     hite;color:#6e6e
 80a4304:	3037 623b 726f 6564 2d72 6f63 6f6c 3a72     70;border-color:
 80a4314:	6877 7469 3b65 6f62 6472 7265 722d 6461     white;border-rad
 80a4324:	7569 3a73 7035 3b78 6568 6769 7468 323a     ius:5px;height:2
 80a4334:	7035 3b78 6574 7478 612d 696c 6e67 633a     5px;text-align:c
 80a4344:	6e65 6574 3b72 6f66 746e 732d 7a69 3a65     enter;font-size:
 80a4354:	3531 7870 697d 706e 7475 643a 7369 6261     15px}input:disab
 80a4364:	656c 7b64 6162 6b63 7267 756f 646e 632d     led{background-c
 80a4374:	6c6f 726f 233a 6562 6562 6562 623b 726f     olor:#bebebe;bor
 80a4384:	6564 2d72 6f63 6f6c 3a72 6223 6265 6265     der-color:#bebeb
 80a4394:	7d65 6e69 7570 5b74 7974 6570 273d 6172     e}input[type='ra
 80a43a4:	6964 276f 7b5d 6f70 6973 6974 6e6f 723a     dio']{position:r
 80a43b4:	6c65 7461 7669 3b65 6f62 7474 6d6f 2d3a     elative;bottom:-
 80a43c4:	2e30 3333 6d65 6d3b 7261 6967 3a6e 3b30     0.33em;margin:0;
 80a43d4:	6f62 6472 7265 303a 683b 6965 6867 3a74     border:0;height:
 80a43e4:	2e31 6535 3b6d 6977 7464 3a68 3531 7d25     1.5em;width:15%}
 80a43f4:	616c 6562 7b6c 6170 6464 6e69 2d67 6f74     label{padding-to
 80a4404:	3a70 7037 3b78 6170 6464 6e69 2d67 6f62     p:7px;padding-bo
 80a4414:	7474 6d6f 373a 7870 703b 6461 6964 676e     ttom:7px;padding
 80a4424:	6c2d 6665 3a74 2535 643b 7369 6c70 7961     -left:5%;display
 80a4434:	693a 6c6e 6e69 2d65 6c62 636f 3b6b 6977     :inline-block;wi
 80a4444:	7464 3a68 3038 3b25 6574 7478 612d 696c     dth:80%;text-ali
 80a4454:	6e67 6c3a 6665 7d74 6e69 7570 5b74 7974     gn:left}input[ty
 80a4464:	6570 273d 6172 6964 276f 3a5d 6863 6365     pe='radio']:chec
 80a4474:	656b 2b64 616c 6562 7b6c 6f66 746e 772d     ked+label{font-w
 80a4484:	6965 6867 3a74 6f62 646c 633b 6c6f 726f     eight:bold;color
 80a4494:	233a 6331 3537 6562 2e7d 6373 6e61 696e     :#1c75be}.scanni
 80a44a4:	676e 652d 7272 726f 667b 6e6f 2d74 6577     ng-error{font-we
 80a44b4:	6769 7468 623a 6c6f 3b64 6574 7478 612d     ight:bold;text-a
 80a44c4:	696c 6e67 633a 6e65 6574 7d72 722e 6461     lign:center}.rad
 80a44d4:	6f69 642d 7669 627b 786f 732d 7a69 6e69     io-div{box-sizin
 80a44e4:	3a67 6f62 6472 7265 622d 786f 6d3b 7261     g:border-box;mar
 80a44f4:	6967 3a6e 7032 3b78 616d 6772 6e69 6c2d     gin:2px;margin-l
 80a4504:	6665 3a74 7561 6f74 6d3b 7261 6967 2d6e     eft:auto;margin-
 80a4514:	6972 6867 3a74 7561 6f74 623b 6361 676b     right:auto;backg
 80a4524:	6f72 6e75 2d64 6f63 6f6c 3a72 6877 7469     round-color:whit
 80a4534:	3b65 6f63 6f6c 3a72 3623 3665 3765 3b30     e;color:#6e6e70;
 80a4544:	6f62 6472 7265 313a 7870 7320 6c6f 6469     border:1px solid
 80a4554:	2320 6536 6536 3037 623b 726f 6564 2d72      #6e6e70;border-
 80a4564:	6172 6964 7375 333a 7870 773b 6469 6874     radius:3px;width
 80a4574:	313a 3030 3b25 6170 6464 6e69 3a67 7035     :100%;padding:5p
 80a4584:	7d78 6e23 7465 6f77 6b72 2d73 6964 7b76     x}#networks-div{
 80a4594:	616d 6772 6e69 6c2d 6665 3a74 7561 6f74     margin-left:auto
 80a45a4:	6d3b 7261 6967 2d6e 6972 6867 3a74 7561     ;margin-right:au
 80a45b4:	6f74 743b 7865 2d74 6c61 6769 3a6e 656c     to;text-align:le
 80a45c4:	7466 237d 6564 6976 6563 692d 7b64 6574     ft}#device-id{te
 80a45d4:	7478 612d 696c 6e67 633a 6e65 6574 7d72     xt-align:center}
 80a45e4:	7323 6163 2d6e 7562 7474 6e6f 6d7b 6e69     #scan-button{min
 80a45f4:	772d 6469 6874 313a 3030 7870 237d 6f63     -width:100px}#co
 80a4604:	6e6e 6365 2d74 7562 7474 6e6f 647b 7369     nnect-button{dis
 80a4614:	6c70 7961 623a 6f6c 6b63 6d3b 6e69 772d     play:block;min-w
 80a4624:	6469 6874 313a 3030 7870 6d3b 7261 6967     idth:100px;margi
 80a4634:	2d6e 6f74 3a70 3031 7870 6d3b 7261 6967     n-top:10px;margi
 80a4644:	2d6e 656c 7466 613a 7475 3b6f 616d 6772     n-left:auto;marg
 80a4654:	6e69 722d 6769 7468 613a 7475 3b6f 616d     in-right:auto;ma
 80a4664:	6772 6e69 622d 746f 6f74 3a6d 3032 7870     rgin-bottom:20px
 80a4674:	237d 6170 7373 6f77 6472 6d7b 7261 6967     }#password{margi
 80a4684:	2d6e 6f74 3a70 3032 7870 6d3b 7261 6967     n-top:20px;margi
 80a4694:	2d6e 6f62 7474 6d6f 313a 7030 7d78 6600          n-bottom:10px}.

080a46a3 <_ZL9jsbn_2_js>:
 80a46a3:	7566 636e 6974 6e6f 6220 706e 5352 6968     function bnpRShi
 80a46b3:	7466 6f54 6128 622c 7b29 2e62 3d73 6874     ftTo(a,b){b.s=th
 80a46c3:	7369 732e 763b 7261 6320 4d3d 7461 2e68     is.s;var c=Math.
 80a46d3:	6c66 6f6f 2872 2f61 6874 7369 442e 2942     floor(a/this.DB)
 80a46e3:	693b 2866 3e63 743d 6968 2e73 2974 627b     ;if(c>=this.t){b
 80a46f3:	742e 303d 723b 7465 7275 3b6e 767d 7261     .t=0;return;}var
 80a4703:	6420 613d 7425 6968 2e73 4244 763b 7261      d=a%this.DB;var
 80a4713:	6520 743d 6968 2e73 4244 642d 763b 7261      e=this.DB-d;var
 80a4723:	6620 283d 3c31 643c 2d29 3b31 5b62 5d30      f=(1<<d)-1;b[0]
 80a4733:	743d 6968 5b73 5d63 3e3e 3b64 6f66 2872     =this[c]>>d;for(
 80a4743:	6176 2072 3d67 2b63 3b31 3c67 6874 7369     var g=c+1;g<this
 80a4753:	742e 2b3b 672b 7b29 5b62 2d67 2d63 5d31     .t;++g){b[g-c-1]
 80a4763:	3d7c 7428 6968 5b73 5d67 6626 3c29 653c     |=(this[g]&f)<<e
 80a4773:	623b 675b 632d 3d5d 6874 7369 675b 3e5d     ;b[g-c]=this[g]>
 80a4783:	643e 7d3b 6669 6428 303e 6229 745b 6968     >d;}if(d>0)b[thi
 80a4793:	2e73 2d74 2d63 5d31 3d7c 7428 6968 2e73     s.t-c-1]|=(this.
 80a47a3:	2673 2966 3c3c 3b65 2e62 3d74 6874 7369     s&f)<<e;b.t=this
 80a47b3:	742e 632d 623b 632e 616c 706d 2928 7d3b     .t-c;b.clamp();}
 80a47c3:	7566 636e 6974 6e6f 6220 706e 7553 5462     function bnpSubT
 80a47d3:	286f 2c61 2962 767b 7261 6320 303d 642c     o(a,b){var c=0,d
 80a47e3:	303d 652c 4d3d 7461 2e68 696d 286e 2e61     =0,e=Math.min(a.
 80a47f3:	2c74 6874 7369 742e 3b29 6877 6c69 2865     t,this.t);while(
 80a4803:	3c63 2965 647b 3d2b 6874 7369 635b 2d5d     c<e){d+=this[c]-
 80a4813:	5b61 5d63 623b 635b 2b2b 3d5d 2664 6874     a[c];b[c++]=d&th
 80a4823:	7369 442e 3b4d 3e64 3d3e 6874 7369 442e     is.DM;d>>=this.D
 80a4833:	3b42 697d 2866 2e61 3c74 6874 7369 742e     B;}if(a.t<this.t
 80a4843:	7b29 2d64 613d 732e 773b 6968 656c 6328     ){d-=a.s;while(c
 80a4853:	743c 6968 2e73 2974 647b 3d2b 6874 7369     <this.t){d+=this
 80a4863:	635b 3b5d 5b62 2b63 5d2b 643d 7426 6968     [c];b[c++]=d&thi
 80a4873:	2e73 4d44 643b 3e3e 743d 6968 2e73 4244     s.DM;d>>=this.DB
 80a4883:	7d3b 2b64 743d 6968 2e73 3b73 657d 736c     ;}d+=this.s;}els
 80a4893:	7b65 2b64 743d 6968 2e73 3b73 6877 6c69     e{d+=this.s;whil
 80a48a3:	2865 3c63 2e61 2974 647b 3d2d 5b61 5d63     e(c<a.t){d-=a[c]
 80a48b3:	623b 635b 2b2b 3d5d 2664 6874 7369 442e     ;b[c++]=d&this.D
 80a48c3:	3b4d 3e64 3d3e 6874 7369 442e 3b42 647d     M;d>>=this.DB;}d
 80a48d3:	3d2d 2e61 3b73 627d 732e 283d 3c64 2930     -=a.s;}b.s=(d<0)
 80a48e3:	2d3f 3a31 3b30 6669 6428 2d3c 2931 5b62     ?-1:0;if(d<-1)b[
 80a48f3:	2b63 5d2b 743d 6968 2e73 5644 642b 653b     c++]=this.DV+d;e
 80a4903:	736c 2065 6669 6428 303e 6229 635b 2b2b     lse if(d>0)b[c++
 80a4913:	3d5d 3b64 2e62 3d74 3b63 2e62 6c63 6d61     ]=d;b.t=c;b.clam
 80a4923:	2870 3b29 667d 6e75 7463 6f69 206e 6e62     p();}function bn
 80a4933:	4d70 6c75 6974 6c70 5479 286f 2c61 2962     pMultiplyTo(a,b)
 80a4943:	767b 7261 6320 743d 6968 2e73 6261 2873     {var c=this.abs(
 80a4953:	2c29 3d64 2e61 6261 2873 3b29 6176 2072     ),d=a.abs();var 
 80a4963:	3d65 2e63 3b74 2e62 3d74 2b65 2e64 3b74     e=c.t;b.t=e+d.t;
 80a4973:	6877 6c69 2865 2d2d 3e65 303d 6229 655b     while(--e>=0)b[e
 80a4983:	3d5d 3b30 6f66 2872 3d65 3b30 3c65 2e64     ]=0;for(e=0;e<d.
 80a4993:	3b74 2b2b 2965 5b62 2b65 2e63 5d74 633d     t;++e)b[e+c.t]=c
 80a49a3:	612e 286d 2c30 5b64 5d65 622c 652c 302c     .am(0,d[e],b,e,0
 80a49b3:	632c 742e 3b29 2e62 3d73 3b30 2e62 6c63     ,c.t);b.s=0;b.cl
 80a49c3:	6d61 2870 3b29 6669 7428 6968 2e73 2173     amp();if(this.s!
 80a49d3:	613d 732e 4229 6769 6e49 6574 6567 2e72     =a.s)BigInteger.
 80a49e3:	455a 4f52 732e 6275 6f54 6228 622c 3b29     ZERO.subTo(b,b);
 80a49f3:	667d 6e75 7463 6f69 206e 6e62 5370 7571     }function bnpSqu
 80a4a03:	7261 5465 286f 2961 767b 7261 6220 743d     areTo(a){var b=t
 80a4a13:	6968 2e73 6261 2873 3b29 6176 2072 3d63     his.abs();var c=
 80a4a23:	2e61 3d74 2a32 2e62 3b74 6877 6c69 2865     a.t=2*b.t;while(
 80a4a33:	2d2d 3e63 303d 6129 635b 3d5d 3b30 6f66     --c>=0)a[c]=0;fo
 80a4a43:	2872 3d63 3b30 3c63 2e62 2d74 3b31 2b2b     r(c=0;c<b.t-1;++
 80a4a53:	2963 767b 7261 6420 623d 612e 286d 2c63     c){var d=b.am(c,
 80a4a63:	5b62 5d63 612c 322c 632a 302c 312c 3b29     b[c],a,2*c,0,1);
 80a4a73:	6669 2828 5b61 2b63 2e62 5d74 3d2b 2e62     if((a[c+b.t]+=b.
 80a4a83:	6d61 6328 312b 322c 622a 635b 2c5d 2c61     am(c+1,2*b[c],a,
 80a4a93:	2a32 2b63 2c31 2c64 2e62 2d74 2d63 2931     2*c+1,d,b.t-c-1)
 80a4aa3:	3e29 623d 442e 2956 617b 635b 622b 742e     )>=b.DV){a[c+b.t
 80a4ab3:	2d5d 623d 442e 3b56 5b61 2b63 2e62 2b74     ]-=b.DV;a[c+b.t+
 80a4ac3:	5d31 313d 7d3b 697d 2866 2e61 3e74 2930     1]=1;}}if(a.t>0)
 80a4ad3:	5b61 2e61 2d74 5d31 3d2b 2e62 6d61 6328     a[a.t-1]+=b.am(c
 80a4ae3:	622c 635b 2c5d 2c61 2a32 2c63 2c30 2931     ,b[c],a,2*c,0,1)
 80a4af3:	613b 732e 303d 613b 632e 616c 706d 2928     ;a.s=0;a.clamp()
 80a4b03:	7d3b 7566 636e 6974 6e6f 6220 706e 6944     ;}function bnpDi
 80a4b13:	5276 6d65 6f54 6128 622c 632c 7b29 6176     vRemTo(a,b,c){va
 80a4b23:	2072 3d64 2e61 6261 2873 3b29 6669 6428     r d=a.abs();if(d
 80a4b33:	742e 3d3c 2930 6572 7574 6e72 763b 7261     .t<=0)return;var
 80a4b43:	6520 743d 6968 2e73 6261 2873 3b29 6669      e=this.abs();if
 80a4b53:	6528 742e 643c 742e 7b29 6669 6228 3d21     (e.t<d.t){if(b!=
 80a4b63:	756e 6c6c 6229 662e 6f72 496d 746e 3028     null)b.fromInt(0
 80a4b73:	3b29 6669 6328 3d21 756e 6c6c 7429 6968     );if(c!=null)thi
 80a4b83:	2e73 6f63 7970 6f54 6328 3b29 6572 7574     s.copyTo(c);retu
 80a4b93:	6e72 7d3b 6669 6328 3d3d 756e 6c6c 6329     rn;}if(c==null)c
 80a4ba3:	6e3d 6962 2928 763b 7261 6620 6e3d 6962     =nbi();var f=nbi
 80a4bb3:	2928 672c 743d 6968 2e73 2c73 3d68 2e61     (),g=this.s,h=a.
 80a4bc3:	3b73 6176 2072 3d69 6874 7369 442e 2d42     s;var i=this.DB-
 80a4bd3:	626e 7469 2873 5b64 2e64 2d74 5d31 3b29     nbits(d[d.t-1]);
 80a4be3:	6669 6928 303e 7b29 2e64 536c 6968 7466     if(i>0){d.lShift
 80a4bf3:	6f54 6928 662c 3b29 2e65 536c 6968 7466     To(i,f);e.lShift
 80a4c03:	6f54 6928 632c 3b29 657d 736c 7b65 2e64     To(i,c);}else{d.
 80a4c13:	6f63 7970 6f54 6628 3b29 2e65 6f63 7970     copyTo(f);e.copy
 80a4c23:	6f54 6328 3b29 767d 7261 6a20 663d 742e     To(c);}var j=f.t
 80a4c33:	763b 7261 6b20 663d 6a5b 312d 3b5d 6669     ;var k=f[j-1];if
 80a4c43:	6b28 3d3d 2930 6572 7574 6e72 763b 7261     (k==0)return;var
 80a4c53:	6c20 6b3d 282a 3c31 743c 6968 2e73 3146      l=k*(1<<this.F1
 80a4c63:	2b29 2828 3e6a 2931 663f 6a5b 322d 3e5d     )+((j>1)?f[j-2]>
 80a4c73:	743e 6968 2e73 3246 303a 3b29 6176 2072     >this.F2:0);var 
 80a4c83:	3d6d 6874 7369 462e 2f56 2c6c 3d6e 3128     m=this.FV/l,n=(1
 80a4c93:	3c3c 6874 7369 462e 2931 6c2f 6f2c 313d     <<this.F1)/l,o=1
 80a4ca3:	3c3c 6874 7369 462e 3b32 6176 2072 3d70     <<this.F2;var p=
 80a4cb3:	2e63 2c74 3d71 2d70 2c6a 3d72 6228 3d3d     c.t,q=p-j,r=(b==
 80a4cc3:	756e 6c6c 3f29 626e 2869 3a29 3b62 2e66     null)?nbi():b;f.
 80a4cd3:	6c64 6853 6669 5474 286f 2c71 2972 693b     dlShiftTo(q,r);i
 80a4ce3:	2866 2e63 6f63 706d 7261 5465 286f 2972     f(c.compareTo(r)
 80a4cf3:	3d3e 2930 637b 635b 742e 2b2b 3d5d 3b31     >=0){c[c.t++]=1;
 80a4d03:	2e63 7573 5462 286f 2c72 2963 7d3b 6942     c.subTo(r,c);}Bi
 80a4d13:	4967 746e 6765 7265 4f2e 454e 642e 536c     gInteger.ONE.dlS
 80a4d23:	6968 7466 6f54 6a28 722c 3b29 2e72 7573     hiftTo(j,r);r.su
 80a4d33:	5462 286f 2c66 2966 773b 6968 656c 6628     bTo(f,f);while(f
 80a4d43:	742e 6a3c 6629 665b 742e 2b2b 3d5d 3b30     .t<j)f[f.t++]=0;
 80a4d53:	6877 6c69 2865 2d2d 3e71 303d 7b29 6176     while(--q>=0){va
 80a4d63:	2072 3d73 6328 2d5b 702d 3d5d 6b3d 3f29     r s=(c[--p]==k)?
 80a4d73:	6874 7369 442e 3a4d 614d 6874 662e 6f6c     this.DM:Math.flo
 80a4d83:	726f 6328 705b 2a5d 2b6d 6328 705b 312d     or(c[p]*m+(c[p-1
 80a4d93:	2b5d 296f 6e2a 3b29 6669 2828 5b63 5d70     ]+o)*n);if((c[p]
 80a4da3:	3d2b 2e66 6d61 3028 732c 632c 712c 302c     +=f.am(0,s,c,q,0
 80a4db3:	6a2c 2929 733c 7b29 2e66 6c64 6853 6669     ,j))<s){f.dlShif
 80a4dc3:	5474 286f 2c71 2972 633b 732e 6275 6f54     tTo(q,r);c.subTo
 80a4dd3:	7228 632c 3b29 6877 6c69 2865 5b63 5d70     (r,c);while(c[p]
 80a4de3:	2d3c 732d 6329 732e 6275 6f54 7228 632c     <--s)c.subTo(r,c
 80a4df3:	3b29 7d7d 6669 6228 3d21 756e 6c6c 7b29     );}}if(b!=null){
 80a4e03:	2e63 7264 6853 6669 5474 286f 2c6a 2962     c.drShiftTo(j,b)
 80a4e13:	693b 2866 2167 683d 4229 6769 6e49 6574     ;if(g!=h)BigInte
 80a4e23:	6567 2e72 455a 4f52 732e 6275 6f54 6228     ger.ZERO.subTo(b
 80a4e33:	622c 3b29 637d 742e 6a3d 633b 632e 616c     ,b);}c.t=j;c.cla
 80a4e43:	706d 2928 693b 2866 3e69 2930 2e63 5372     mp();if(i>0)c.rS
 80a4e53:	6968 7466 6f54 6928 632c 3b29 6669 6728     hiftTo(i,c);if(g
 80a4e63:	303c 4229 6769 6e49 6574 6567 2e72 455a     <0)BigInteger.ZE
 80a4e73:	4f52 732e 6275 6f54 6328 632c 3b29 667d     RO.subTo(c,c);}f
 80a4e83:	6e75 7463 6f69 206e 6e62 6f4d 2864 2961     unction bnMod(a)
 80a4e93:	767b 7261 6220 6e3d 6962 2928 743b 6968     {var b=nbi();thi
 80a4ea3:	2e73 6261 2873 2e29 6964 5276 6d65 6f54     s.abs().divRemTo
 80a4eb3:	6128 6e2c 6c75 2c6c 2962 693b 2866 6874     (a,null,b);if(th
 80a4ec3:	7369 732e 303c 2626 2e62 6f63 706d 7261     is.s<0&&b.compar
 80a4ed3:	5465 286f 6942 4967 746e 6765 7265 5a2e     eTo(BigInteger.Z
 80a4ee3:	5245 294f 303e 6129 732e 6275 6f54 6228     ERO)>0)a.subTo(b
 80a4ef3:	622c 3b29 6572 7574 6e72 6220 7d3b 7566     ,b);return b;}fu
 80a4f03:	636e 6974 6e6f 4320 616c 7373 6369 6128     nction Classic(a
 80a4f13:	7b29 6874 7369 6d2e 613d 7d3b 7566 636e     ){this.m=a;}func
 80a4f23:	6974 6e6f 6320 6f43 766e 7265 2874 2961     tion cConvert(a)
 80a4f33:	697b 2866 2e61 3c73 7c30 617c 632e 6d6f     {if(a.s<0||a.com
 80a4f43:	6170 6572 6f54 7428 6968 2e73 296d 3d3e     pareTo(this.m)>=
 80a4f53:	2930 6572 7574 6e72 6120 6d2e 646f 7428     0)return a.mod(t
 80a4f63:	6968 2e73 296d 653b 736c 2065 6572 7574     his.m);else retu
 80a4f73:	6e72 6120 7d3b 7566 636e 6974 6e6f 6320     rn a;}function c
 80a4f83:	6552 6576 7472 6128 7b29 6572 7574 6e72     Revert(a){return
 80a4f93:	6120 7d3b 7566 636e 6974 6e6f 6320 6552      a;}function cRe
 80a4fa3:	7564 6563 6128 7b29 2e61 6964 5276 6d65     duce(a){a.divRem
 80a4fb3:	6f54 7428 6968 2e73 2c6d 756e 6c6c 612c     To(this.m,null,a
 80a4fc3:	3b29 667d 6e75 7463 6f69 206e 4d63 6c75     );}function cMul
 80a4fd3:	6f54 6128 622c 632c 7b29 2e61 756d 746c     To(a,b,c){a.mult
 80a4fe3:	7069 796c 6f54 6228 632c 3b29 6874 7369     iplyTo(b,c);this
 80a4ff3:	722e 6465 6375 2865 2963 7d3b 7566 636e     .reduce(c);}func
 80a5003:	6974 6e6f 6320 7153 5472 286f 2c61 2962     tion cSqrTo(a,b)
 80a5013:	617b 732e 7571 7261 5465 286f 2962 743b     {a.squareTo(b);t
 80a5023:	6968 2e73 6572 7564 6563 6228 3b29 437d     his.reduce(b);}C
 80a5033:	616c 7373 6369 702e 6f72 6f74 7974 6570     lassic.prototype
 80a5043:	632e 6e6f 6576 7472 633d 6f43 766e 7265     .convert=cConver
 80a5053:	3b74 6c43 7361 6973 2e63 7270 746f 746f     t;Classic.protot
 80a5063:	7079 2e65 6572 6576 7472 633d 6552 6576     ype.revert=cReve
 80a5073:	7472 433b 616c 7373 6369 702e 6f72 6f74     rt;Classic.proto
 80a5083:	7974 6570 722e 6465 6375 3d65 5263 6465     type.reduce=cRed
 80a5093:	6375 3b65 6c43 7361 6973 2e63 7270 746f     uce;Classic.prot
 80a50a3:	746f 7079 2e65 756d 546c 3d6f 4d63 6c75     otype.mulTo=cMul
 80a50b3:	6f54 433b 616c 7373 6369 702e 6f72 6f74     To;Classic.proto
 80a50c3:	7974 6570 732e 7271 6f54 633d 7153 5472     type.sqrTo=cSqrT
 80a50d3:	3b6f 7566 636e 6974 6e6f 6220 706e 6e49     o;function bnpIn
 80a50e3:	4476 6769 7469 2928 697b 2866 6874 7369     vDigit(){if(this
 80a50f3:	742e 313c 7229 7465 7275 206e 3b30 6176     .t<1)return 0;va
 80a5103:	2072 3d61 6874 7369 305b 3b5d 6669 2828     r a=this[0];if((
 80a5113:	2661 2931 3d3d 2930 6572 7574 6e72 3020     a&1)==0)return 0
 80a5123:	763b 7261 6220 613d 3326 623b 283d 2a62     ;var b=a&3;b=(b*
 80a5133:	3228 282d 2661 7830 2966 622a 2929 3026     (2-(a&0xf)*b))&0
 80a5143:	6678 623b 283d 2a62 3228 282d 2661 7830     xf;b=(b*(2-(a&0x
 80a5153:	6666 2a29 2962 2629 7830 6666 623b 283d     ff)*b))&0xff;b=(
 80a5163:	2a62 3228 282d 2828 2661 7830 6666 6666     b*(2-(((a&0xffff
 80a5173:	2a29 2962 3026 6678 6666 2966 2929 3026     )*b)&0xffff)))&0
 80a5183:	6678 6666 3b66 3d62 6228 282a 2d32 2a61     xffff;b=(b*(2-a*
 80a5193:	2562 6874 7369 442e 2956 2529 6874 7369     b%this.DV))%this
 80a51a3:	442e 3b56 6572 7574 6e72 6228 303e 3f29     .DV;return(b>0)?
 80a51b3:	6874 7369 442e 2d56 3a62 622d 7d3b 7566     this.DV-b:-b;}fu
 80a51c3:	636e 6974 6e6f 4d20 6e6f 6774 6d6f 7265     nction Montgomer
 80a51d3:	2879 2961 747b 6968 2e73 3d6d 3b61 6874     y(a){this.m=a;th
 80a51e3:	7369 6d2e 3d70 2e61 6e69 4476 6769 7469     is.mp=a.invDigit
 80a51f3:	2928 743b 6968 2e73 706d 3d6c 6874 7369     ();this.mpl=this
 80a5203:	6d2e 2670 7830 6637 6666 743b 6968 2e73     .mp&0x7fff;this.
 80a5213:	706d 3d68 6874 7369 6d2e 3e70 313e 3b35     mph=this.mp>>15;
 80a5223:	6874 7369 752e 3d6d 3128 3c3c 6128 442e     this.um=(1<<(a.D
 80a5233:	2d42 3531 2929 312d 743b 6968 2e73 746d     B-15))-1;this.mt
 80a5243:	3d32 2a32 2e61 3b74 667d 6e75 7463 6f69     2=2*a.t;}functio
 80a5253:	206e 6f6d 746e 6f43 766e 7265 2874 2961     n montConvert(a)
 80a5263:	767b 7261 6220 6e3d 6962 2928 613b 612e     {var b=nbi();a.a
 80a5273:	7362 2928 642e 536c 6968 7466 6f54 7428     bs().dlShiftTo(t
 80a5283:	6968 2e73 2e6d 2c74 2962 623b 642e 7669     his.m.t,b);b.div
 80a5293:	6552 546d 286f 6874 7369 6d2e 6e2c 6c75     RemTo(this.m,nul
 80a52a3:	2c6c 2962 693b 2866 2e61 3c73 2630 6226     l,b);if(a.s<0&&b
 80a52b3:	632e 6d6f 6170 6572 6f54 4228 6769 6e49     .compareTo(BigIn
 80a52c3:	6574 6567 2e72 455a 4f52 3e29 2930 6874     teger.ZERO)>0)th
 80a52d3:	7369 6d2e 732e 6275 6f54 6228 622c 3b29     is.m.subTo(b,b);
 80a52e3:	6572 7574 6e72 6220 7d3b 7566 636e 6974     return b;}functi
 80a52f3:	6e6f 6d20 6e6f 5274 7665 7265 2874 2961     on montRevert(a)
 80a5303:	767b 7261 6220 6e3d 6962 2928 613b 632e     {var b=nbi();a.c
 80a5313:	706f 5479 286f 2962 743b 6968 2e73 6572     opyTo(b);this.re
 80a5323:	7564 6563 6228 3b29 6572 7574 6e72 6220     duce(b);return b
 80a5333:	7d3b 7566 636e 6974 6e6f 6d20 6e6f 5274     ;}function montR
 80a5343:	6465 6375 2865 2961 777b 6968 656c 6128     educe(a){while(a
 80a5353:	742e 3d3c 6874 7369 6d2e 3274 6129 615b     .t<=this.mt2)a[a
 80a5363:	742e 2b2b 3d5d 3b30 6f66 2872 6176 2072     .t++]=0;for(var 
 80a5373:	3d62 3b30 3c62 6874 7369 6d2e 742e 2b3b     b=0;b<this.m.t;+
 80a5383:	622b 7b29 6176 2072 3d63 5b61 5d62 3026     +b){var c=a[b]&0
 80a5393:	3778 6666 3b66 6176 2072 3d64 6328 742a     x7fff;var d=(c*t
 80a53a3:	6968 2e73 706d 2b6c 2828 6328 742a 6968     his.mpl+(((c*thi
 80a53b3:	2e73 706d 2b68 6128 625b 3e5d 313e 2935     s.mph+(a[b]>>15)
 80a53c3:	742a 6968 2e73 706d 296c 7426 6968 2e73     *this.mpl)&this.
 80a53d3:	6d75 3c29 313c 2935 2629 2e61 4d44 633b     um)<<15))&a.DM;c
 80a53e3:	623d 742b 6968 2e73 2e6d 3b74 5b61 5d63     =b+this.m.t;a[c]
 80a53f3:	3d2b 6874 7369 6d2e 612e 286d 2c30 2c64     +=this.m.am(0,d,
 80a5403:	2c61 2c62 2c30 6874 7369 6d2e 742e 3b29     a,b,0,this.m.t);
 80a5413:	6877 6c69 2865 5b61 5d63 3d3e 2e61 5644     while(a[c]>=a.DV
 80a5423:	7b29 5b61 5d63 3d2d 2e61 5644 613b 2b5b     ){a[c]-=a.DV;a[+
 80a5433:	632b 2b5d 3b2b 7d7d 2e61 6c63 6d61 2870     +c]++;}}a.clamp(
 80a5443:	3b29 2e61 7264 6853 6669 5474 286f 6874     );a.drShiftTo(th
 80a5453:	7369 6d2e 742e 612c 3b29 6669 6128 632e     is.m.t,a);if(a.c
 80a5463:	6d6f 6170 6572 6f54 7428 6968 2e73 296d     ompareTo(this.m)
 80a5473:	3d3e 2930 2e61 7573 5462 286f 6874 7369     >=0)a.subTo(this
 80a5483:	6d2e 612c 3b29 667d 6e75 7463 6f69 206e     .m,a);}function 
 80a5493:	6f6d 746e 7153 5472 286f 2c61 2962 617b     montSqrTo(a,b){a
 80a54a3:	732e 7571 7261 5465 286f 2962 743b 6968     .squareTo(b);thi
 80a54b3:	2e73 6572 7564 6563 6228 3b29 667d 6e75     s.reduce(b);}fun
 80a54c3:	7463 6f69 206e 6f6d 746e 754d 546c 286f     ction montMulTo(
 80a54d3:	2c61 2c62 2963 617b 6d2e 6c75 6974 6c70     a,b,c){a.multipl
 80a54e3:	5479 286f 2c62 2963 743b 6968 2e73 6572     yTo(b,c);this.re
 80a54f3:	7564 6563 6328 3b29 4d7d 6e6f 6774 6d6f     duce(c);}Montgom
 80a5503:	7265 2e79 7270 746f 746f 7079 2e65 6f63     ery.prototype.co
 80a5513:	766e 7265 3d74 6f6d 746e 6f43 766e 7265     nvert=montConver
 80a5523:	3b74 6f4d 746e 6f67 656d 7972 702e 6f72     t;Montgomery.pro
 80a5533:	6f74 7974 6570 722e 7665 7265 3d74 6f6d     totype.revert=mo
 80a5543:	746e 6552 6576 7472 4d3b 6e6f 6774 6d6f     ntRevert;Montgom
 80a5553:	7265 2e79 7270 746f 746f 7079 2e65 6572     ery.prototype.re
 80a5563:	7564 6563 6d3d 6e6f 5274 6465 6375 3b65     duce=montReduce;
 80a5573:	6f4d 746e 6f67 656d 7972 702e 6f72 6f74     Montgomery.proto
 80a5583:	7974 6570 6d2e 6c75 6f54 6d3d 6e6f 4d74     type.mulTo=montM
 80a5593:	6c75 6f54 4d3b 6e6f 6774 6d6f 7265 2e79     ulTo;Montgomery.
 80a55a3:	7270 746f 746f 7079 2e65 7173 5472 3d6f     prototype.sqrTo=
 80a55b3:	6f6d 746e 7153 5472 3b6f 7566 636e 6974     montSqrTo;functi
 80a55c3:	6e6f 6220 706e 7349 7645 6e65 2928 727b     on bnpIsEven(){r
 80a55d3:	7465 7275 286e 7428 6968 2e73 3e74 2930     eturn((this.t>0)
 80a55e3:	283f 6874 7369 305b 265d 2931 743a 6968     ?(this[0]&1):thi
 80a55f3:	2e73 2973 3d3d 3b30 667d 6e75 7463 6f69     s.s)==0;}functio
 80a5603:	206e 6e62 4570 7078 6128 622c 7b29 6669     n bnpExp(a,b){if
 80a5613:	6128 303e 6678 6666 6666 6666 7c66 617c     (a>0xffffffff||a
 80a5623:	313c 7229 7465 7275 206e 6942 4967 746e     <1)return BigInt
 80a5633:	6765 7265 4f2e 454e 763b 7261 6320 6e3d     eger.ONE;var c=n
 80a5643:	6962 2928 642c 6e3d 6962 2928 652c 623d     bi(),d=nbi(),e=b
 80a5653:	632e 6e6f 6576 7472 7428 6968 2973 662c     .convert(this),f
 80a5663:	6e3d 6962 7374 6128 2d29 3b31 2e65 6f63     =nbits(a)-1;e.co
 80a5673:	7970 6f54 6328 3b29 6877 6c69 2865 2d2d     pyTo(c);while(--
 80a5683:	3e66 303d 7b29 2e62 7173 5472 286f 2c63     f>=0){b.sqrTo(c,
 80a5693:	2964 693b 2866 6128 2826 3c31 663c 2929     d);if((a&(1<<f))
 80a56a3:	303e 6229 6d2e 6c75 6f54 6428 652c 632c     >0)b.mulTo(d,e,c
 80a56b3:	3b29 6c65 6573 767b 7261 6720 633d 633b     );else{var g=c;c
 80a56c3:	643d 643b 673d 7d3b 727d 7465 7275 206e     =d;d=g;}}return 
 80a56d3:	2e62 6572 6576 7472 6328 3b29 667d 6e75     b.revert(c);}fun
 80a56e3:	7463 6f69 206e 6e62 6f4d 5064 776f 6e49     ction bnModPowIn
 80a56f3:	2874 2c61 2962 767b 7261 6320 693b 2866     t(a,b){var c;if(
 80a5703:	3c61 3532 7c36 627c 692e 4573 6576 286e     a<256||b.isEven(
 80a5713:	2929 3d63 656e 2077 6c43 7361 6973 2863     ))c=new Classic(
 80a5723:	2962 653b 736c 2065 3d63 656e 2077 6f4d     b);else c=new Mo
 80a5733:	746e 6f67 656d 7972 6228 3b29 6572 7574     ntgomery(b);retu
 80a5743:	6e72 7420 6968 2e73 7865 2870 2c61 2963     rn this.exp(a,c)
 80a5753:	7d3b 6942 4967 746e 6765 7265 702e 6f72     ;}BigInteger.pro
 80a5763:	6f74 7974 6570 632e 706f 5479 3d6f 6e62     totype.copyTo=bn
 80a5773:	4370 706f 5479 3b6f 6942 4967 746e 6765     pCopyTo;BigInteg
 80a5783:	7265 702e 6f72 6f74 7974 6570 662e 6f72     er.prototype.fro
 80a5793:	496d 746e 623d 706e 7246 6d6f 6e49 3b74     mInt=bnpFromInt;
 80a57a3:	6942 4967 746e 6765 7265 702e 6f72 6f74     BigInteger.proto
 80a57b3:	7974 6570 662e 6f72 536d 7274 6e69 3d67     type.fromString=
 80a57c3:	6e62 4670 6f72 536d 7274 6e69 3b67 6942     bnpFromString;Bi
 80a57d3:	4967 746e 6765 7265 702e 6f72 6f74 7974     gInteger.prototy
 80a57e3:	6570 632e 616c 706d 623d 706e 6c43 6d61     pe.clamp=bnpClam
 80a57f3:	3b70 6942 4967 746e 6765 7265 702e 6f72     p;BigInteger.pro
 80a5803:	6f74 7974 6570 642e 536c 6968 7466 6f54     totype.dlShiftTo
 80a5813:	623d 706e 4c44 6853 6669 5474 3b6f 6942     =bnpDLShiftTo;Bi
 80a5823:	4967 746e 6765 7265 702e 6f72 6f74 7974     gInteger.prototy
 80a5833:	6570 642e 5372 6968 7466 6f54 623d 706e     pe.drShiftTo=bnp
 80a5843:	5244 6853 6669 5474 3b6f 6942 4967 746e     DRShiftTo;BigInt
 80a5853:	6765 7265 702e 6f72 6f74 7974 6570 6c2e     eger.prototype.l
 80a5863:	6853 6669 5474 3d6f 6e62 4c70 6853 6669     ShiftTo=bnpLShif
 80a5873:	5474 3b6f 6942 4967 746e 6765 7265 702e     tTo;BigInteger.p
 80a5883:	6f72 6f74 7974 6570 722e 6853 6669 5474     rototype.rShiftT
 80a5893:	3d6f 6e62 5270 6853 6669 5474 3b6f 6942     o=bnpRShiftTo;Bi
 80a58a3:	4967 746e 6765 7265 702e 6f72 6f74 7974     gInteger.prototy
 80a58b3:	6570 732e 6275 6f54 623d 706e 7553 5462     pe.subTo=bnpSubT
 80a58c3:	3b6f 6942 4967 746e 6765 7265 702e 6f72     o;BigInteger.pro
 80a58d3:	6f74 7974 6570 6d2e 6c75 6974 6c70 5479     totype.multiplyT
 80a58e3:	3d6f 6e62 4d70 6c75 6974 6c70 5479 3b6f     o=bnpMultiplyTo;
 80a58f3:	6942 4967 746e 6765 7265 702e 6f72 6f74     BigInteger.proto
 80a5903:	7974 6570 732e 7571 7261 5465 3d6f 6e62     type.squareTo=bn
 80a5913:	5370 7571 7261 5465 3b6f 6942 4967 746e     pSquareTo;BigInt
 80a5923:	6765 7265 702e 6f72 6f74 7974 6570 642e     eger.prototype.d
 80a5933:	7669 6552 546d 3d6f 6e62 4470 7669 6552     ivRemTo=bnpDivRe
 80a5943:	546d 3b6f 6942 4967 746e 6765 7265 702e     mTo;BigInteger.p
 80a5953:	6f72 6f74 7974 6570 692e 766e 6944 6967     rototype.invDigi
 80a5963:	3d74 6e62 4970 766e 6944 6967 3b74 6942     t=bnpInvDigit;Bi
 80a5973:	4967 746e 6765 7265 702e 6f72 6f74 7974     gInteger.prototy
 80a5983:	6570 692e 4573 6576 3d6e 6e62 4970 4573     pe.isEven=bnpIsE
 80a5993:	6576 3b6e 6942 4967 746e 6765 7265 702e     ven;BigInteger.p
 80a59a3:	6f72 6f74 7974 6570 652e 7078 623d 706e     rototype.exp=bnp
 80a59b3:	7845 3b70 6942 4967 746e 6765 7265 702e     Exp;BigInteger.p
 80a59c3:	6f72 6f74 7974 6570 742e 536f 7274 6e69     rototype.toStrin
 80a59d3:	3d67 6e62 6f54 7453 6972 676e 423b 6769     g=bnToString;Big
 80a59e3:	6e49 6574 6567 2e72 7270 746f 746f 7079     Integer.prototyp
 80a59f3:	2e65 656e 6167 6574 623d 4e6e 6765 7461     e.negate=bnNegat
 80a5a03:	3b65 6942 4967 746e 6765 7265 702e 6f72     e;BigInteger.pro
 80a5a13:	6f74 7974 6570 612e 7362 623d 416e 7362     totype.abs=bnAbs
 80a5a23:	423b 6769 6e49 6574 6567 2e72 7270 746f     ;BigInteger.prot
 80a5a33:	746f 7079 2e65 6f63 706d 7261 5465 3d6f     otype.compareTo=
 80a5a43:	6e62 6f43 706d 7261 5465 3b6f 6942 4967     bnCompareTo;BigI
 80a5a53:	746e 6765 7265 702e 6f72 6f74 7974 6570     nteger.prototype
 80a5a63:	622e 7469 654c 676e 6874 623d 426e 7469     .bitLength=bnBit
 80a5a73:	654c 676e 6874 423b 6769 6e49 6574 6567     Length;BigIntege
 80a5a83:	2e72 7270 746f 746f 7079 2e65 6f6d 3d64     r.prototype.mod=
 80a5a93:	6e62 6f4d 3b64 6942 4967 746e 6765 7265     bnMod;BigInteger
 80a5aa3:	702e 6f72 6f74 7974 6570 6d2e 646f 6f50     .prototype.modPo
 80a5ab3:	4977 746e 623d 4d6e 646f 6f50 4977 746e     wInt=bnModPowInt
 80a5ac3:	423b 6769 6e49 6574 6567 2e72 455a 4f52     ;BigInteger.ZERO
 80a5ad3:	6e3d 7662 3028 3b29 6942 4967 746e 6765     =nbv(0);BigInteg
 80a5ae3:	7265 4f2e 454e 6e3d 7662 3128 3b29 6800     er.ONE=nbv(1);.h
 80a5af3:	6e61 6c64 6e69 2067 6170 6567 2520 0073     andling page %s.
 80a5b03:	692f 646e 7865 7300 6e65 6964 676e 7220     /index.sending r
 80a5b13:	6465 7269 6365 0074 6f4c 6163 6974 6e6f     edirect.Location
 80a5b23:	203a 692f 646e 7865 682e 6d74 0d6c 000a     : /index.html...
 80a5b33:	6574 7478 702f 616c 6e69 6f00 006e 6c66     text/plain.on.fl
 80a5b43:	6d61 0065 692f 646e 7865 682e 6d74 006c     ame./index.html.
 80a5b53:	6574 7478 682f 6d74 006c 722f 6173 752d     text/html./rsa-u
 80a5b63:	6974 736c 722f 6173 6a2e 0073 7061 6c70     tils/rsa.js.appl
 80a5b73:	6369 7461 6f69 2f6e 616a 6176 6373 6972     ication/javascri
 80a5b83:	7470 2f00 7473 6c79 2e65 7363 0073 6574     pt./style.css.te
 80a5b93:	7478 632f 7373 2f00 7372 2d61 7475 6c69     xt/css./rsa-util
 80a5ba3:	2f73 6e72 2e67 736a 2f00 7372 2d61 7475     s/rng.js./rsa-ut
 80a5bb3:	6c69 2f73 736a 6e62 325f 6a2e 0073 722f     ils/jsbn_2.js./r
 80a5bc3:	6173 752d 6974 736c 6a2f 6273 5f6e 2e31     sa-utils/jsbn_1.
 80a5bd3:	736a 2f00 6373 6972 7470 6a2e 0073 722f     js./script.js./r
 80a5be3:	6173 752d 6974 736c 702f 6e72 3467 6a2e     sa-utils/prng4.j
 80a5bf3:	0073                                        s.

080a5bf5 <_ZL8prng4_js>:
 80a5bf5:	7566 636e 6974 6e6f 4120 6372 6f66 7275     function Arcfour
 80a5c05:	2928 747b 6968 2e73 3d69 3b30 6874 7369     (){this.i=0;this
 80a5c15:	6a2e 303d 743b 6968 2e73 3d53 656e 2077     .j=0;this.S=new 
 80a5c25:	7241 6172 2879 3b29 667d 6e75 7463 6f69     Array();}functio
 80a5c35:	206e 5241 3443 6e69 7469 6128 7b29 6176     n ARC4init(a){va
 80a5c45:	2072 2c62 2c63 3b64 6f66 2872 3d62 3b30     r b,c,d;for(b=0;
 80a5c55:	3c62 3532 3b36 2b2b 2962 6874 7369 532e     b<256;++b)this.S
 80a5c65:	625b 3d5d 3b62 3d63 3b30 6f66 2872 3d62     [b]=b;c=0;for(b=
 80a5c75:	3b30 3c62 3532 3b36 2b2b 2962 637b 283d     0;b<256;++b){c=(
 80a5c85:	2b63 6874 7369 532e 625b 2b5d 5b61 2562     c+this.S[b]+a[b%
 80a5c95:	2e61 656c 676e 6874 295d 3226 3535 643b     a.length])&255;d
 80a5ca5:	743d 6968 2e73 5b53 5d62 743b 6968 2e73     =this.S[b];this.
 80a5cb5:	5b53 5d62 743d 6968 2e73 5b53 5d63 743b     S[b]=this.S[c];t
 80a5cc5:	6968 2e73 5b53 5d63 643d 7d3b 6874 7369     his.S[c]=d;}this
 80a5cd5:	692e 303d 743b 6968 2e73 3d6a 3b30 667d     .i=0;this.j=0;}f
 80a5ce5:	6e75 7463 6f69 206e 5241 3443 656e 7478     unction ARC4next
 80a5cf5:	2928 767b 7261 6120 743b 6968 2e73 3d69     (){var a;this.i=
 80a5d05:	7428 6968 2e73 2b69 2931 3226 3535 743b     (this.i+1)&255;t
 80a5d15:	6968 2e73 3d6a 7428 6968 2e73 2b6a 6874     his.j=(this.j+th
 80a5d25:	7369 532e 745b 6968 2e73 5d69 2629 3532     is.S[this.i])&25
 80a5d35:	3b35 3d61 6874 7369 532e 745b 6968 2e73     5;a=this.S[this.
 80a5d45:	5d69 743b 6968 2e73 5b53 6874 7369 692e     i];this.S[this.i
 80a5d55:	3d5d 6874 7369 532e 745b 6968 2e73 5d6a     ]=this.S[this.j]
 80a5d65:	743b 6968 2e73 5b53 6874 7369 6a2e 3d5d     ;this.S[this.j]=
 80a5d75:	3b61 6572 7574 6e72 7420 6968 2e73 5b53     a;return this.S[
 80a5d85:	6128 742b 6968 2e73 5b53 6874 7369 692e     (a+this.S[this.i
 80a5d95:	295d 3226 3535 3b5d 417d 6372 6f66 7275     ])&255];}Arcfour
 80a5da5:	702e 6f72 6f74 7974 6570 692e 696e 3d74     .prototype.init=
 80a5db5:	5241 3443 6e69 7469 413b 6372 6f66 7275     ARC4init;Arcfour
 80a5dc5:	702e 6f72 6f74 7974 6570 6e2e 7865 3d74     .prototype.next=
 80a5dd5:	5241 3443 656e 7478 663b 6e75 7463 6f69     ARC4next;functio
 80a5de5:	206e 7270 676e 6e5f 7765 7473 7461 2865     n prng_newstate(
 80a5df5:	7b29 6572 7574 6e72 6e20 7765 4120 6372     ){return new Arc
 80a5e05:	6f66 7275 2928 7d3b 6176 2072 6e72 5f67     four();}var rng_
 80a5e15:	7370 7a69 3d65 3532 3b36 6600                    psize=256;.

080a5e20 <_ZL6rsa_js>:
 80a5e20:	7566 636e 6974 6e6f 7020 7261 6573 6942     function parseBi
 80a5e30:	4967 746e 6128 622c 7b29 6572 7574 6e72     gInt(a,b){return
 80a5e40:	6e20 7765 4220 6769 6e49 6574 6567 2872      new BigInteger(
 80a5e50:	2c61 2962 7d3b 7566 636e 6974 6e6f 6c20     a,b);}function l
 80a5e60:	6e69 6265 6b72 6128 622c 7b29 6176 2072     inebrk(a,b){var 
 80a5e70:	3d63 2727 763b 7261 6420 303d 773b 6968     c='';var d=0;whi
 80a5e80:	656c 6428 622b 613c 6c2e 6e65 7467 2968     le(d+b<a.length)
 80a5e90:	637b 3d2b 2e61 7573 7362 7274 6e69 2867     {c+=a.substring(
 80a5ea0:	2c64 2b64 2962 272b 6e5c 3b27 2b64 623d     d,d+b)+'\n';d+=b
 80a5eb0:	7d3b 6572 7574 6e72 6320 612b 732e 6275     ;}return c+a.sub
 80a5ec0:	7473 6972 676e 6428 612c 6c2e 6e65 7467     string(d,a.lengt
 80a5ed0:	2968 7d3b 7566 636e 6974 6e6f 6220 7479     h);}function byt
 80a5ee0:	3265 6548 2878 2961 697b 2866 3c61 7830     e2Hex(a){if(a<0x
 80a5ef0:	3031 7229 7465 7275 206e 3027 2b27 2e61     10)return '0'+a.
 80a5f00:	6f74 7453 6972 676e 3128 2936 653b 736c     toString(16);els
 80a5f10:	2065 6572 7574 6e72 6120 742e 536f 7274     e return a.toStr
 80a5f20:	6e69 2867 3631 3b29 667d 6e75 7463 6f69     ing(16);}functio
 80a5f30:	206e 6b70 7363 7031 6461 2832 2c61 2962     n pkcs1pad2(a,b)
 80a5f40:	697b 2866 3c62 2e61 656c 676e 6874 312b     {if(b<a.length+1
 80a5f50:	2931 617b 656c 7472 2728 654d 7373 6761     1){alert('Messag
 80a5f60:	2065 6f74 206f 6f6c 676e 6620 726f 5220     e too long for R
 80a5f70:	4153 2927 723b 7465 7275 206e 756e 6c6c     SA');return null
 80a5f80:	7d3b 6176 2072 3d63 656e 2077 7241 6172     ;}var c=new Arra
 80a5f90:	2879 3b29 6176 2072 3d64 2e61 656c 676e     y();var d=a.leng
 80a5fa0:	6874 312d 773b 6968 656c 6428 3d3e 2630     th-1;while(d>=0&
 80a5fb0:	6226 303e 7b29 6176 2072 3d65 2e61 6863     &b>0){var e=a.ch
 80a5fc0:	7261 6f43 6564 7441 6428 2d2d 3b29 6669     arCodeAt(d--);if
 80a5fd0:	6528 313c 3832 6329 2d5b 622d 3d5d 3b65     (e<128)c[--b]=e;
 80a5fe0:	6c65 6573 6920 2866 6528 313e 3732 2629     else if((e>127)&
 80a5ff0:	2826 3c65 3032 3834 2929 637b 2d5b 622d     &(e<2048)){c[--b
 80a6000:	3d5d 6528 3626 2933 317c 3832 633b 2d5b     ]=(e&63)|128;c[-
 80a6010:	622d 3d5d 6528 3e3e 2936 317c 3239 7d3b     -b]=(e>>6)|192;}
 80a6020:	6c65 6573 637b 2d5b 622d 3d5d 6528 3626     else{c[--b]=(e&6
 80a6030:	2933 317c 3832 633b 2d5b 622d 3d5d 2828     3)|128;c[--b]=((
 80a6040:	3e65 363e 2629 3336 7c29 3231 3b38 5b63     e>>6)&63)|128;c[
 80a6050:	2d2d 5d62 283d 3e65 313e 2932 327c 3432     --b]=(e>>12)|224
 80a6060:	7d3b 637d 2d5b 622d 3d5d 3b30 6176 2072     ;}}c[--b]=0;var 
 80a6070:	3d66 656e 2077 6553 7563 6572 6152 646e     f=new SecureRand
 80a6080:	6d6f 2928 763b 7261 6720 6e3d 7765 4120     om();var g=new A
 80a6090:	7272 7961 2928 773b 6968 656c 6228 323e     rray();while(b>2
 80a60a0:	7b29 5b67 5d30 303d 773b 6968 656c 6728     ){g[0]=0;while(g
 80a60b0:	305b 3d5d 303d 6629 6e2e 7865 4274 7479     [0]==0)f.nextByt
 80a60c0:	7365 6728 3b29 5b63 2d2d 5d62 673d 305b     es(g);c[--b]=g[0
 80a60d0:	3b5d 637d 2d5b 622d 3d5d 3b32 5b63 2d2d     ];}c[--b]=2;c[--
 80a60e0:	5d62 303d 723b 7465 7275 206e 656e 2077     b]=0;return new 
 80a60f0:	6942 4967 746e 6765 7265 6328 3b29 667d     BigInteger(c);}f
 80a6100:	6e75 7463 6f69 206e 5352 4b41 7965 2928     unction RSAKey()
 80a6110:	747b 6968 2e73 3d6e 756e 6c6c 743b 6968     {this.n=null;thi
 80a6120:	2e73 3d65 3b30 6874 7369 642e 6e3d 6c75     s.e=0;this.d=nul
 80a6130:	3b6c 6874 7369 702e 6e3d 6c75 3b6c 6874     l;this.p=null;th
 80a6140:	7369 712e 6e3d 6c75 3b6c 6874 7369 642e     is.q=null;this.d
 80a6150:	706d 3d31 756e 6c6c 743b 6968 2e73 6d64     mp1=null;this.dm
 80a6160:	3171 6e3d 6c75 3b6c 6874 7369 632e 656f     q1=null;this.coe
 80a6170:	6666 6e3d 6c75 3b6c 667d 6e75 7463 6f69     ff=null;}functio
 80a6180:	206e 5352 5341 7465 7550 6c62 6369 6128     n RSASetPublic(a
 80a6190:	622c 7b29 6669 6128 3d21 756e 6c6c 2626     ,b){if(a!=null&&
 80a61a0:	2162 6e3d 6c75 266c 6126 6c2e 6e65 7467     b!=null&&a.lengt
 80a61b0:	3e68 2630 6226 6c2e 6e65 7467 3e68 2930     h>0&&b.length>0)
 80a61c0:	747b 6968 2e73 3d6e 6170 7372 4265 6769     {this.n=parseBig
 80a61d0:	6e49 2874 2c61 3631 3b29 6874 7369 652e     Int(a,16);this.e
 80a61e0:	703d 7261 6573 6e49 2874 2c62 3631 3b29     =parseInt(b,16);
 80a61f0:	657d 736c 2065 6c61 7265 2874 4927 766e     }else alert('Inv
 80a6200:	6c61 6469 5220 4153 7020 6275 696c 2063     alid RSA public 
 80a6210:	656b 2779 3b29 667d 6e75 7463 6f69 206e     key');}function 
 80a6220:	5352 4441 506f 6275 696c 2863 2961 727b     RSADoPublic(a){r
 80a6230:	7465 7275 206e 2e61 6f6d 5064 776f 6e49     eturn a.modPowIn
 80a6240:	2874 6874 7369 652e 742c 6968 2e73 296e     t(this.e,this.n)
 80a6250:	7d3b 7566 636e 6974 6e6f 5220 4153 6e45     ;}function RSAEn
 80a6260:	7263 7079 2874 2961 767b 7261 6220 703d     crypt(a){var b=p
 80a6270:	636b 3173 6170 3264 6128 282c 6874 7369     kcs1pad2(a,(this
 80a6280:	6e2e 622e 7469 654c 676e 6874 2928 372b     .n.bitLength()+7
 80a6290:	3e29 333e 3b29 6669 6228 3d3d 756e 6c6c     )>>3);if(b==null
 80a62a0:	7229 7465 7275 206e 756e 6c6c 763b 7261     )return null;var
 80a62b0:	6320 743d 6968 2e73 6f64 7550 6c62 6369      c=this.doPublic
 80a62c0:	6228 3b29 6669 6328 3d3d 756e 6c6c 7229     (b);if(c==null)r
 80a62d0:	7465 7275 206e 756e 6c6c 763b 7261 6420     eturn null;var d
 80a62e0:	633d 742e 536f 7274 6e69 2867 3631 3b29     =c.toString(16);
 80a62f0:	6669 2828 2e64 656c 676e 6874 3126 3d29     if((d.length&1)=
 80a6300:	303d 7229 7465 7275 206e 3b64 6c65 6573     =0)return d;else
 80a6310:	7220 7465 7275 206e 3027 2b27 3b64 527d      return '0'+d;}R
 80a6320:	4153 654b 2e79 7270 746f 746f 7079 2e65     SAKey.prototype.
 80a6330:	6f64 7550 6c62 6369 523d 4153 6f44 7550     doPublic=RSADoPu
 80a6340:	6c62 6369 523b 4153 654b 2e79 7270 746f     blic;RSAKey.prot
 80a6350:	746f 7079 2e65 6573 5074 6275 696c 3d63     otype.setPublic=
 80a6360:	5352 5341 7465 7550 6c62 6369 523b 4153     RSASetPublic;RSA
 80a6370:	654b 2e79 7270 746f 746f 7079 2e65 6e65     Key.prototype.en
 80a6380:	7263 7079 3d74 5352 4541 636e 7972 7470     crypt=RSAEncrypt
 80a6390:	003b                                        ;.

080a6392 <_ZL10index_html>:
 80a6392:	213c 4f44 5443 5059 2045 7468 6c6d 3c3e     <!DOCTYPE html><
 80a63a2:	7468 6c6d 3c3e 6568 6461 3c3e 656d 6174     html><head><meta
 80a63b2:	6e20 6d61 3d65 7627 6569 7077 726f 2774      name='viewport'
 80a63c2:	6320 6e6f 6574 746e 273d 6977 7464 3d68      content='width=
 80a63d2:	6564 6976 6563 772d 6469 6874 202c 6e69     device-width, in
 80a63e2:	7469 6169 2d6c 6373 6c61 3d65 2731 3c3e     itial-scale=1'><
 80a63f2:	6974 6c74 3e65 6553 7574 2070 6f79 7275     title>Setup your
 80a6402:	6420 7665 6369 3c65 742f 7469 656c 3c3e      device</title><
 80a6412:	696c 6b6e 7220 6c65 273d 7473 6c79 7365     link rel='styles
 80a6422:	6568 7465 2027 7974 6570 273d 6574 7478     heet' type='text
 80a6432:	632f 7373 2027 7268 6665 273d 7473 6c79     /css' href='styl
 80a6442:	2e65 7363 2773 3c3e 682f 6165 3e64 623c     e.css'></head><b
 80a6452:	646f 3e79 683c 3e31 6f43 6e6e 6365 2074     ody><h1>Connect 
 80a6462:	656d 7420 206f 6f79 7275 5720 4669 2169     me to your WiFi!
 80a6472:	2f3c 3168 3c3e 3368 4d3e 2079 6564 6976     </h1><h3>My devi
 80a6482:	6563 4920 3a44 2f3c 3368 3c3e 6e69 7570     ce ID:</h3><inpu
 80a6492:	2074 7974 6570 743d 7865 2074 6469 273d     t type=text id='
 80a64a2:	6564 6976 6563 692d 2764 7320 7a69 3d65     device-id' size=
 80a64b2:	3227 2735 7620 6c61 6575 273d 2027 6964     '25' value='' di
 80a64c2:	6173 6c62 6465 3e2f 623c 7475 6f74 206e     sabled/><button 
 80a64d2:	7974 6570 273d 7562 7474 6e6f 2027 6c63     type='button' cl
 80a64e2:	7361 3d73 6927 706e 7475 682d 6c65 6570     ass='input-helpe
 80a64f2:	2772 6920 3d64 6327 706f 2d79 7562 7474     r' id='copy-butt
 80a6502:	6e6f 3e27 6f43 7970 2f3c 7562 7474 6e6f     on'>Copy</button
 80a6512:	3c3e 6964 2076 6469 273d 6373 6e61 642d     ><div id='scan-d
 80a6522:	7669 3e27 683c 3e33 6353 6e61 6620 726f     iv'><h3>Scan for
 80a6532:	7620 7369 6269 656c 5720 4669 2069 656e      visible WiFi ne
 80a6542:	7774 726f 736b 2f3c 3368 3c3e 7562 7474     tworks</h3><butt
 80a6552:	6e6f 6920 3d64 7327 6163 2d6e 7562 7474     on id='scan-butt
 80a6562:	6e6f 2027 7974 6570 273d 7562 7474 6e6f     on' type='button
 80a6572:	3e27 6353 6e61 2f3c 7562 7474 6e6f 3c3e     '>Scan</button><
 80a6582:	642f 7669 3c3e 6964 2076 6469 273d 656e     /div><div id='ne
 80a6592:	7774 726f 736b 642d 7669 3e27 2f3c 6964     tworks-div'></di
 80a65a2:	3e76 643c 7669 6920 3d64 6327 6e6f 656e     v><div id='conne
 80a65b2:	7463 642d 7669 2027 7473 6c79 3d65 6427     ct-div' style='d
 80a65c2:	7369 6c70 7961 203a 6f6e 656e 3e27 703c     isplay: none'><p
 80a65d2:	443e 6e6f 7427 7320 6565 7920 756f 2072     >Don't see your 
 80a65e2:	656e 7774 726f 3f6b 4d20 766f 2065 656d     network? Move me
 80a65f2:	6320 6f6c 6573 2072 6f74 7920 756f 2072      closer to your 
 80a6602:	6f72 7475 7265 202c 6874 6e65 7220 2d65     router, then re-
 80a6612:	6373 6e61 3c2e 702f 3c3e 6f66 6d72 6920     scan.</p><form i
 80a6622:	3d64 6327 6e6f 656e 7463 662d 726f 276d     d='connect-form'
 80a6632:	3c3e 6e69 7570 2074 7974 6570 273d 6170     ><input type='pa
 80a6642:	7373 6f77 6472 2027 6469 273d 6170 7373     ssword' id='pass
 80a6652:	6f77 6472 2027 6973 657a 273d 3532 2027     word' size='25' 
 80a6662:	6c70 6361 6865 6c6f 6564 3d72 7027 7361     placeholder='pas
 80a6672:	7773 726f 2764 3e2f 623c 7475 6f74 206e     sword'/><button 
 80a6682:	7974 6570 273d 7562 7474 6e6f 2027 6c63     type='button' cl
 80a6692:	7361 3d73 6927 706e 7475 682d 6c65 6570     ass='input-helpe
 80a66a2:	2772 6920 3d64 7327 6f68 2d77 7562 7474     r' id='show-butt
 80a66b2:	6e6f 3e27 6853 776f 2f3c 7562 7474 6e6f     on'>Show</button
 80a66c2:	3c3e 7562 7474 6e6f 7420 7079 3d65 7327     ><button type='s
 80a66d2:	6275 696d 2774 6920 3d64 6327 6e6f 656e     ubmit' id='conne
 80a66e2:	7463 622d 7475 6f74 276e 433e 6e6f 656e     ct-button'>Conne
 80a66f2:	7463 2f3c 7562 7474 6e6f 3c3e 662f 726f     ct</button></for
 80a6702:	3e6d 2f3c 6964 3e76 733c 7263 7069 2074     m></div><script 
 80a6712:	7273 3d63 7227 6173 752d 6974 736c 6a2f     src='rsa-utils/j
 80a6722:	6273 5f6e 2e31 736a 3e27 2f3c 6373 6972     sbn_1.js'></scri
 80a6732:	7470 3c3e 6373 6972 7470 7320 6372 273d     pt><script src='
 80a6742:	7372 2d61 7475 6c69 2f73 736a 6e62 325f     rsa-utils/jsbn_2
 80a6752:	6a2e 2773 3c3e 732f 7263 7069 3e74 733c     .js'></script><s
 80a6762:	7263 7069 2074 7273 3d63 7227 6173 752d     cript src='rsa-u
 80a6772:	6974 736c 702f 6e72 3467 6a2e 2773 3c3e     tils/prng4.js'><
 80a6782:	732f 7263 7069 3e74 733c 7263 7069 2074     /script><script 
 80a6792:	7273 3d63 7227 6173 752d 6974 736c 722f     src='rsa-utils/r
 80a67a2:	676e 6a2e 2773 3c3e 732f 7263 7069 3e74     ng.js'></script>
 80a67b2:	733c 7263 7069 2074 7273 3d63 7227 6173     <script src='rsa
 80a67c2:	752d 6974 736c 722f 6173 6a2e 2773 3c3e     -utils/rsa.js'><
 80a67d2:	732f 7263 7069 3e74 733c 7263 7069 2074     /script><script 
 80a67e2:	7273 3d63 7327 7263 7069 2e74 736a 3e27     src='script.js'>
 80a67f2:	2f3c 6373 6972 7470 3c3e 622f 646f 3e79     </script></body>
 80a6802:	2f3c 7468 6c6d 003e                         </html>.

080a680a <_ZL9jsbn_1_js>:
 80a680a:	6176 2072 6264 7469 3b73 6176 2072 6163     var dbits;var ca
 80a681a:	616e 7972 303d 6478 6165 6264 6565 6366     nary=0xdeadbeefc
 80a682a:	6661 3b65 6176 2072 5f6a 6d6c 283d 6328     afe;var j_lm=((c
 80a683a:	6e61 7261 2679 7830 6666 6666 6666 3d29     anary&0xffffff)=
 80a684a:	303d 6578 6366 6661 2965 663b 6e75 7463     =0xefcafe);funct
 80a685a:	6f69 206e 6942 4967 746e 6765 7265 6128     ion BigInteger(a
 80a686a:	622c 632c 7b29 6669 6128 3d21 756e 6c6c     ,b,c){if(a!=null
 80a687a:	6929 2866 6e27 6d75 6562 2772 3d3d 7974     )if('number'==ty
 80a688a:	6570 666f 6120 7429 6968 2e73 7266 6d6f     peof a)this.from
 80a689a:	754e 626d 7265 6128 622c 632c 3b29 6c65     Number(a,b,c);el
 80a68aa:	6573 6920 2866 3d62 6e3d 6c75 266c 2726     se if(b==null&&'
 80a68ba:	7473 6972 676e 2127 743d 7079 6f65 2066     string'!=typeof 
 80a68ca:	2961 6874 7369 662e 6f72 536d 7274 6e69     a)this.fromStrin
 80a68da:	2867 2c61 3532 2936 653b 736c 2065 6874     g(a,256);else th
 80a68ea:	7369 662e 6f72 536d 7274 6e69 2867 2c61     is.fromString(a,
 80a68fa:	2962 7d3b 7566 636e 6974 6e6f 6e20 6962     b);}function nbi
 80a690a:	2928 727b 7465 7275 206e 656e 2077 6942     (){return new Bi
 80a691a:	4967 746e 6765 7265 6e28 6c75 296c 7d3b     gInteger(null);}
 80a692a:	7566 636e 6974 6e6f 6120 316d 6128 622c     function am1(a,b
 80a693a:	632c 642c 652c 662c 7b29 6877 6c69 2865     ,c,d,e,f){while(
 80a694a:	2d2d 3e66 303d 7b29 6176 2072 3d67 2a62     --f>=0){var g=b*
 80a695a:	6874 7369 615b 2b2b 2b5d 5b63 5d64 652b     this[a++]+c[d]+e
 80a696a:	653b 4d3d 7461 2e68 6c66 6f6f 2872 2f67     ;e=Math.floor(g/
 80a697a:	7830 3034 3030 3030 2930 633b 645b 2b2b     0x4000000);c[d++
 80a698a:	3d5d 2667 7830 6633 6666 6666 3b66 727d     ]=g&0x3ffffff;}r
 80a699a:	7465 7275 206e 3b65 667d 6e75 7463 6f69     eturn e;}functio
 80a69aa:	206e 6d61 2832 2c61 2c62 2c63 2c64 2c65     n am2(a,b,c,d,e,
 80a69ba:	2966 767b 7261 6720 623d 3026 3778 6666     f){var g=b&0x7ff
 80a69ca:	2c66 3d68 3e62 313e 3b35 6877 6c69 2865     f,h=b>>15;while(
 80a69da:	2d2d 3e66 303d 7b29 6176 2072 3d69 6874     --f>=0){var i=th
 80a69ea:	7369 615b 265d 7830 6637 6666 763b 7261     is[a]&0x7fff;var
 80a69fa:	6a20 743d 6968 5b73 2b61 5d2b 3e3e 3531      j=this[a++]>>15
 80a6a0a:	763b 7261 6b20 683d 692a 6a2b 672a 693b     ;var k=h*i+j*g;i
 80a6a1a:	673d 692a 282b 6b28 3026 3778 6666 2966     =g*i+((k&0x7fff)
 80a6a2a:	3c3c 3531 2b29 5b63 5d64 282b 2665 7830     <<15)+c[d]+(e&0x
 80a6a3a:	6633 6666 6666 6666 3b29 3d65 6928 3e3e     3fffffff);e=(i>>
 80a6a4a:	333e 2930 282b 3e6b 3e3e 3531 2b29 2a68     >30)+(k>>>15)+h*
 80a6a5a:	2b6a 6528 3e3e 333e 2930 633b 645b 2b2b     j+(e>>>30);c[d++
 80a6a6a:	3d5d 2669 7830 6633 6666 6666 6666 7d3b     ]=i&0x3fffffff;}
 80a6a7a:	6572 7574 6e72 6520 7d3b 7566 636e 6974     return e;}functi
 80a6a8a:	6e6f 6120 336d 6128 622c 632c 642c 652c     on am3(a,b,c,d,e
 80a6a9a:	662c 7b29 6176 2072 3d67 2662 7830 6633     ,f){var g=b&0x3f
 80a6aaa:	6666 682c 623d 3e3e 3431 773b 6968 656c     ff,h=b>>14;while
 80a6aba:	2d28 662d 3d3e 2930 767b 7261 6920 743d     (--f>=0){var i=t
 80a6aca:	6968 5b73 5d61 3026 3378 6666 3b66 6176     his[a]&0x3fff;va
 80a6ada:	2072 3d6a 6874 7369 615b 2b2b 3e5d 313e     r j=this[a++]>>1
 80a6aea:	3b34 6176 2072 3d6b 2a68 2b69 2a6a 3b67     4;var k=h*i+j*g;
 80a6afa:	3d69 2a67 2b69 2828 266b 7830 6633 6666     i=g*i+((k&0x3fff
 80a6b0a:	3c29 313c 2934 632b 645b 2b5d 3b65 3d65     )<<14)+c[d]+e;e=
 80a6b1a:	6928 3e3e 3832 2b29 6b28 3e3e 3431 2b29     (i>>28)+(k>>14)+
 80a6b2a:	2a68 3b6a 5b63 2b64 5d2b 693d 3026 6678     h*j;c[d++]=i&0xf
 80a6b3a:	6666 6666 6666 7d3b 6572 7574 6e72 6520     ffffff;}return e
 80a6b4a:	7d3b 6669 6a28 6c5f 266d 2826 616e 6976     ;}if(j_lm&&(navi
 80a6b5a:	6167 6f74 2e72 7061 4e70 6d61 3d65 273d     gator.appName=='
 80a6b6a:	694d 7263 736f 666f 2074 6e49 6574 6e72     Microsoft Intern
 80a6b7a:	7465 4520 7078 6f6c 6572 2772 2929 427b     et Explorer')){B
 80a6b8a:	6769 6e49 6574 6567 2e72 7270 746f 746f     igInteger.protot
 80a6b9a:	7079 2e65 6d61 613d 326d 643b 6962 7374     ype.am=am2;dbits
 80a6baa:	333d 3b30 657d 736c 2065 6669 6a28 6c5f     =30;}else if(j_l
 80a6bba:	266d 2826 616e 6976 6167 6f74 2e72 7061     m&&(navigator.ap
 80a6bca:	4e70 6d61 2165 273d 654e 7374 6163 6570     pName!='Netscape
 80a6bda:	2927 7b29 6942 4967 746e 6765 7265 702e     ')){BigInteger.p
 80a6bea:	6f72 6f74 7974 6570 612e 3d6d 6d61 3b31     rototype.am=am1;
 80a6bfa:	6264 7469 3d73 3632 7d3b 6c65 6573 427b     dbits=26;}else{B
 80a6c0a:	6769 6e49 6574 6567 2e72 7270 746f 746f     igInteger.protot
 80a6c1a:	7079 2e65 6d61 613d 336d 643b 6962 7374     ype.am=am3;dbits
 80a6c2a:	323d 3b38 427d 6769 6e49 6574 6567 2e72     =28;}BigInteger.
 80a6c3a:	7270 746f 746f 7079 2e65 4244 643d 6962     prototype.DB=dbi
 80a6c4a:	7374 423b 6769 6e49 6574 6567 2e72 7270     ts;BigInteger.pr
 80a6c5a:	746f 746f 7079 2e65 4d44 283d 3128 3c3c     ototype.DM=((1<<
 80a6c6a:	6264 7469 2973 312d 3b29 6942 4967 746e     dbits)-1);BigInt
 80a6c7a:	6765 7265 702e 6f72 6f74 7974 6570 442e     eger.prototype.D
 80a6c8a:	3d56 3128 3c3c 6264 7469 2973 763b 7261     V=(1<<dbits);var
 80a6c9a:	4220 5f49 5046 353d 3b32 6942 4967 746e      BI_FP=52;BigInt
 80a6caa:	6765 7265 702e 6f72 6f74 7974 6570 462e     eger.prototype.F
 80a6cba:	3d56 614d 6874 702e 776f 3228 422c 5f49     V=Math.pow(2,BI_
 80a6cca:	5046 3b29 6942 4967 746e 6765 7265 702e     FP);BigInteger.p
 80a6cda:	6f72 6f74 7974 6570 462e 3d31 4942 465f     rototype.F1=BI_F
 80a6cea:	2d50 6264 7469 3b73 6942 4967 746e 6765     P-dbits;BigInteg
 80a6cfa:	7265 702e 6f72 6f74 7974 6570 462e 3d32     er.prototype.F2=
 80a6d0a:	2a32 6264 7469 2d73 4942 465f 3b50 6176     2*dbits-BI_FP;va
 80a6d1a:	2072 4942 525f 3d4d 3027 3231 3433 3635     r BI_RM='0123456
 80a6d2a:	3837 6139 6362 6564 6766 6968 6b6a 6d6c     789abcdefghijklm
 80a6d3a:	6f6e 7170 7372 7574 7776 7978 277a 763b     nopqrstuvwxyz';v
 80a6d4a:	7261 4220 5f49 4352 6e3d 7765 4120 7272     ar BI_RC=new Arr
 80a6d5a:	7961 2928 763b 7261 7220 2c72 7676 723b     ay();var rr,vv;r
 80a6d6a:	3d72 3027 2e27 6863 7261 6f43 6564 7441     r='0'.charCodeAt
 80a6d7a:	3028 3b29 6f66 2872 7676 303d 763b 3c76     (0);for(vv=0;vv<
 80a6d8a:	393d 2b3b 762b 2976 4942 525f 5b43 7272     =9;++vv)BI_RC[rr
 80a6d9a:	2b2b 3d5d 7676 723b 3d72 6127 2e27 6863     ++]=vv;rr='a'.ch
 80a6daa:	7261 6f43 6564 7441 3028 3b29 6f66 2872     arCodeAt(0);for(
 80a6dba:	7676 313d 3b30 7676 333c 3b36 2b2b 7676     vv=10;vv<36;++vv
 80a6dca:	4229 5f49 4352 725b 2b72 5d2b 763d 3b76     )BI_RC[rr++]=vv;
 80a6dda:	7272 273d 2741 632e 6168 4372 646f 4165     rr='A'.charCodeA
 80a6dea:	2874 2930 663b 726f 7628 3d76 3031 763b     t(0);for(vv=10;v
 80a6dfa:	3c76 3633 2b3b 762b 2976 4942 525f 5b43     v<36;++vv)BI_RC[
 80a6e0a:	7272 2b2b 3d5d 7676 663b 6e75 7463 6f69     rr++]=vv;functio
 80a6e1a:	206e 6e69 3274 6863 7261 6128 7b29 6572     n int2char(a){re
 80a6e2a:	7574 6e72 4220 5f49 4d52 632e 6168 4172     turn BI_RM.charA
 80a6e3a:	2874 2961 7d3b 7566 636e 6974 6e6f 6920     t(a);}function i
 80a6e4a:	746e 7441 6128 622c 7b29 6176 2072 3d63     ntAt(a,b){var c=
 80a6e5a:	4942 525f 5b43 2e61 6863 7261 6f43 6564     BI_RC[a.charCode
 80a6e6a:	7441 6228 5d29 723b 7465 7275 286e 3d63     At(b)];return(c=
 80a6e7a:	6e3d 6c75 296c 2d3f 3a31 3b63 667d 6e75     =null)?-1:c;}fun
 80a6e8a:	7463 6f69 206e 6e62 4370 706f 5479 286f     ction bnpCopyTo(
 80a6e9a:	2961 667b 726f 7628 7261 6220 743d 6968     a){for(var b=thi
 80a6eaa:	2e73 2d74 3b31 3e62 303d 2d3b 622d 6129     s.t-1;b>=0;--b)a
 80a6eba:	625b 3d5d 6874 7369 625b 3b5d 2e61 3d74     [b]=this[b];a.t=
 80a6eca:	6874 7369 742e 613b 732e 743d 6968 2e73     this.t;a.s=this.
 80a6eda:	3b73 667d 6e75 7463 6f69 206e 6e62 4670     s;}function bnpF
 80a6eea:	6f72 496d 746e 6128 7b29 6874 7369 742e     romInt(a){this.t
 80a6efa:	313d 743b 6968 2e73 3d73 6128 303c 3f29     =1;this.s=(a<0)?
 80a6f0a:	312d 303a 693b 2866 3e61 2930 6874 7369     -1:0;if(a>0)this
 80a6f1a:	305b 3d5d 3b61 6c65 6573 6920 2866 3c61     [0]=a;else if(a<
 80a6f2a:	312d 7429 6968 5b73 5d30 613d 742b 6968     -1)this[0]=a+thi
 80a6f3a:	2e73 5644 653b 736c 2065 6874 7369 742e     s.DV;else this.t
 80a6f4a:	303d 7d3b 7566 636e 6974 6e6f 6e20 7662     =0;}function nbv
 80a6f5a:	6128 7b29 6176 2072 3d62 626e 2869 3b29     (a){var b=nbi();
 80a6f6a:	2e62 7266 6d6f 6e49 2874 2961 723b 7465     b.fromInt(a);ret
 80a6f7a:	7275 206e 3b62 667d 6e75 7463 6f69 206e     urn b;}function 
 80a6f8a:	6e62 4670 6f72 536d 7274 6e69 2867 2c61     bnpFromString(a,
 80a6f9a:	2962 767b 7261 6320 693b 2866 3d62 313d     b){var c;if(b==1
 80a6faa:	2936 3d63 3b34 6c65 6573 6920 2866 3d62     6)c=4;else if(b=
 80a6fba:	383d 6329 333d 653b 736c 2065 6669 6228     =8)c=3;else if(b
 80a6fca:	3d3d 3532 2936 3d63 3b38 6c65 6573 6920     ==256)c=8;else i
 80a6fda:	2866 3d62 323d 6329 313d 653b 736c 2065     f(b==2)c=1;else 
 80a6fea:	6669 6228 3d3d 3233 6329 353d 653b 736c     if(b==32)c=5;els
 80a6ffa:	2065 6669 6228 3d3d 2934 3d63 3b32 6c65     e if(b==4)c=2;el
 80a700a:	6573 747b 6968 2e73 7266 6d6f 6152 6964     se{this.fromRadi
 80a701a:	2878 2c61 2962 723b 7465 7275 3b6e 747d     x(a,b);return;}t
 80a702a:	6968 2e73 3d74 3b30 6874 7369 732e 303d     his.t=0;this.s=0
 80a703a:	763b 7261 6420 613d 6c2e 6e65 7467 2c68     ;var d=a.length,
 80a704a:	3d65 6166 736c 2c65 3d66 3b30 6877 6c69     e=false,f=0;whil
 80a705a:	2865 2d2d 3e64 303d 7b29 6176 2072 3d67     e(--d>=0){var g=
 80a706a:	6328 3d3d 2938 613f 645b 265d 7830 6666     (c==8)?a[d]&0xff
 80a707a:	693a 746e 7441 6128 642c 3b29 6669 6728     :intAt(a,d);if(g
 80a708a:	303c 7b29 6669 6128 632e 6168 4172 2874     <0){if(a.charAt(
 80a709a:	2964 3d3d 2d27 2927 3d65 7274 6575 633b     d)=='-')e=true;c
 80a70aa:	6e6f 6974 756e 3b65 657d 663d 6c61 6573     ontinue;}e=false
 80a70ba:	693b 2866 3d66 303d 7429 6968 5b73 6874     ;if(f==0)this[th
 80a70ca:	7369 742e 2b2b 3d5d 3b67 6c65 6573 6920     is.t++]=g;else i
 80a70da:	2866 2b66 3e63 6874 7369 442e 2942 747b     f(f+c>this.DB){t
 80a70ea:	6968 5b73 6874 7369 742e 312d 7c5d 283d     his[this.t-1]|=(
 80a70fa:	2667 2828 3c31 283c 6874 7369 442e 2d42     g&((1<<(this.DB-
 80a710a:	2966 2d29 2931 3c29 663c 743b 6968 5b73     f))-1))<<f;this[
 80a711a:	6874 7369 742e 2b2b 3d5d 6728 3e3e 7428     this.t++]=(g>>(t
 80a712a:	6968 2e73 4244 662d 2929 7d3b 6c65 6573     his.DB-f));}else
 80a713a:	7420 6968 5b73 6874 7369 742e 312d 7c5d      this[this.t-1]|
 80a714a:	673d 3c3c 3b66 2b66 633d 693b 2866 3e66     =g<<f;f+=c;if(f>
 80a715a:	743d 6968 2e73 4244 6629 3d2d 6874 7369     =this.DB)f-=this
 80a716a:	442e 3b42 697d 2866 3d63 383d 2626 6128     .DB;}if(c==8&&(a
 80a717a:	305b 265d 7830 3038 2129 303d 7b29 6874     [0]&0x80)!=0){th
 80a718a:	7369 732e 2d3d 3b31 6669 6628 303e 7429     is.s=-1;if(f>0)t
 80a719a:	6968 5b73 6874 7369 742e 312d 7c5d 283d     his[this.t-1]|=(
 80a71aa:	3128 3c3c 7428 6968 2e73 4244 662d 2929     (1<<(this.DB-f))
 80a71ba:	312d 3c29 663c 7d3b 6874 7369 632e 616c     -1)<<f;}this.cla
 80a71ca:	706d 2928 693b 2866 2965 6942 4967 746e     mp();if(e)BigInt
 80a71da:	6765 7265 5a2e 5245 2e4f 7573 5462 286f     eger.ZERO.subTo(
 80a71ea:	6874 7369 742c 6968 2973 7d3b 7566 636e     this,this);}func
 80a71fa:	6974 6e6f 6220 706e 6c43 6d61 2870 7b29     tion bnpClamp(){
 80a720a:	6176 2072 3d61 6874 7369 732e 7426 6968     var a=this.s&thi
 80a721a:	2e73 4d44 773b 6968 656c 7428 6968 2e73     s.DM;while(this.
 80a722a:	3e74 2630 7426 6968 5b73 6874 7369 742e     t>0&&this[this.t
 80a723a:	312d 3d5d 613d 2d29 742d 6968 2e73 3b74     -1]==a)--this.t;
 80a724a:	667d 6e75 7463 6f69 206e 6e62 6f54 7453     }function bnToSt
 80a725a:	6972 676e 6128 7b29 6669 7428 6968 2e73     ring(a){if(this.
 80a726a:	3c73 2930 6572 7574 6e72 2720 272d 742b     s<0)return '-'+t
 80a727a:	6968 2e73 656e 6167 6574 2928 742e 536f     his.negate().toS
 80a728a:	7274 6e69 2867 2961 763b 7261 6220 693b     tring(a);var b;i
 80a729a:	2866 3d61 313d 2936 3d62 3b34 6c65 6573     f(a==16)b=4;else
 80a72aa:	6920 2866 3d61 383d 6229 333d 653b 736c      if(a==8)b=3;els
 80a72ba:	2065 6669 6128 3d3d 2932 3d62 3b31 6c65     e if(a==2)b=1;el
 80a72ca:	6573 6920 2866 3d61 333d 2932 3d62 3b35     se if(a==32)b=5;
 80a72da:	6c65 6573 6920 2866 3d61 343d 6229 323d     else if(a==4)b=2
 80a72ea:	653b 736c 2065 6572 7574 6e72 7420 6968     ;else return thi
 80a72fa:	2e73 6f74 6152 6964 2878 2961 763b 7261     s.toRadix(a);var
 80a730a:	6320 283d 3c31 623c 2d29 2c31 2c64 3d65      c=(1<<b)-1,d,e=
 80a731a:	6166 736c 2c65 3d66 2727 672c 743d 6968     false,f='',g=thi
 80a732a:	2e73 3b74 6176 2072 3d68 6874 7369 442e     s.t;var h=this.D
 80a733a:	2d42 6728 742a 6968 2e73 4244 2529 3b62     B-(g*this.DB)%b;
 80a734a:	6669 6728 2d2d 303e 7b29 6669 6828 743c     if(g-->0){if(h<t
 80a735a:	6968 2e73 4244 2626 6428 743d 6968 5b73     his.DB&&(d=this[
 80a736a:	5d67 3e3e 2968 303e 7b29 3d65 7274 6575     g]>>h)>0){e=true
 80a737a:	663b 693d 746e 6332 6168 2872 2964 7d3b     ;f=int2char(d);}
 80a738a:	6877 6c69 2865 3e67 303d 7b29 6669 6828     while(g>=0){if(h
 80a739a:	623c 7b29 3d64 7428 6968 5b73 5d67 2826     <b){d=(this[g]&(
 80a73aa:	3128 3c3c 2968 312d 2929 3c3c 6228 682d     (1<<h)-1))<<(b-h
 80a73ba:	3b29 7c64 743d 6968 5b73 2d2d 5d67 3e3e     );d|=this[--g]>>
 80a73ca:	6828 3d2b 6874 7369 442e 2d42 2962 7d3b     (h+=this.DB-b);}
 80a73da:	6c65 6573 647b 283d 6874 7369 675b 3e5d     else{d=(this[g]>
 80a73ea:	283e 2d68 623d 2929 6326 693b 2866 3c68     >(h-=b))&c;if(h<
 80a73fa:	303d 7b29 2b68 743d 6968 2e73 4244 2d3b     =0){h+=this.DB;-
 80a740a:	672d 7d3b 697d 2866 3e64 2930 3d65 7274     -g;}}if(d>0)e=tr
 80a741a:	6575 693b 2866 2965 2b66 693d 746e 6332     ue;if(e)f+=int2c
 80a742a:	6168 2872 2964 7d3b 727d 7465 7275 206e     har(d);}}return 
 80a743a:	3f65 3a66 3027 3b27 667d 6e75 7463 6f69     e?f:'0';}functio
 80a744a:	206e 6e62 654e 6167 6574 2928 767b 7261     n bnNegate(){var
 80a745a:	6120 6e3d 6962 2928 423b 6769 6e49 6574      a=nbi();BigInte
 80a746a:	6567 2e72 455a 4f52 732e 6275 6f54 7428     ger.ZERO.subTo(t
 80a747a:	6968 2c73 2961 723b 7465 7275 206e 3b61     his,a);return a;
 80a748a:	667d 6e75 7463 6f69 206e 6e62 6241 2873     }function bnAbs(
 80a749a:	7b29 6572 7574 6e72 7428 6968 2e73 3c73     ){return(this.s<
 80a74aa:	2930 743f 6968 2e73 656e 6167 6574 2928     0)?this.negate()
 80a74ba:	743a 6968 3b73 667d 6e75 7463 6f69 206e     :this;}function 
 80a74ca:	6e62 6f43 706d 7261 5465 286f 2961 767b     bnCompareTo(a){v
 80a74da:	7261 6220 743d 6968 2e73 2d73 2e61 3b73     ar b=this.s-a.s;
 80a74ea:	6669 6228 3d21 2930 6572 7574 6e72 6220     if(b!=0)return b
 80a74fa:	763b 7261 6320 743d 6968 2e73 3b74 3d62     ;var c=this.t;b=
 80a750a:	2d63 2e61 3b74 6669 6228 3d21 2930 6572     c-a.t;if(b!=0)re
 80a751a:	7574 6e72 7428 6968 2e73 3c73 2930 2d3f     turn(this.s<0)?-
 80a752a:	3a62 3b62 6877 6c69 2865 2d2d 3e63 303d     b:b;while(--c>=0
 80a753a:	6929 2866 6228 743d 6968 5b73 5d63 612d     )if((b=this[c]-a
 80a754a:	635b 295d 3d21 2930 6572 7574 6e72 6220     [c])!=0)return b
 80a755a:	723b 7465 7275 206e 3b30 667d 6e75 7463     ;return 0;}funct
 80a756a:	6f69 206e 626e 7469 2873 2961 767b 7261     ion nbits(a){var
 80a757a:	6220 313d 632c 693b 2866 6328 613d 3e3e      b=1,c;if((c=a>>
 80a758a:	313e 2936 3d21 2930 617b 633d 623b 3d2b     >16)!=0){a=c;b+=
 80a759a:	3631 7d3b 6669 2828 3d63 3e61 383e 2129     16;}if((c=a>>8)!
 80a75aa:	303d 7b29 3d61 3b63 2b62 383d 7d3b 6669     =0){a=c;b+=8;}if
 80a75ba:	2828 3d63 3e61 343e 2129 303d 7b29 3d61     ((c=a>>4)!=0){a=
 80a75ca:	3b63 2b62 343d 7d3b 6669 2828 3d63 3e61     c;b+=4;}if((c=a>
 80a75da:	323e 2129 303d 7b29 3d61 3b63 2b62 323d     >2)!=0){a=c;b+=2
 80a75ea:	7d3b 6669 2828 3d63 3e61 313e 2129 303d     ;}if((c=a>>1)!=0
 80a75fa:	7b29 3d61 3b63 2b62 313d 7d3b 6572 7574     ){a=c;b+=1;}retu
 80a760a:	6e72 6220 7d3b 7566 636e 6974 6e6f 6220     rn b;}function b
 80a761a:	426e 7469 654c 676e 6874 2928 697b 2866     nBitLength(){if(
 80a762a:	6874 7369 742e 3d3c 2930 6572 7574 6e72     this.t<=0)return
 80a763a:	3020 723b 7465 7275 206e 6874 7369 442e      0;return this.D
 80a764a:	2a42 7428 6968 2e73 2d74 2931 6e2b 6962     B*(this.t-1)+nbi
 80a765a:	7374 7428 6968 5b73 6874 7369 742e 312d     ts(this[this.t-1
 80a766a:	5e5d 7428 6968 2e73 2673 6874 7369 442e     ]^(this.s&this.D
 80a767a:	294d 3b29 667d 6e75 7463 6f69 206e 6e62     M));}function bn
 80a768a:	4470 534c 6968 7466 6f54 6128 622c 7b29     pDLShiftTo(a,b){
 80a769a:	6176 2072 3b63 6f66 2872 3d63 6874 7369     var c;for(c=this
 80a76aa:	742e 312d 633b 3d3e 3b30 2d2d 2963 5b62     .t-1;c>=0;--c)b[
 80a76ba:	2b63 5d61 743d 6968 5b73 5d63 663b 726f     c+a]=this[c];for
 80a76ca:	6328 613d 312d 633b 3d3e 3b30 2d2d 2963     (c=a-1;c>=0;--c)
 80a76da:	5b62 5d63 303d 623b 742e 743d 6968 2e73     b[c]=0;b.t=this.
 80a76ea:	2b74 3b61 2e62 3d73 6874 7369 732e 7d3b     t+a;b.s=this.s;}
 80a76fa:	7566 636e 6974 6e6f 6220 706e 5244 6853     function bnpDRSh
 80a770a:	6669 5474 286f 2c61 2962 667b 726f 7628     iftTo(a,b){for(v
 80a771a:	7261 6320 613d 633b 743c 6968 2e73 3b74     ar c=a;c<this.t;
 80a772a:	2b2b 2963 5b62 2d63 5d61 743d 6968 5b73     ++c)b[c-a]=this[
 80a773a:	5d63 623b 742e 4d3d 7461 2e68 616d 2878     c];b.t=Math.max(
 80a774a:	6874 7369 742e 612d 302c 3b29 2e62 3d73     this.t-a,0);b.s=
 80a775a:	6874 7369 732e 7d3b 7566 636e 6974 6e6f     this.s;}function
 80a776a:	6220 706e 534c 6968 7466 6f54 6128 622c      bnpLShiftTo(a,b
 80a777a:	7b29 6176 2072 3d63 2561 6874 7369 442e     ){var c=a%this.D
 80a778a:	3b42 6176 2072 3d64 6874 7369 442e 2d42     B;var d=this.DB-
 80a779a:	3b63 6176 2072 3d65 3128 3c3c 2964 312d     c;var e=(1<<d)-1
 80a77aa:	763b 7261 6620 4d3d 7461 2e68 6c66 6f6f     ;var f=Math.floo
 80a77ba:	2872 2f61 6874 7369 442e 2942 672c 283d     r(a/this.DB),g=(
 80a77ca:	6874 7369 732e 3c3c 2963 7426 6968 2e73     this.s<<c)&this.
 80a77da:	4d44 682c 663b 726f 6828 743d 6968 2e73     DM,h;for(h=this.
 80a77ea:	2d74 3b31 3e68 303d 2d3b 682d 7b29 5b62     t-1;h>=0;--h){b[
 80a77fa:	2b68 2b66 5d31 283d 6874 7369 685b 3e5d     h+f+1]=(this[h]>
 80a780a:	643e 7c29 3b67 3d67 7428 6968 5b73 5d68     >d)|g;g=(this[h]
 80a781a:	6526 3c29 633c 7d3b 6f66 2872 3d68 2d66     &e)<<c;}for(h=f-
 80a782a:	3b31 3e68 303d 2d3b 682d 6229 685b 3d5d     1;h>=0;--h)b[h]=
 80a783a:	3b30 5b62 5d66 673d 623b 742e 743d 6968     0;b[f]=g;b.t=thi
 80a784a:	2e73 2b74 2b66 3b31 2e62 3d73 6874 7369     s.t+f+1;b.s=this
 80a785a:	732e 623b 632e 616c 706d 2928 7d3b 7600          .s;b.clamp();}.

080a7869 <_ZL6rng_js>:
 80a7869:	6176 2072 6e72 5f67 7473 7461 3b65 6176     var rng_state;va
 80a7879:	2072 6e72 5f67 6f70 6c6f 763b 7261 7220     r rng_pool;var r
 80a7889:	676e 705f 7470 3b72 7566 636e 6974 6e6f     ng_pptr;function
 80a7899:	7220 676e 735f 6565 5f64 6e69 2874 2961      rng_seed_int(a)
 80a78a9:	727b 676e 705f 6f6f 5b6c 6e72 5f67 7070     {rng_pool[rng_pp
 80a78b9:	7274 2b2b 5e5d 613d 3226 3535 723b 676e     tr++]^=a&255;rng
 80a78c9:	705f 6f6f 5b6c 6e72 5f67 7070 7274 2b2b     _pool[rng_pptr++
 80a78d9:	5e5d 283d 3e61 383e 2629 3532 3b35 6e72     ]^=(a>>8)&255;rn
 80a78e9:	5f67 6f70 6c6f 725b 676e 705f 7470 2b72     g_pool[rng_pptr+
 80a78f9:	5d2b 3d5e 6128 3e3e 3631 2629 3532 3b35     +]^=(a>>16)&255;
 80a7909:	6e72 5f67 6f70 6c6f 725b 676e 705f 7470     rng_pool[rng_ppt
 80a7919:	2b72 5d2b 3d5e 6128 3e3e 3432 2629 3532     r++]^=(a>>24)&25
 80a7929:	3b35 6669 7228 676e 705f 7470 3e72 723d     5;if(rng_pptr>=r
 80a7939:	676e 705f 6973 657a 7229 676e 705f 7470     ng_psize)rng_ppt
 80a7949:	2d72 723d 676e 705f 6973 657a 7d3b 7566     r-=rng_psize;}fu
 80a7959:	636e 6974 6e6f 7220 676e 735f 6565 5f64     nction rng_seed_
 80a7969:	6974 656d 2928 727b 676e 735f 6565 5f64     time(){rng_seed_
 80a7979:	6e69 2874 656e 2077 6144 6574 2928 672e     int(new Date().g
 80a7989:	7465 6954 656d 2928 3b29 697d 2866 6e72     etTime());}if(rn
 80a7999:	5f67 6f70 6c6f 3d3d 756e 6c6c 7b29 6e72     g_pool==null){rn
 80a79a9:	5f67 6f70 6c6f 6e3d 7765 4120 7272 7961     g_pool=new Array
 80a79b9:	2928 723b 676e 705f 7470 3d72 3b30 6176     ();rng_pptr=0;va
 80a79c9:	2072 3b74 6669 7728 6e69 6f64 2e77 7263     r t;if(window.cr
 80a79d9:	7079 6f74 2626 6977 646e 776f 632e 7972     ypto&&window.cry
 80a79e9:	7470 2e6f 6567 5274 6e61 6f64 566d 6c61     pto.getRandomVal
 80a79f9:	6575 2973 767b 7261 7520 3d61 656e 2077     ues){var ua=new 
 80a7a09:	6955 746e 4138 7272 7961 3328 2932 773b     Uint8Array(32);w
 80a7a19:	6e69 6f64 2e77 7263 7079 6f74 672e 7465     indow.crypto.get
 80a7a29:	6152 646e 6d6f 6156 756c 7365 7528 2961     RandomValues(ua)
 80a7a39:	663b 726f 7428 303d 743b 333c 3b32 2b2b     ;for(t=0;t<32;++
 80a7a49:	2974 6e72 5f67 6f70 6c6f 725b 676e 705f     t)rng_pool[rng_p
 80a7a59:	7470 2b72 5d2b 753d 5b61 5d74 7d3b 6669     ptr++]=ua[t];}if
 80a7a69:	6e28 7661 6769 7461 726f 612e 7070 614e     (navigator.appNa
 80a7a79:	656d 3d3d 4e27 7465 6373 7061 2765 2626     me=='Netscape'&&
 80a7a89:	616e 6976 6167 6f74 2e72 7061 5670 7265     navigator.appVer
 80a7a99:	6973 6e6f 273c 2735 2626 6977 646e 776f     sion<'5'&&window
 80a7aa9:	632e 7972 7470 296f 767b 7261 7a20 773d     .crypto){var z=w
 80a7ab9:	6e69 6f64 2e77 7263 7079 6f74 722e 6e61     indow.crypto.ran
 80a7ac9:	6f64 286d 3233 3b29 6f66 2872 3d74 3b30     dom(32);for(t=0;
 80a7ad9:	3c74 2e7a 656c 676e 6874 2b3b 742b 7229     t<z.length;++t)r
 80a7ae9:	676e 705f 6f6f 5b6c 6e72 5f67 7070 7274     ng_pool[rng_pptr
 80a7af9:	2b2b 3d5d 2e7a 6863 7261 6f43 6564 7441     ++]=z.charCodeAt
 80a7b09:	7428 2629 3532 3b35 777d 6968 656c 7228     (t)&255;}while(r
 80a7b19:	676e 705f 7470 3c72 6e72 5f67 7370 7a69     ng_pptr<rng_psiz
 80a7b29:	2965 747b 4d3d 7461 2e68 6c66 6f6f 2872     e){t=Math.floor(
 80a7b39:	3536 3335 2a36 614d 6874 722e 6e61 6f64     65536*Math.rando
 80a7b49:	286d 2929 723b 676e 705f 6f6f 5b6c 6e72     m());rng_pool[rn
 80a7b59:	5f67 7070 7274 2b2b 3d5d 3e74 3e3e 3b38     g_pptr++]=t>>>8;
 80a7b69:	6e72 5f67 6f70 6c6f 725b 676e 705f 7470     rng_pool[rng_ppt
 80a7b79:	2b72 5d2b 743d 3226 3535 7d3b 6e72 5f67     r++]=t&255;}rng_
 80a7b89:	7070 7274 303d 723b 676e 735f 6565 5f64     pptr=0;rng_seed_
 80a7b99:	6974 656d 2928 7d3b 7566 636e 6974 6e6f     time();}function
 80a7ba9:	7220 676e 675f 7465 625f 7479 2865 7b29      rng_get_byte(){
 80a7bb9:	6669 7228 676e 735f 6174 6574 3d3d 756e     if(rng_state==nu
 80a7bc9:	6c6c 7b29 6e72 5f67 6573 6465 745f 6d69     ll){rng_seed_tim
 80a7bd9:	2865 3b29 6e72 5f67 7473 7461 3d65 7270     e();rng_state=pr
 80a7be9:	676e 6e5f 7765 7473 7461 2865 3b29 6e72     ng_newstate();rn
 80a7bf9:	5f67 7473 7461 2e65 6e69 7469 7228 676e     g_state.init(rng
 80a7c09:	705f 6f6f 296c 663b 726f 7228 676e 705f     _pool);for(rng_p
 80a7c19:	7470 3d72 3b30 6e72 5f67 7070 7274 723c     ptr=0;rng_pptr<r
 80a7c29:	676e 705f 6f6f 2e6c 656c 676e 6874 2b3b     ng_pool.length;+
 80a7c39:	722b 676e 705f 7470 2972 6e72 5f67 6f70     +rng_pptr)rng_po
 80a7c49:	6c6f 725b 676e 705f 7470 5d72 303d 723b     ol[rng_pptr]=0;r
 80a7c59:	676e 705f 7470 3d72 3b30 727d 7465 7275     ng_pptr=0;}retur
 80a7c69:	206e 6e72 5f67 7473 7461 2e65 656e 7478     n rng_state.next
 80a7c79:	2928 7d3b 7566 636e 6974 6e6f 7220 676e     ();}function rng
 80a7c89:	675f 7465 625f 7479 7365 6128 7b29 6176     _get_bytes(a){va
 80a7c99:	2072 3b62 6f66 2872 3d62 3b30 3c62 2e61     r b;for(b=0;b<a.
 80a7ca9:	656c 676e 6874 2b3b 622b 6129 625b 3d5d     length;++b)a[b]=
 80a7cb9:	6e72 5f67 6567 5f74 7962 6574 2928 7d3b     rng_get_byte();}
 80a7cc9:	7566 636e 6974 6e6f 5320 6365 7275 5265     function SecureR
 80a7cd9:	6e61 6f64 286d 7b29 537d 6365 7275 5265     andom(){}SecureR
 80a7ce9:	6e61 6f64 2e6d 7270 746f 746f 7079 2e65     andom.prototype.
 80a7cf9:	656e 7478 7942 6574 3d73 6e72 5f67 6567     nextBytes=rng_ge
 80a7d09:	5f74 7962 6574 3b73 0000 2c00                    t_bytes;...

080a7d14 <CSWTCH.210>:
 80a7d14:	012c 0000 0018 0000 01f4 0000 012c 0000     ,...........,...
 80a7d24:	0050 0000 6162 6475 5300 7265 6169 006c     P...baud.Serial.
 80a7d34:	5355 5342 7265 6169 316c 7400 7079 0065     USBSerial1.type.
 80a7d44:	6170 6172 006d 6d63 0064 6469 6800 646e     param.cmd.id.hnd
 80a7d54:	7300 7274 006d 6966 746c 6c00 6c76 6100     .strm.filt.lvl.a
 80a7d64:	6464 6148 646e 656c 0072 6572 6f6d 6576     ddHandler.remove
 80a7d74:	6148 646e 656c 0072 6e65 6d75 6148 646e     Handler.enumHand
 80a7d84:	656c 7372 4a00 4f53 534e 7274 6165 4c6d     lers.JSONStreamL
 80a7d94:	676f 6148 646e 656c 0072 7061 0070 3025     ogHandler.app.%0
 80a7da4:	3031 2075 5d00 0020 6425 2c00 0020 2928     10u .] .%d., .()
 80a7db4:	203a 2000 005b 6f63 6564 3d20 0020 6925     : . [.code = .%i
 80a7dc4:	6400 7465 6961 736c 3d20 0020 0066 6e6c     .details = .f.ln
 80a7dd4:	6600 006e 6f63 6564 6400 7465 6961 006c     .fn.code.detail.
 80a7de4:	6f6e 656e 7400 6172 6563 6900 666e 006f     none.trace.info.
 80a7df4:	6177 6e72 6500 7272 726f 7000 6e61 6369     warn.error.panic
 80a7e04:	6100 6c6c 5a00 2500 302b 6433 253a 3230     .all.Z.%+03d:%02
 80a7e14:	0075 5925 252d 2d6d 6425 2554 3a48 4d25     u.%Y-%m-%dT%H:%M
 80a7e24:	253a 2553 007a 7361 7463 6d69 0065 0000     :%S%z.asctime...

080a7e34 <_ZTV9IPAddress>:
	...
 80a7e3c:	1deb 080a 1ddb 080a 1ddd 080a               ............

080a7e48 <_ZTV9USBSerial>:
	...
 80a7e50:	1ea5 080a 1ef5 080a 1f03 080a 1aa9 080a     ................
 80a7e60:	1ee1 080a 1ea7 080a 1ebd 080a 1eef 080a     ................
 80a7e70:	1ed3 080a 1ea1 080a                         ........

080a7e78 <_ZTV11USARTSerial>:
	...
 80a7e80:	203d 080a 208d 080a 209b 080a 1aa9 080a     = ... ... ......
 80a7e90:	2051 080a 2073 080a 205f 080a 2087 080a     Q ..s .._ ... ..
 80a7ea0:	203f 080a 2043 080a                         ? ..C ..

080a7ea8 <_ZTV7TwoWire>:
	...
 80a7eb0:	2141 080a 218b 080a 2163 080a 2143 080a     A!...!..c!..C!..
 80a7ec0:	216b 080a 2173 080a 217b 080a 2183 080a     k!..s!..{!...!..

080a7ed0 <_ZTVN5spark9WiFiClassE>:
	...
 80a7ed8:	2285 080a 227b 080a 2271 080a 21ef 080a     ."..{"..q"...!..
 80a7ee8:	1bd9 080a 2265 080a 2259 080a 2251 080a     ....e"..Y"..Q"..
 80a7ef8:	2247 080a 223d 080a 21f9 080a               G"..="...!..

080a7f04 <_ZTVN5spark12NetworkClassE>:
	...
 80a7f0c:	22a5 080a 22af 080a 22b9 080a 22c3 080a     ."..."..."..."..
 80a7f1c:	22cd 080a 22d9 080a 22e5 080a 22f1 080a     ."..."..."..."..
 80a7f2c:	22f9 080a 2303 080a 230d 080a               ."...#...#..

080a7f38 <_ZSt7nothrow>:
 80a7f38:	0000 0000                                   ....

080a7f3c <__sf_fake_stdin>:
	...

080a7f5c <__sf_fake_stdout>:
	...

080a7f7c <__sf_fake_stderr>:
	...
 80a7f9c:	0043                                        C.

080a7f9e <link_const_variable_data_end>:
	...

080a7fa0 <link_constructors_location>:
 80a7fa0:	080a0279 	.word	0x080a0279
 80a7fa4:	080a15a5 	.word	0x080a15a5
 80a7fa8:	080a1969 	.word	0x080a1969
 80a7fac:	080a1be5 	.word	0x080a1be5
 80a7fb0:	080a1bf5 	.word	0x080a1bf5
 80a7fb4:	080a1c2d 	.word	0x080a1c2d
 80a7fb8:	080a2291 	.word	0x080a2291
 80a7fbc:	080a235d 	.word	0x080a235d
 80a7fc0:	080a2451 	.word	0x080a2451
 80a7fc4:	080a2545 	.word	0x080a2545
 80a7fc8:	080a25c9 	.word	0x080a25c9
 80a7fcc:	080a268d 	.word	0x080a268d
 80a7fd0:	080a2751 	.word	0x080a2751

080a7fd4 <link_constructors_end>:
	...
